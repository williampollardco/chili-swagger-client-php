<?php
/**
 * ResourcesApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Rest API v1.2
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1.2
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.27
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * ResourcesApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ResourcesApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation restApiAssetAddOrUpdateSubjectInfo
     *
     * AssetAddOrUpdateSubjectInfo
     *
     * @param  string $asset_id The asset ID (required)
     * @param  \Swagger\Client\Model\AssetAddOrUpdateSubjectInfoBodyWrapper $body  (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiAssetAddOrUpdateSubjectInfo($asset_id, $body)
    {
        list($response) = $this->restApiAssetAddOrUpdateSubjectInfoWithHttpInfo($asset_id, $body);
        return $response;
    }

    /**
     * Operation restApiAssetAddOrUpdateSubjectInfoWithHttpInfo
     *
     * AssetAddOrUpdateSubjectInfo
     *
     * @param  string $asset_id The asset ID (required)
     * @param  \Swagger\Client\Model\AssetAddOrUpdateSubjectInfoBodyWrapper $body  (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiAssetAddOrUpdateSubjectInfoWithHttpInfo($asset_id, $body)
    {
        $returnType = 'object';
        $request = $this->restApiAssetAddOrUpdateSubjectInfoRequest($asset_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiAssetAddOrUpdateSubjectInfoAsync
     *
     * AssetAddOrUpdateSubjectInfo
     *
     * @param  string $asset_id The asset ID (required)
     * @param  \Swagger\Client\Model\AssetAddOrUpdateSubjectInfoBodyWrapper $body  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiAssetAddOrUpdateSubjectInfoAsync($asset_id, $body)
    {
        return $this->restApiAssetAddOrUpdateSubjectInfoAsyncWithHttpInfo($asset_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiAssetAddOrUpdateSubjectInfoAsyncWithHttpInfo
     *
     * AssetAddOrUpdateSubjectInfo
     *
     * @param  string $asset_id The asset ID (required)
     * @param  \Swagger\Client\Model\AssetAddOrUpdateSubjectInfoBodyWrapper $body  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiAssetAddOrUpdateSubjectInfoAsyncWithHttpInfo($asset_id, $body)
    {
        $returnType = 'object';
        $request = $this->restApiAssetAddOrUpdateSubjectInfoRequest($asset_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiAssetAddOrUpdateSubjectInfo'
     *
     * @param  string $asset_id The asset ID (required)
     * @param  \Swagger\Client\Model\AssetAddOrUpdateSubjectInfoBodyWrapper $body  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiAssetAddOrUpdateSubjectInfoRequest($asset_id, $body)
    {
        // verify the required parameter 'asset_id' is set
        if ($asset_id === null || (is_array($asset_id) && count($asset_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $asset_id when calling restApiAssetAddOrUpdateSubjectInfo'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling restApiAssetAddOrUpdateSubjectInfo'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/assets/{assetID}/subjectinfo';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($asset_id !== null) {
            $resourcePath = str_replace(
                '{' . 'assetID' . '}',
                ObjectSerializer::toPathValue($asset_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiAssetDeleteSubjectInfo
     *
     * AssetDeleteSubjectInfo
     *
     * @param  string $asset_id The asset ID (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiAssetDeleteSubjectInfo($asset_id)
    {
        list($response) = $this->restApiAssetDeleteSubjectInfoWithHttpInfo($asset_id);
        return $response;
    }

    /**
     * Operation restApiAssetDeleteSubjectInfoWithHttpInfo
     *
     * AssetDeleteSubjectInfo
     *
     * @param  string $asset_id The asset ID (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiAssetDeleteSubjectInfoWithHttpInfo($asset_id)
    {
        $returnType = 'object';
        $request = $this->restApiAssetDeleteSubjectInfoRequest($asset_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiAssetDeleteSubjectInfoAsync
     *
     * AssetDeleteSubjectInfo
     *
     * @param  string $asset_id The asset ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiAssetDeleteSubjectInfoAsync($asset_id)
    {
        return $this->restApiAssetDeleteSubjectInfoAsyncWithHttpInfo($asset_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiAssetDeleteSubjectInfoAsyncWithHttpInfo
     *
     * AssetDeleteSubjectInfo
     *
     * @param  string $asset_id The asset ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiAssetDeleteSubjectInfoAsyncWithHttpInfo($asset_id)
    {
        $returnType = 'object';
        $request = $this->restApiAssetDeleteSubjectInfoRequest($asset_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiAssetDeleteSubjectInfo'
     *
     * @param  string $asset_id The asset ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiAssetDeleteSubjectInfoRequest($asset_id)
    {
        // verify the required parameter 'asset_id' is set
        if ($asset_id === null || (is_array($asset_id) && count($asset_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $asset_id when calling restApiAssetDeleteSubjectInfo'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/assets/{assetID}/subjectinfo';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($asset_id !== null) {
            $resourcePath = str_replace(
                '{' . 'assetID' . '}',
                ObjectSerializer::toPathValue($asset_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiAssetGetImageInfo
     *
     * AssetGetImageInfo
     *
     * @param  string $asset_id The asset ID (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiAssetGetImageInfo($asset_id)
    {
        list($response) = $this->restApiAssetGetImageInfoWithHttpInfo($asset_id);
        return $response;
    }

    /**
     * Operation restApiAssetGetImageInfoWithHttpInfo
     *
     * AssetGetImageInfo
     *
     * @param  string $asset_id The asset ID (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiAssetGetImageInfoWithHttpInfo($asset_id)
    {
        $returnType = 'object';
        $request = $this->restApiAssetGetImageInfoRequest($asset_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiAssetGetImageInfoAsync
     *
     * AssetGetImageInfo
     *
     * @param  string $asset_id The asset ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiAssetGetImageInfoAsync($asset_id)
    {
        return $this->restApiAssetGetImageInfoAsyncWithHttpInfo($asset_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiAssetGetImageInfoAsyncWithHttpInfo
     *
     * AssetGetImageInfo
     *
     * @param  string $asset_id The asset ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiAssetGetImageInfoAsyncWithHttpInfo($asset_id)
    {
        $returnType = 'object';
        $request = $this->restApiAssetGetImageInfoRequest($asset_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiAssetGetImageInfo'
     *
     * @param  string $asset_id The asset ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiAssetGetImageInfoRequest($asset_id)
    {
        // verify the required parameter 'asset_id' is set
        if ($asset_id === null || (is_array($asset_id) && count($asset_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $asset_id when calling restApiAssetGetImageInfo'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/assets/{assetID}/imageinfo';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($asset_id !== null) {
            $resourcePath = str_replace(
                '{' . 'assetID' . '}',
                ObjectSerializer::toPathValue($asset_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiAssetGetSubjectInfo
     *
     * AssetGetSubjectInfo
     *
     * @param  string $asset_id The asset ID (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiAssetGetSubjectInfo($asset_id)
    {
        list($response) = $this->restApiAssetGetSubjectInfoWithHttpInfo($asset_id);
        return $response;
    }

    /**
     * Operation restApiAssetGetSubjectInfoWithHttpInfo
     *
     * AssetGetSubjectInfo
     *
     * @param  string $asset_id The asset ID (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiAssetGetSubjectInfoWithHttpInfo($asset_id)
    {
        $returnType = 'object';
        $request = $this->restApiAssetGetSubjectInfoRequest($asset_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiAssetGetSubjectInfoAsync
     *
     * AssetGetSubjectInfo
     *
     * @param  string $asset_id The asset ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiAssetGetSubjectInfoAsync($asset_id)
    {
        return $this->restApiAssetGetSubjectInfoAsyncWithHttpInfo($asset_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiAssetGetSubjectInfoAsyncWithHttpInfo
     *
     * AssetGetSubjectInfo
     *
     * @param  string $asset_id The asset ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiAssetGetSubjectInfoAsyncWithHttpInfo($asset_id)
    {
        $returnType = 'object';
        $request = $this->restApiAssetGetSubjectInfoRequest($asset_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiAssetGetSubjectInfo'
     *
     * @param  string $asset_id The asset ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiAssetGetSubjectInfoRequest($asset_id)
    {
        // verify the required parameter 'asset_id' is set
        if ($asset_id === null || (is_array($asset_id) && count($asset_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $asset_id when calling restApiAssetGetSubjectInfo'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/assets/{assetID}/subjectinfo';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($asset_id !== null) {
            $resourcePath = str_replace(
                '{' . 'assetID' . '}',
                ObjectSerializer::toPathValue($asset_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiDocumentCopyAnnotations
     *
     * DocumentCopyAnnotations
     *
     * @param  string $from_item_id The original document&#39;s ID (required)
     * @param  string $to_item_id The new document&#39;s ID (required)
     * @param  bool $replace_existing_annotations If true, all existing annotations are first removed from the target document (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiDocumentCopyAnnotations($from_item_id, $to_item_id, $replace_existing_annotations = null)
    {
        list($response) = $this->restApiDocumentCopyAnnotationsWithHttpInfo($from_item_id, $to_item_id, $replace_existing_annotations);
        return $response;
    }

    /**
     * Operation restApiDocumentCopyAnnotationsWithHttpInfo
     *
     * DocumentCopyAnnotations
     *
     * @param  string $from_item_id The original document&#39;s ID (required)
     * @param  string $to_item_id The new document&#39;s ID (required)
     * @param  bool $replace_existing_annotations If true, all existing annotations are first removed from the target document (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiDocumentCopyAnnotationsWithHttpInfo($from_item_id, $to_item_id, $replace_existing_annotations = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentCopyAnnotationsRequest($from_item_id, $to_item_id, $replace_existing_annotations);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiDocumentCopyAnnotationsAsync
     *
     * DocumentCopyAnnotations
     *
     * @param  string $from_item_id The original document&#39;s ID (required)
     * @param  string $to_item_id The new document&#39;s ID (required)
     * @param  bool $replace_existing_annotations If true, all existing annotations are first removed from the target document (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentCopyAnnotationsAsync($from_item_id, $to_item_id, $replace_existing_annotations = null)
    {
        return $this->restApiDocumentCopyAnnotationsAsyncWithHttpInfo($from_item_id, $to_item_id, $replace_existing_annotations)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiDocumentCopyAnnotationsAsyncWithHttpInfo
     *
     * DocumentCopyAnnotations
     *
     * @param  string $from_item_id The original document&#39;s ID (required)
     * @param  string $to_item_id The new document&#39;s ID (required)
     * @param  bool $replace_existing_annotations If true, all existing annotations are first removed from the target document (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentCopyAnnotationsAsyncWithHttpInfo($from_item_id, $to_item_id, $replace_existing_annotations = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentCopyAnnotationsRequest($from_item_id, $to_item_id, $replace_existing_annotations);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiDocumentCopyAnnotations'
     *
     * @param  string $from_item_id The original document&#39;s ID (required)
     * @param  string $to_item_id The new document&#39;s ID (required)
     * @param  bool $replace_existing_annotations If true, all existing annotations are first removed from the target document (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiDocumentCopyAnnotationsRequest($from_item_id, $to_item_id, $replace_existing_annotations = null)
    {
        // verify the required parameter 'from_item_id' is set
        if ($from_item_id === null || (is_array($from_item_id) && count($from_item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from_item_id when calling restApiDocumentCopyAnnotations'
            );
        }
        // verify the required parameter 'to_item_id' is set
        if ($to_item_id === null || (is_array($to_item_id) && count($to_item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to_item_id when calling restApiDocumentCopyAnnotations'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/documents/{toItemID}/annotations/copy';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from_item_id !== null) {
            $queryParams['fromItemID'] = ObjectSerializer::toQueryValue($from_item_id);
        }
        // query params
        if ($replace_existing_annotations !== null) {
            $queryParams['replaceExistingAnnotations'] = ObjectSerializer::toQueryValue($replace_existing_annotations);
        }

        // path params
        if ($to_item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'toItemID' . '}',
                ObjectSerializer::toPathValue($to_item_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiDocumentCopyDocumentEventActions
     *
     * DocumentCopyDocumentEventActions
     *
     * @param  string $from_item_id The original document&#39;s ID (required)
     * @param  string $to_item_id The new document&#39;s ID (required)
     * @param  bool $replace_existing_actions If true, all existing actions are first removed from the target document (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiDocumentCopyDocumentEventActions($from_item_id, $to_item_id, $replace_existing_actions = null)
    {
        list($response) = $this->restApiDocumentCopyDocumentEventActionsWithHttpInfo($from_item_id, $to_item_id, $replace_existing_actions);
        return $response;
    }

    /**
     * Operation restApiDocumentCopyDocumentEventActionsWithHttpInfo
     *
     * DocumentCopyDocumentEventActions
     *
     * @param  string $from_item_id The original document&#39;s ID (required)
     * @param  string $to_item_id The new document&#39;s ID (required)
     * @param  bool $replace_existing_actions If true, all existing actions are first removed from the target document (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiDocumentCopyDocumentEventActionsWithHttpInfo($from_item_id, $to_item_id, $replace_existing_actions = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentCopyDocumentEventActionsRequest($from_item_id, $to_item_id, $replace_existing_actions);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiDocumentCopyDocumentEventActionsAsync
     *
     * DocumentCopyDocumentEventActions
     *
     * @param  string $from_item_id The original document&#39;s ID (required)
     * @param  string $to_item_id The new document&#39;s ID (required)
     * @param  bool $replace_existing_actions If true, all existing actions are first removed from the target document (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentCopyDocumentEventActionsAsync($from_item_id, $to_item_id, $replace_existing_actions = null)
    {
        return $this->restApiDocumentCopyDocumentEventActionsAsyncWithHttpInfo($from_item_id, $to_item_id, $replace_existing_actions)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiDocumentCopyDocumentEventActionsAsyncWithHttpInfo
     *
     * DocumentCopyDocumentEventActions
     *
     * @param  string $from_item_id The original document&#39;s ID (required)
     * @param  string $to_item_id The new document&#39;s ID (required)
     * @param  bool $replace_existing_actions If true, all existing actions are first removed from the target document (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentCopyDocumentEventActionsAsyncWithHttpInfo($from_item_id, $to_item_id, $replace_existing_actions = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentCopyDocumentEventActionsRequest($from_item_id, $to_item_id, $replace_existing_actions);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiDocumentCopyDocumentEventActions'
     *
     * @param  string $from_item_id The original document&#39;s ID (required)
     * @param  string $to_item_id The new document&#39;s ID (required)
     * @param  bool $replace_existing_actions If true, all existing actions are first removed from the target document (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiDocumentCopyDocumentEventActionsRequest($from_item_id, $to_item_id, $replace_existing_actions = null)
    {
        // verify the required parameter 'from_item_id' is set
        if ($from_item_id === null || (is_array($from_item_id) && count($from_item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from_item_id when calling restApiDocumentCopyDocumentEventActions'
            );
        }
        // verify the required parameter 'to_item_id' is set
        if ($to_item_id === null || (is_array($to_item_id) && count($to_item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to_item_id when calling restApiDocumentCopyDocumentEventActions'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/documents/{toItemID}/documenteventactions/copy';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from_item_id !== null) {
            $queryParams['fromItemID'] = ObjectSerializer::toQueryValue($from_item_id);
        }
        // query params
        if ($replace_existing_actions !== null) {
            $queryParams['replaceExistingActions'] = ObjectSerializer::toQueryValue($replace_existing_actions);
        }

        // path params
        if ($to_item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'toItemID' . '}',
                ObjectSerializer::toPathValue($to_item_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiDocumentCopyVariableDefinitions
     *
     * DocumentCopyVariableDefinitions
     *
     * @param  string $from_item_id The ID of the document from which the variables will be copied (required)
     * @param  string $to_item_id The id of the document to which the variables need to be copied (required)
     * @param  bool $replace_existing_variables If true, all previously existing variables are first removed in the target document (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiDocumentCopyVariableDefinitions($from_item_id, $to_item_id, $replace_existing_variables = null)
    {
        list($response) = $this->restApiDocumentCopyVariableDefinitionsWithHttpInfo($from_item_id, $to_item_id, $replace_existing_variables);
        return $response;
    }

    /**
     * Operation restApiDocumentCopyVariableDefinitionsWithHttpInfo
     *
     * DocumentCopyVariableDefinitions
     *
     * @param  string $from_item_id The ID of the document from which the variables will be copied (required)
     * @param  string $to_item_id The id of the document to which the variables need to be copied (required)
     * @param  bool $replace_existing_variables If true, all previously existing variables are first removed in the target document (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiDocumentCopyVariableDefinitionsWithHttpInfo($from_item_id, $to_item_id, $replace_existing_variables = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentCopyVariableDefinitionsRequest($from_item_id, $to_item_id, $replace_existing_variables);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiDocumentCopyVariableDefinitionsAsync
     *
     * DocumentCopyVariableDefinitions
     *
     * @param  string $from_item_id The ID of the document from which the variables will be copied (required)
     * @param  string $to_item_id The id of the document to which the variables need to be copied (required)
     * @param  bool $replace_existing_variables If true, all previously existing variables are first removed in the target document (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentCopyVariableDefinitionsAsync($from_item_id, $to_item_id, $replace_existing_variables = null)
    {
        return $this->restApiDocumentCopyVariableDefinitionsAsyncWithHttpInfo($from_item_id, $to_item_id, $replace_existing_variables)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiDocumentCopyVariableDefinitionsAsyncWithHttpInfo
     *
     * DocumentCopyVariableDefinitions
     *
     * @param  string $from_item_id The ID of the document from which the variables will be copied (required)
     * @param  string $to_item_id The id of the document to which the variables need to be copied (required)
     * @param  bool $replace_existing_variables If true, all previously existing variables are first removed in the target document (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentCopyVariableDefinitionsAsyncWithHttpInfo($from_item_id, $to_item_id, $replace_existing_variables = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentCopyVariableDefinitionsRequest($from_item_id, $to_item_id, $replace_existing_variables);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiDocumentCopyVariableDefinitions'
     *
     * @param  string $from_item_id The ID of the document from which the variables will be copied (required)
     * @param  string $to_item_id The id of the document to which the variables need to be copied (required)
     * @param  bool $replace_existing_variables If true, all previously existing variables are first removed in the target document (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiDocumentCopyVariableDefinitionsRequest($from_item_id, $to_item_id, $replace_existing_variables = null)
    {
        // verify the required parameter 'from_item_id' is set
        if ($from_item_id === null || (is_array($from_item_id) && count($from_item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from_item_id when calling restApiDocumentCopyVariableDefinitions'
            );
        }
        // verify the required parameter 'to_item_id' is set
        if ($to_item_id === null || (is_array($to_item_id) && count($to_item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to_item_id when calling restApiDocumentCopyVariableDefinitions'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/documents/{toItemID}/variabledefinitions/copy';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from_item_id !== null) {
            $queryParams['fromItemID'] = ObjectSerializer::toQueryValue($from_item_id);
        }
        // query params
        if ($replace_existing_variables !== null) {
            $queryParams['replaceExistingVariables'] = ObjectSerializer::toQueryValue($replace_existing_variables);
        }

        // path params
        if ($to_item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'toItemID' . '}',
                ObjectSerializer::toPathValue($to_item_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiDocumentCreateFromBlankDocTemplate
     *
     * DocumentCreateFromBlankDocTemplate
     *
     * @param  string $document_name The name of the new document (required)
     * @param  string $folder_path The path for the new document (required)
     * @param  string $blank_doc_template_id The ID of the BlankDocumentTemplates resource item (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiDocumentCreateFromBlankDocTemplate($document_name, $folder_path, $blank_doc_template_id)
    {
        list($response) = $this->restApiDocumentCreateFromBlankDocTemplateWithHttpInfo($document_name, $folder_path, $blank_doc_template_id);
        return $response;
    }

    /**
     * Operation restApiDocumentCreateFromBlankDocTemplateWithHttpInfo
     *
     * DocumentCreateFromBlankDocTemplate
     *
     * @param  string $document_name The name of the new document (required)
     * @param  string $folder_path The path for the new document (required)
     * @param  string $blank_doc_template_id The ID of the BlankDocumentTemplates resource item (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiDocumentCreateFromBlankDocTemplateWithHttpInfo($document_name, $folder_path, $blank_doc_template_id)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentCreateFromBlankDocTemplateRequest($document_name, $folder_path, $blank_doc_template_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiDocumentCreateFromBlankDocTemplateAsync
     *
     * DocumentCreateFromBlankDocTemplate
     *
     * @param  string $document_name The name of the new document (required)
     * @param  string $folder_path The path for the new document (required)
     * @param  string $blank_doc_template_id The ID of the BlankDocumentTemplates resource item (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentCreateFromBlankDocTemplateAsync($document_name, $folder_path, $blank_doc_template_id)
    {
        return $this->restApiDocumentCreateFromBlankDocTemplateAsyncWithHttpInfo($document_name, $folder_path, $blank_doc_template_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiDocumentCreateFromBlankDocTemplateAsyncWithHttpInfo
     *
     * DocumentCreateFromBlankDocTemplate
     *
     * @param  string $document_name The name of the new document (required)
     * @param  string $folder_path The path for the new document (required)
     * @param  string $blank_doc_template_id The ID of the BlankDocumentTemplates resource item (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentCreateFromBlankDocTemplateAsyncWithHttpInfo($document_name, $folder_path, $blank_doc_template_id)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentCreateFromBlankDocTemplateRequest($document_name, $folder_path, $blank_doc_template_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiDocumentCreateFromBlankDocTemplate'
     *
     * @param  string $document_name The name of the new document (required)
     * @param  string $folder_path The path for the new document (required)
     * @param  string $blank_doc_template_id The ID of the BlankDocumentTemplates resource item (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiDocumentCreateFromBlankDocTemplateRequest($document_name, $folder_path, $blank_doc_template_id)
    {
        // verify the required parameter 'document_name' is set
        if ($document_name === null || (is_array($document_name) && count($document_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_name when calling restApiDocumentCreateFromBlankDocTemplate'
            );
        }
        // verify the required parameter 'folder_path' is set
        if ($folder_path === null || (is_array($folder_path) && count($folder_path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $folder_path when calling restApiDocumentCreateFromBlankDocTemplate'
            );
        }
        // verify the required parameter 'blank_doc_template_id' is set
        if ($blank_doc_template_id === null || (is_array($blank_doc_template_id) && count($blank_doc_template_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $blank_doc_template_id when calling restApiDocumentCreateFromBlankDocTemplate'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/documents/fromtemplate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($document_name !== null) {
            $queryParams['documentName'] = ObjectSerializer::toQueryValue($document_name);
        }
        // query params
        if ($folder_path !== null) {
            $queryParams['folderPath'] = ObjectSerializer::toQueryValue($folder_path);
        }
        // query params
        if ($blank_doc_template_id !== null) {
            $queryParams['blankDocTemplateID'] = ObjectSerializer::toQueryValue($blank_doc_template_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiDocumentCreateFromChiliPackage
     *
     * DocumentCreateFromChiliPackage
     *
     * @param  string $document_name The name for the new document (required)
     * @param  string $folder_path The path for the new document (required)
     * @param  \Swagger\Client\Model\DocumentCreateFromChiliPackageBodyWrapper $body  (required)
     * @param  string $new_asset_location Optional new location for the assets in the package. When creating the package, the user can choose a location for the assets. If a newAssetLocation is provided, this location will be modified (optional)
     * @param  string $new_font_location Optional new location for the fonts in the package. When creating the package, the user can choose a location for the fonts. If a newFontLocation is provided, this location will be modified (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiDocumentCreateFromChiliPackage($document_name, $folder_path, $body, $new_asset_location = null, $new_font_location = null)
    {
        list($response) = $this->restApiDocumentCreateFromChiliPackageWithHttpInfo($document_name, $folder_path, $body, $new_asset_location, $new_font_location);
        return $response;
    }

    /**
     * Operation restApiDocumentCreateFromChiliPackageWithHttpInfo
     *
     * DocumentCreateFromChiliPackage
     *
     * @param  string $document_name The name for the new document (required)
     * @param  string $folder_path The path for the new document (required)
     * @param  \Swagger\Client\Model\DocumentCreateFromChiliPackageBodyWrapper $body  (required)
     * @param  string $new_asset_location Optional new location for the assets in the package. When creating the package, the user can choose a location for the assets. If a newAssetLocation is provided, this location will be modified (optional)
     * @param  string $new_font_location Optional new location for the fonts in the package. When creating the package, the user can choose a location for the fonts. If a newFontLocation is provided, this location will be modified (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiDocumentCreateFromChiliPackageWithHttpInfo($document_name, $folder_path, $body, $new_asset_location = null, $new_font_location = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentCreateFromChiliPackageRequest($document_name, $folder_path, $body, $new_asset_location, $new_font_location);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiDocumentCreateFromChiliPackageAsync
     *
     * DocumentCreateFromChiliPackage
     *
     * @param  string $document_name The name for the new document (required)
     * @param  string $folder_path The path for the new document (required)
     * @param  \Swagger\Client\Model\DocumentCreateFromChiliPackageBodyWrapper $body  (required)
     * @param  string $new_asset_location Optional new location for the assets in the package. When creating the package, the user can choose a location for the assets. If a newAssetLocation is provided, this location will be modified (optional)
     * @param  string $new_font_location Optional new location for the fonts in the package. When creating the package, the user can choose a location for the fonts. If a newFontLocation is provided, this location will be modified (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentCreateFromChiliPackageAsync($document_name, $folder_path, $body, $new_asset_location = null, $new_font_location = null)
    {
        return $this->restApiDocumentCreateFromChiliPackageAsyncWithHttpInfo($document_name, $folder_path, $body, $new_asset_location, $new_font_location)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiDocumentCreateFromChiliPackageAsyncWithHttpInfo
     *
     * DocumentCreateFromChiliPackage
     *
     * @param  string $document_name The name for the new document (required)
     * @param  string $folder_path The path for the new document (required)
     * @param  \Swagger\Client\Model\DocumentCreateFromChiliPackageBodyWrapper $body  (required)
     * @param  string $new_asset_location Optional new location for the assets in the package. When creating the package, the user can choose a location for the assets. If a newAssetLocation is provided, this location will be modified (optional)
     * @param  string $new_font_location Optional new location for the fonts in the package. When creating the package, the user can choose a location for the fonts. If a newFontLocation is provided, this location will be modified (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentCreateFromChiliPackageAsyncWithHttpInfo($document_name, $folder_path, $body, $new_asset_location = null, $new_font_location = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentCreateFromChiliPackageRequest($document_name, $folder_path, $body, $new_asset_location, $new_font_location);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiDocumentCreateFromChiliPackage'
     *
     * @param  string $document_name The name for the new document (required)
     * @param  string $folder_path The path for the new document (required)
     * @param  \Swagger\Client\Model\DocumentCreateFromChiliPackageBodyWrapper $body  (required)
     * @param  string $new_asset_location Optional new location for the assets in the package. When creating the package, the user can choose a location for the assets. If a newAssetLocation is provided, this location will be modified (optional)
     * @param  string $new_font_location Optional new location for the fonts in the package. When creating the package, the user can choose a location for the fonts. If a newFontLocation is provided, this location will be modified (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiDocumentCreateFromChiliPackageRequest($document_name, $folder_path, $body, $new_asset_location = null, $new_font_location = null)
    {
        // verify the required parameter 'document_name' is set
        if ($document_name === null || (is_array($document_name) && count($document_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_name when calling restApiDocumentCreateFromChiliPackage'
            );
        }
        // verify the required parameter 'folder_path' is set
        if ($folder_path === null || (is_array($folder_path) && count($folder_path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $folder_path when calling restApiDocumentCreateFromChiliPackage'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling restApiDocumentCreateFromChiliPackage'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/documents/frompackage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($document_name !== null) {
            $queryParams['documentName'] = ObjectSerializer::toQueryValue($document_name);
        }
        // query params
        if ($folder_path !== null) {
            $queryParams['folderPath'] = ObjectSerializer::toQueryValue($folder_path);
        }
        // query params
        if ($new_asset_location !== null) {
            $queryParams['newAssetLocation'] = ObjectSerializer::toQueryValue($new_asset_location);
        }
        // query params
        if ($new_font_location !== null) {
            $queryParams['newFontLocation'] = ObjectSerializer::toQueryValue($new_font_location);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiDocumentCreateFromODT
     *
     * DocumentCreateFromODT
     *
     * @param  string $document_name The name for the new document (required)
     * @param  string $folder_path The path for the new document (required)
     * @param  \Swagger\Client\Model\DocumentCreateFromODTBodyWrapper $body  (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiDocumentCreateFromODT($document_name, $folder_path, $body)
    {
        list($response) = $this->restApiDocumentCreateFromODTWithHttpInfo($document_name, $folder_path, $body);
        return $response;
    }

    /**
     * Operation restApiDocumentCreateFromODTWithHttpInfo
     *
     * DocumentCreateFromODT
     *
     * @param  string $document_name The name for the new document (required)
     * @param  string $folder_path The path for the new document (required)
     * @param  \Swagger\Client\Model\DocumentCreateFromODTBodyWrapper $body  (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiDocumentCreateFromODTWithHttpInfo($document_name, $folder_path, $body)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentCreateFromODTRequest($document_name, $folder_path, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiDocumentCreateFromODTAsync
     *
     * DocumentCreateFromODT
     *
     * @param  string $document_name The name for the new document (required)
     * @param  string $folder_path The path for the new document (required)
     * @param  \Swagger\Client\Model\DocumentCreateFromODTBodyWrapper $body  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentCreateFromODTAsync($document_name, $folder_path, $body)
    {
        return $this->restApiDocumentCreateFromODTAsyncWithHttpInfo($document_name, $folder_path, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiDocumentCreateFromODTAsyncWithHttpInfo
     *
     * DocumentCreateFromODT
     *
     * @param  string $document_name The name for the new document (required)
     * @param  string $folder_path The path for the new document (required)
     * @param  \Swagger\Client\Model\DocumentCreateFromODTBodyWrapper $body  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentCreateFromODTAsyncWithHttpInfo($document_name, $folder_path, $body)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentCreateFromODTRequest($document_name, $folder_path, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiDocumentCreateFromODT'
     *
     * @param  string $document_name The name for the new document (required)
     * @param  string $folder_path The path for the new document (required)
     * @param  \Swagger\Client\Model\DocumentCreateFromODTBodyWrapper $body  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiDocumentCreateFromODTRequest($document_name, $folder_path, $body)
    {
        // verify the required parameter 'document_name' is set
        if ($document_name === null || (is_array($document_name) && count($document_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_name when calling restApiDocumentCreateFromODT'
            );
        }
        // verify the required parameter 'folder_path' is set
        if ($folder_path === null || (is_array($folder_path) && count($folder_path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $folder_path when calling restApiDocumentCreateFromODT'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling restApiDocumentCreateFromODT'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/documents/fromodt';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($document_name !== null) {
            $queryParams['documentName'] = ObjectSerializer::toQueryValue($document_name);
        }
        // query params
        if ($folder_path !== null) {
            $queryParams['folderPath'] = ObjectSerializer::toQueryValue($folder_path);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiDocumentCreateFromPDF
     *
     * DocumentCreateFromPDF
     *
     * @param  string $document_name The name for the new document (required)
     * @param  string $folder_path The path for the new document (required)
     * @param  string $background_asset_location Location for the PDF pages used as backgrounds for the document (required)
     * @param  \Swagger\Client\Model\DocumentCreateFromPDFBodyWrapper $body  (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiDocumentCreateFromPDF($document_name, $folder_path, $background_asset_location, $body)
    {
        list($response) = $this->restApiDocumentCreateFromPDFWithHttpInfo($document_name, $folder_path, $background_asset_location, $body);
        return $response;
    }

    /**
     * Operation restApiDocumentCreateFromPDFWithHttpInfo
     *
     * DocumentCreateFromPDF
     *
     * @param  string $document_name The name for the new document (required)
     * @param  string $folder_path The path for the new document (required)
     * @param  string $background_asset_location Location for the PDF pages used as backgrounds for the document (required)
     * @param  \Swagger\Client\Model\DocumentCreateFromPDFBodyWrapper $body  (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiDocumentCreateFromPDFWithHttpInfo($document_name, $folder_path, $background_asset_location, $body)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentCreateFromPDFRequest($document_name, $folder_path, $background_asset_location, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiDocumentCreateFromPDFAsync
     *
     * DocumentCreateFromPDF
     *
     * @param  string $document_name The name for the new document (required)
     * @param  string $folder_path The path for the new document (required)
     * @param  string $background_asset_location Location for the PDF pages used as backgrounds for the document (required)
     * @param  \Swagger\Client\Model\DocumentCreateFromPDFBodyWrapper $body  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentCreateFromPDFAsync($document_name, $folder_path, $background_asset_location, $body)
    {
        return $this->restApiDocumentCreateFromPDFAsyncWithHttpInfo($document_name, $folder_path, $background_asset_location, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiDocumentCreateFromPDFAsyncWithHttpInfo
     *
     * DocumentCreateFromPDF
     *
     * @param  string $document_name The name for the new document (required)
     * @param  string $folder_path The path for the new document (required)
     * @param  string $background_asset_location Location for the PDF pages used as backgrounds for the document (required)
     * @param  \Swagger\Client\Model\DocumentCreateFromPDFBodyWrapper $body  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentCreateFromPDFAsyncWithHttpInfo($document_name, $folder_path, $background_asset_location, $body)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentCreateFromPDFRequest($document_name, $folder_path, $background_asset_location, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiDocumentCreateFromPDF'
     *
     * @param  string $document_name The name for the new document (required)
     * @param  string $folder_path The path for the new document (required)
     * @param  string $background_asset_location Location for the PDF pages used as backgrounds for the document (required)
     * @param  \Swagger\Client\Model\DocumentCreateFromPDFBodyWrapper $body  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiDocumentCreateFromPDFRequest($document_name, $folder_path, $background_asset_location, $body)
    {
        // verify the required parameter 'document_name' is set
        if ($document_name === null || (is_array($document_name) && count($document_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_name when calling restApiDocumentCreateFromPDF'
            );
        }
        // verify the required parameter 'folder_path' is set
        if ($folder_path === null || (is_array($folder_path) && count($folder_path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $folder_path when calling restApiDocumentCreateFromPDF'
            );
        }
        // verify the required parameter 'background_asset_location' is set
        if ($background_asset_location === null || (is_array($background_asset_location) && count($background_asset_location) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $background_asset_location when calling restApiDocumentCreateFromPDF'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling restApiDocumentCreateFromPDF'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/documents/frompdf';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($document_name !== null) {
            $queryParams['documentName'] = ObjectSerializer::toQueryValue($document_name);
        }
        // query params
        if ($folder_path !== null) {
            $queryParams['folderPath'] = ObjectSerializer::toQueryValue($folder_path);
        }
        // query params
        if ($background_asset_location !== null) {
            $queryParams['backgroundAssetLocation'] = ObjectSerializer::toQueryValue($background_asset_location);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiDocumentCreateHTML
     *
     * DocumentCreateHTML
     *
     * @param  string $item_id  (required)
     * @param  \Swagger\Client\Model\DocumentCreateHTMLBodyWrapper $body  (required)
     * @param  int $task_priority  (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiDocumentCreateHTML($item_id, $body, $task_priority = null)
    {
        list($response) = $this->restApiDocumentCreateHTMLWithHttpInfo($item_id, $body, $task_priority);
        return $response;
    }

    /**
     * Operation restApiDocumentCreateHTMLWithHttpInfo
     *
     * DocumentCreateHTML
     *
     * @param  string $item_id  (required)
     * @param  \Swagger\Client\Model\DocumentCreateHTMLBodyWrapper $body  (required)
     * @param  int $task_priority  (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiDocumentCreateHTMLWithHttpInfo($item_id, $body, $task_priority = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentCreateHTMLRequest($item_id, $body, $task_priority);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiDocumentCreateHTMLAsync
     *
     * DocumentCreateHTML
     *
     * @param  string $item_id  (required)
     * @param  \Swagger\Client\Model\DocumentCreateHTMLBodyWrapper $body  (required)
     * @param  int $task_priority  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentCreateHTMLAsync($item_id, $body, $task_priority = null)
    {
        return $this->restApiDocumentCreateHTMLAsyncWithHttpInfo($item_id, $body, $task_priority)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiDocumentCreateHTMLAsyncWithHttpInfo
     *
     * DocumentCreateHTML
     *
     * @param  string $item_id  (required)
     * @param  \Swagger\Client\Model\DocumentCreateHTMLBodyWrapper $body  (required)
     * @param  int $task_priority  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentCreateHTMLAsyncWithHttpInfo($item_id, $body, $task_priority = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentCreateHTMLRequest($item_id, $body, $task_priority);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiDocumentCreateHTML'
     *
     * @param  string $item_id  (required)
     * @param  \Swagger\Client\Model\DocumentCreateHTMLBodyWrapper $body  (required)
     * @param  int $task_priority  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiDocumentCreateHTMLRequest($item_id, $body, $task_priority = null)
    {
        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling restApiDocumentCreateHTML'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling restApiDocumentCreateHTML'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/documents/{itemID}/representations/html';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($task_priority !== null) {
            $queryParams['taskPriority'] = ObjectSerializer::toQueryValue($task_priority);
        }

        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemID' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiDocumentCreateIDML
     *
     * DocumentCreateIDML
     *
     * @param  string $item_id  (required)
     * @param  \Swagger\Client\Model\DocumentCreateIDMLBodyWrapper $body  (required)
     * @param  int $task_priority  (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiDocumentCreateIDML($item_id, $body, $task_priority = null)
    {
        list($response) = $this->restApiDocumentCreateIDMLWithHttpInfo($item_id, $body, $task_priority);
        return $response;
    }

    /**
     * Operation restApiDocumentCreateIDMLWithHttpInfo
     *
     * DocumentCreateIDML
     *
     * @param  string $item_id  (required)
     * @param  \Swagger\Client\Model\DocumentCreateIDMLBodyWrapper $body  (required)
     * @param  int $task_priority  (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiDocumentCreateIDMLWithHttpInfo($item_id, $body, $task_priority = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentCreateIDMLRequest($item_id, $body, $task_priority);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiDocumentCreateIDMLAsync
     *
     * DocumentCreateIDML
     *
     * @param  string $item_id  (required)
     * @param  \Swagger\Client\Model\DocumentCreateIDMLBodyWrapper $body  (required)
     * @param  int $task_priority  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentCreateIDMLAsync($item_id, $body, $task_priority = null)
    {
        return $this->restApiDocumentCreateIDMLAsyncWithHttpInfo($item_id, $body, $task_priority)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiDocumentCreateIDMLAsyncWithHttpInfo
     *
     * DocumentCreateIDML
     *
     * @param  string $item_id  (required)
     * @param  \Swagger\Client\Model\DocumentCreateIDMLBodyWrapper $body  (required)
     * @param  int $task_priority  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentCreateIDMLAsyncWithHttpInfo($item_id, $body, $task_priority = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentCreateIDMLRequest($item_id, $body, $task_priority);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiDocumentCreateIDML'
     *
     * @param  string $item_id  (required)
     * @param  \Swagger\Client\Model\DocumentCreateIDMLBodyWrapper $body  (required)
     * @param  int $task_priority  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiDocumentCreateIDMLRequest($item_id, $body, $task_priority = null)
    {
        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling restApiDocumentCreateIDML'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling restApiDocumentCreateIDML'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/documents/{itemID}/representations/idml';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($task_priority !== null) {
            $queryParams['taskPriority'] = ObjectSerializer::toQueryValue($task_priority);
        }

        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemID' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiDocumentCreateImages
     *
     * DocumentCreateImages
     *
     * @param  string $item_id The ID of the document for which to create the PDF (required)
     * @param  string $image_conversion_profile_id The ID of the image conversion profile (required)
     * @param  \Swagger\Client\Model\DocumentCreateImagesBodyWrapper $body  (required)
     * @param  int $task_priority The priority (1-10) of the task (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiDocumentCreateImages($item_id, $image_conversion_profile_id, $body, $task_priority = null)
    {
        list($response) = $this->restApiDocumentCreateImagesWithHttpInfo($item_id, $image_conversion_profile_id, $body, $task_priority);
        return $response;
    }

    /**
     * Operation restApiDocumentCreateImagesWithHttpInfo
     *
     * DocumentCreateImages
     *
     * @param  string $item_id The ID of the document for which to create the PDF (required)
     * @param  string $image_conversion_profile_id The ID of the image conversion profile (required)
     * @param  \Swagger\Client\Model\DocumentCreateImagesBodyWrapper $body  (required)
     * @param  int $task_priority The priority (1-10) of the task (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiDocumentCreateImagesWithHttpInfo($item_id, $image_conversion_profile_id, $body, $task_priority = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentCreateImagesRequest($item_id, $image_conversion_profile_id, $body, $task_priority);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiDocumentCreateImagesAsync
     *
     * DocumentCreateImages
     *
     * @param  string $item_id The ID of the document for which to create the PDF (required)
     * @param  string $image_conversion_profile_id The ID of the image conversion profile (required)
     * @param  \Swagger\Client\Model\DocumentCreateImagesBodyWrapper $body  (required)
     * @param  int $task_priority The priority (1-10) of the task (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentCreateImagesAsync($item_id, $image_conversion_profile_id, $body, $task_priority = null)
    {
        return $this->restApiDocumentCreateImagesAsyncWithHttpInfo($item_id, $image_conversion_profile_id, $body, $task_priority)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiDocumentCreateImagesAsyncWithHttpInfo
     *
     * DocumentCreateImages
     *
     * @param  string $item_id The ID of the document for which to create the PDF (required)
     * @param  string $image_conversion_profile_id The ID of the image conversion profile (required)
     * @param  \Swagger\Client\Model\DocumentCreateImagesBodyWrapper $body  (required)
     * @param  int $task_priority The priority (1-10) of the task (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentCreateImagesAsyncWithHttpInfo($item_id, $image_conversion_profile_id, $body, $task_priority = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentCreateImagesRequest($item_id, $image_conversion_profile_id, $body, $task_priority);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiDocumentCreateImages'
     *
     * @param  string $item_id The ID of the document for which to create the PDF (required)
     * @param  string $image_conversion_profile_id The ID of the image conversion profile (required)
     * @param  \Swagger\Client\Model\DocumentCreateImagesBodyWrapper $body  (required)
     * @param  int $task_priority The priority (1-10) of the task (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiDocumentCreateImagesRequest($item_id, $image_conversion_profile_id, $body, $task_priority = null)
    {
        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling restApiDocumentCreateImages'
            );
        }
        // verify the required parameter 'image_conversion_profile_id' is set
        if ($image_conversion_profile_id === null || (is_array($image_conversion_profile_id) && count($image_conversion_profile_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_conversion_profile_id when calling restApiDocumentCreateImages'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling restApiDocumentCreateImages'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/documents/{itemID}/representations/images';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($image_conversion_profile_id !== null) {
            $queryParams['imageConversionProfileID'] = ObjectSerializer::toQueryValue($image_conversion_profile_id);
        }
        // query params
        if ($task_priority !== null) {
            $queryParams['taskPriority'] = ObjectSerializer::toQueryValue($task_priority);
        }

        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemID' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiDocumentCreateImagesAndPDF
     *
     * DocumentCreateImagesAndPDF
     *
     * @param  string $item_id The ID of the document for which to create the PDF (required)
     * @param  string $image_conversion_profile_id The ID of the image conversion profile (required)
     * @param  \Swagger\Client\Model\DocumentCreateImagesAndPDFBodyWrapper $body  (required)
     * @param  int $task_priority The priority (1-10) of the task (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiDocumentCreateImagesAndPDF($item_id, $image_conversion_profile_id, $body, $task_priority = null)
    {
        list($response) = $this->restApiDocumentCreateImagesAndPDFWithHttpInfo($item_id, $image_conversion_profile_id, $body, $task_priority);
        return $response;
    }

    /**
     * Operation restApiDocumentCreateImagesAndPDFWithHttpInfo
     *
     * DocumentCreateImagesAndPDF
     *
     * @param  string $item_id The ID of the document for which to create the PDF (required)
     * @param  string $image_conversion_profile_id The ID of the image conversion profile (required)
     * @param  \Swagger\Client\Model\DocumentCreateImagesAndPDFBodyWrapper $body  (required)
     * @param  int $task_priority The priority (1-10) of the task (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiDocumentCreateImagesAndPDFWithHttpInfo($item_id, $image_conversion_profile_id, $body, $task_priority = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentCreateImagesAndPDFRequest($item_id, $image_conversion_profile_id, $body, $task_priority);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiDocumentCreateImagesAndPDFAsync
     *
     * DocumentCreateImagesAndPDF
     *
     * @param  string $item_id The ID of the document for which to create the PDF (required)
     * @param  string $image_conversion_profile_id The ID of the image conversion profile (required)
     * @param  \Swagger\Client\Model\DocumentCreateImagesAndPDFBodyWrapper $body  (required)
     * @param  int $task_priority The priority (1-10) of the task (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentCreateImagesAndPDFAsync($item_id, $image_conversion_profile_id, $body, $task_priority = null)
    {
        return $this->restApiDocumentCreateImagesAndPDFAsyncWithHttpInfo($item_id, $image_conversion_profile_id, $body, $task_priority)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiDocumentCreateImagesAndPDFAsyncWithHttpInfo
     *
     * DocumentCreateImagesAndPDF
     *
     * @param  string $item_id The ID of the document for which to create the PDF (required)
     * @param  string $image_conversion_profile_id The ID of the image conversion profile (required)
     * @param  \Swagger\Client\Model\DocumentCreateImagesAndPDFBodyWrapper $body  (required)
     * @param  int $task_priority The priority (1-10) of the task (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentCreateImagesAndPDFAsyncWithHttpInfo($item_id, $image_conversion_profile_id, $body, $task_priority = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentCreateImagesAndPDFRequest($item_id, $image_conversion_profile_id, $body, $task_priority);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiDocumentCreateImagesAndPDF'
     *
     * @param  string $item_id The ID of the document for which to create the PDF (required)
     * @param  string $image_conversion_profile_id The ID of the image conversion profile (required)
     * @param  \Swagger\Client\Model\DocumentCreateImagesAndPDFBodyWrapper $body  (required)
     * @param  int $task_priority The priority (1-10) of the task (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiDocumentCreateImagesAndPDFRequest($item_id, $image_conversion_profile_id, $body, $task_priority = null)
    {
        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling restApiDocumentCreateImagesAndPDF'
            );
        }
        // verify the required parameter 'image_conversion_profile_id' is set
        if ($image_conversion_profile_id === null || (is_array($image_conversion_profile_id) && count($image_conversion_profile_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_conversion_profile_id when calling restApiDocumentCreateImagesAndPDF'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling restApiDocumentCreateImagesAndPDF'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/documents/{itemID}/representations/imagesandpdf';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($image_conversion_profile_id !== null) {
            $queryParams['imageConversionProfileID'] = ObjectSerializer::toQueryValue($image_conversion_profile_id);
        }
        // query params
        if ($task_priority !== null) {
            $queryParams['taskPriority'] = ObjectSerializer::toQueryValue($task_priority);
        }

        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemID' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiDocumentCreateODF
     *
     * DocumentCreateODF
     *
     * @param  string $item_id  (required)
     * @param  \Swagger\Client\Model\DocumentCreateODFBodyWrapper $body  (required)
     * @param  int $task_priority  (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiDocumentCreateODF($item_id, $body, $task_priority = null)
    {
        list($response) = $this->restApiDocumentCreateODFWithHttpInfo($item_id, $body, $task_priority);
        return $response;
    }

    /**
     * Operation restApiDocumentCreateODFWithHttpInfo
     *
     * DocumentCreateODF
     *
     * @param  string $item_id  (required)
     * @param  \Swagger\Client\Model\DocumentCreateODFBodyWrapper $body  (required)
     * @param  int $task_priority  (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiDocumentCreateODFWithHttpInfo($item_id, $body, $task_priority = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentCreateODFRequest($item_id, $body, $task_priority);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiDocumentCreateODFAsync
     *
     * DocumentCreateODF
     *
     * @param  string $item_id  (required)
     * @param  \Swagger\Client\Model\DocumentCreateODFBodyWrapper $body  (required)
     * @param  int $task_priority  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentCreateODFAsync($item_id, $body, $task_priority = null)
    {
        return $this->restApiDocumentCreateODFAsyncWithHttpInfo($item_id, $body, $task_priority)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiDocumentCreateODFAsyncWithHttpInfo
     *
     * DocumentCreateODF
     *
     * @param  string $item_id  (required)
     * @param  \Swagger\Client\Model\DocumentCreateODFBodyWrapper $body  (required)
     * @param  int $task_priority  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentCreateODFAsyncWithHttpInfo($item_id, $body, $task_priority = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentCreateODFRequest($item_id, $body, $task_priority);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiDocumentCreateODF'
     *
     * @param  string $item_id  (required)
     * @param  \Swagger\Client\Model\DocumentCreateODFBodyWrapper $body  (required)
     * @param  int $task_priority  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiDocumentCreateODFRequest($item_id, $body, $task_priority = null)
    {
        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling restApiDocumentCreateODF'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling restApiDocumentCreateODF'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/documents/{itemID}/representations/odf';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($task_priority !== null) {
            $queryParams['taskPriority'] = ObjectSerializer::toQueryValue($task_priority);
        }

        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemID' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiDocumentCreatePDF
     *
     * DocumentCreatePDF
     *
     * @param  string $item_id The ID of the document for which to create the PDF (required)
     * @param  \Swagger\Client\Model\DocumentCreatePDFBodyWrapper $body  (required)
     * @param  int $task_priority The priority (1-10) of the task (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiDocumentCreatePDF($item_id, $body, $task_priority = null)
    {
        list($response) = $this->restApiDocumentCreatePDFWithHttpInfo($item_id, $body, $task_priority);
        return $response;
    }

    /**
     * Operation restApiDocumentCreatePDFWithHttpInfo
     *
     * DocumentCreatePDF
     *
     * @param  string $item_id The ID of the document for which to create the PDF (required)
     * @param  \Swagger\Client\Model\DocumentCreatePDFBodyWrapper $body  (required)
     * @param  int $task_priority The priority (1-10) of the task (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiDocumentCreatePDFWithHttpInfo($item_id, $body, $task_priority = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentCreatePDFRequest($item_id, $body, $task_priority);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiDocumentCreatePDFAsync
     *
     * DocumentCreatePDF
     *
     * @param  string $item_id The ID of the document for which to create the PDF (required)
     * @param  \Swagger\Client\Model\DocumentCreatePDFBodyWrapper $body  (required)
     * @param  int $task_priority The priority (1-10) of the task (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentCreatePDFAsync($item_id, $body, $task_priority = null)
    {
        return $this->restApiDocumentCreatePDFAsyncWithHttpInfo($item_id, $body, $task_priority)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiDocumentCreatePDFAsyncWithHttpInfo
     *
     * DocumentCreatePDF
     *
     * @param  string $item_id The ID of the document for which to create the PDF (required)
     * @param  \Swagger\Client\Model\DocumentCreatePDFBodyWrapper $body  (required)
     * @param  int $task_priority The priority (1-10) of the task (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentCreatePDFAsyncWithHttpInfo($item_id, $body, $task_priority = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentCreatePDFRequest($item_id, $body, $task_priority);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiDocumentCreatePDF'
     *
     * @param  string $item_id The ID of the document for which to create the PDF (required)
     * @param  \Swagger\Client\Model\DocumentCreatePDFBodyWrapper $body  (required)
     * @param  int $task_priority The priority (1-10) of the task (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiDocumentCreatePDFRequest($item_id, $body, $task_priority = null)
    {
        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling restApiDocumentCreatePDF'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling restApiDocumentCreatePDF'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/documents/{itemID}/representations/pdf';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($task_priority !== null) {
            $queryParams['taskPriority'] = ObjectSerializer::toQueryValue($task_priority);
        }

        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemID' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiDocumentCreatePackage
     *
     * DocumentCreatePackage
     *
     * @param  string $item_id The ID of the document for which to create the Package (required)
     * @param  int $task_priority The priority (1-10) of the task (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiDocumentCreatePackage($item_id, $task_priority = null)
    {
        list($response) = $this->restApiDocumentCreatePackageWithHttpInfo($item_id, $task_priority);
        return $response;
    }

    /**
     * Operation restApiDocumentCreatePackageWithHttpInfo
     *
     * DocumentCreatePackage
     *
     * @param  string $item_id The ID of the document for which to create the Package (required)
     * @param  int $task_priority The priority (1-10) of the task (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiDocumentCreatePackageWithHttpInfo($item_id, $task_priority = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentCreatePackageRequest($item_id, $task_priority);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiDocumentCreatePackageAsync
     *
     * DocumentCreatePackage
     *
     * @param  string $item_id The ID of the document for which to create the Package (required)
     * @param  int $task_priority The priority (1-10) of the task (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentCreatePackageAsync($item_id, $task_priority = null)
    {
        return $this->restApiDocumentCreatePackageAsyncWithHttpInfo($item_id, $task_priority)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiDocumentCreatePackageAsyncWithHttpInfo
     *
     * DocumentCreatePackage
     *
     * @param  string $item_id The ID of the document for which to create the Package (required)
     * @param  int $task_priority The priority (1-10) of the task (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentCreatePackageAsyncWithHttpInfo($item_id, $task_priority = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentCreatePackageRequest($item_id, $task_priority);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiDocumentCreatePackage'
     *
     * @param  string $item_id The ID of the document for which to create the Package (required)
     * @param  int $task_priority The priority (1-10) of the task (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiDocumentCreatePackageRequest($item_id, $task_priority = null)
    {
        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling restApiDocumentCreatePackage'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/documents/{itemID}/representations/package';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($task_priority !== null) {
            $queryParams['taskPriority'] = ObjectSerializer::toQueryValue($task_priority);
        }

        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemID' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiDocumentCreateTempFolding
     *
     * DocumentCreateTempFolding
     *
     * @param  string $item_id  (required)
     * @param  \Swagger\Client\Model\DocumentCreateTempFoldingBodyWrapper $body  (required)
     * @param  int $task_priority  (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiDocumentCreateTempFolding($item_id, $body, $task_priority = null)
    {
        list($response) = $this->restApiDocumentCreateTempFoldingWithHttpInfo($item_id, $body, $task_priority);
        return $response;
    }

    /**
     * Operation restApiDocumentCreateTempFoldingWithHttpInfo
     *
     * DocumentCreateTempFolding
     *
     * @param  string $item_id  (required)
     * @param  \Swagger\Client\Model\DocumentCreateTempFoldingBodyWrapper $body  (required)
     * @param  int $task_priority  (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiDocumentCreateTempFoldingWithHttpInfo($item_id, $body, $task_priority = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentCreateTempFoldingRequest($item_id, $body, $task_priority);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiDocumentCreateTempFoldingAsync
     *
     * DocumentCreateTempFolding
     *
     * @param  string $item_id  (required)
     * @param  \Swagger\Client\Model\DocumentCreateTempFoldingBodyWrapper $body  (required)
     * @param  int $task_priority  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentCreateTempFoldingAsync($item_id, $body, $task_priority = null)
    {
        return $this->restApiDocumentCreateTempFoldingAsyncWithHttpInfo($item_id, $body, $task_priority)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiDocumentCreateTempFoldingAsyncWithHttpInfo
     *
     * DocumentCreateTempFolding
     *
     * @param  string $item_id  (required)
     * @param  \Swagger\Client\Model\DocumentCreateTempFoldingBodyWrapper $body  (required)
     * @param  int $task_priority  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentCreateTempFoldingAsyncWithHttpInfo($item_id, $body, $task_priority = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentCreateTempFoldingRequest($item_id, $body, $task_priority);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiDocumentCreateTempFolding'
     *
     * @param  string $item_id  (required)
     * @param  \Swagger\Client\Model\DocumentCreateTempFoldingBodyWrapper $body  (required)
     * @param  int $task_priority  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiDocumentCreateTempFoldingRequest($item_id, $body, $task_priority = null)
    {
        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling restApiDocumentCreateTempFolding'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling restApiDocumentCreateTempFolding'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/documents/tempxml/folding';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($item_id !== null) {
            $queryParams['itemID'] = ObjectSerializer::toQueryValue($item_id);
        }
        // query params
        if ($task_priority !== null) {
            $queryParams['taskPriority'] = ObjectSerializer::toQueryValue($task_priority);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiDocumentCreateTempHTML
     *
     * DocumentCreateTempHTML
     *
     * @param  \Swagger\Client\Model\DocumentCreateTempHTMLBodyWrapper $body  (required)
     * @param  string $item_id  (optional)
     * @param  int $task_priority  (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiDocumentCreateTempHTML($body, $item_id = null, $task_priority = null)
    {
        list($response) = $this->restApiDocumentCreateTempHTMLWithHttpInfo($body, $item_id, $task_priority);
        return $response;
    }

    /**
     * Operation restApiDocumentCreateTempHTMLWithHttpInfo
     *
     * DocumentCreateTempHTML
     *
     * @param  \Swagger\Client\Model\DocumentCreateTempHTMLBodyWrapper $body  (required)
     * @param  string $item_id  (optional)
     * @param  int $task_priority  (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiDocumentCreateTempHTMLWithHttpInfo($body, $item_id = null, $task_priority = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentCreateTempHTMLRequest($body, $item_id, $task_priority);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiDocumentCreateTempHTMLAsync
     *
     * DocumentCreateTempHTML
     *
     * @param  \Swagger\Client\Model\DocumentCreateTempHTMLBodyWrapper $body  (required)
     * @param  string $item_id  (optional)
     * @param  int $task_priority  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentCreateTempHTMLAsync($body, $item_id = null, $task_priority = null)
    {
        return $this->restApiDocumentCreateTempHTMLAsyncWithHttpInfo($body, $item_id, $task_priority)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiDocumentCreateTempHTMLAsyncWithHttpInfo
     *
     * DocumentCreateTempHTML
     *
     * @param  \Swagger\Client\Model\DocumentCreateTempHTMLBodyWrapper $body  (required)
     * @param  string $item_id  (optional)
     * @param  int $task_priority  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentCreateTempHTMLAsyncWithHttpInfo($body, $item_id = null, $task_priority = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentCreateTempHTMLRequest($body, $item_id, $task_priority);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiDocumentCreateTempHTML'
     *
     * @param  \Swagger\Client\Model\DocumentCreateTempHTMLBodyWrapper $body  (required)
     * @param  string $item_id  (optional)
     * @param  int $task_priority  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiDocumentCreateTempHTMLRequest($body, $item_id = null, $task_priority = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling restApiDocumentCreateTempHTML'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/documents/tempxml/html';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($item_id !== null) {
            $queryParams['itemID'] = ObjectSerializer::toQueryValue($item_id);
        }
        // query params
        if ($task_priority !== null) {
            $queryParams['taskPriority'] = ObjectSerializer::toQueryValue($task_priority);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiDocumentCreateTempIDML
     *
     * DocumentCreateTempIDML
     *
     * @param  \Swagger\Client\Model\DocumentCreateTempIDMLBodyWrapper $body  (required)
     * @param  string $item_id  (optional)
     * @param  int $task_priority  (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiDocumentCreateTempIDML($body, $item_id = null, $task_priority = null)
    {
        list($response) = $this->restApiDocumentCreateTempIDMLWithHttpInfo($body, $item_id, $task_priority);
        return $response;
    }

    /**
     * Operation restApiDocumentCreateTempIDMLWithHttpInfo
     *
     * DocumentCreateTempIDML
     *
     * @param  \Swagger\Client\Model\DocumentCreateTempIDMLBodyWrapper $body  (required)
     * @param  string $item_id  (optional)
     * @param  int $task_priority  (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiDocumentCreateTempIDMLWithHttpInfo($body, $item_id = null, $task_priority = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentCreateTempIDMLRequest($body, $item_id, $task_priority);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiDocumentCreateTempIDMLAsync
     *
     * DocumentCreateTempIDML
     *
     * @param  \Swagger\Client\Model\DocumentCreateTempIDMLBodyWrapper $body  (required)
     * @param  string $item_id  (optional)
     * @param  int $task_priority  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentCreateTempIDMLAsync($body, $item_id = null, $task_priority = null)
    {
        return $this->restApiDocumentCreateTempIDMLAsyncWithHttpInfo($body, $item_id, $task_priority)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiDocumentCreateTempIDMLAsyncWithHttpInfo
     *
     * DocumentCreateTempIDML
     *
     * @param  \Swagger\Client\Model\DocumentCreateTempIDMLBodyWrapper $body  (required)
     * @param  string $item_id  (optional)
     * @param  int $task_priority  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentCreateTempIDMLAsyncWithHttpInfo($body, $item_id = null, $task_priority = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentCreateTempIDMLRequest($body, $item_id, $task_priority);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiDocumentCreateTempIDML'
     *
     * @param  \Swagger\Client\Model\DocumentCreateTempIDMLBodyWrapper $body  (required)
     * @param  string $item_id  (optional)
     * @param  int $task_priority  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiDocumentCreateTempIDMLRequest($body, $item_id = null, $task_priority = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling restApiDocumentCreateTempIDML'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/documents/tempxml/idml';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($item_id !== null) {
            $queryParams['itemID'] = ObjectSerializer::toQueryValue($item_id);
        }
        // query params
        if ($task_priority !== null) {
            $queryParams['taskPriority'] = ObjectSerializer::toQueryValue($task_priority);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiDocumentCreateTempImages
     *
     * DocumentCreateTempImages
     *
     * @param  string $image_conversion_profile_id The ID of the image conversion profile (required)
     * @param  \Swagger\Client\Model\DocumentCreateTempImagesBodyWrapper $body  (required)
     * @param  string $item_id The ID of the document for which to create the PDF (optional)
     * @param  int $task_priority The priority (1-10) of the task (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiDocumentCreateTempImages($image_conversion_profile_id, $body, $item_id = null, $task_priority = null)
    {
        list($response) = $this->restApiDocumentCreateTempImagesWithHttpInfo($image_conversion_profile_id, $body, $item_id, $task_priority);
        return $response;
    }

    /**
     * Operation restApiDocumentCreateTempImagesWithHttpInfo
     *
     * DocumentCreateTempImages
     *
     * @param  string $image_conversion_profile_id The ID of the image conversion profile (required)
     * @param  \Swagger\Client\Model\DocumentCreateTempImagesBodyWrapper $body  (required)
     * @param  string $item_id The ID of the document for which to create the PDF (optional)
     * @param  int $task_priority The priority (1-10) of the task (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiDocumentCreateTempImagesWithHttpInfo($image_conversion_profile_id, $body, $item_id = null, $task_priority = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentCreateTempImagesRequest($image_conversion_profile_id, $body, $item_id, $task_priority);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiDocumentCreateTempImagesAsync
     *
     * DocumentCreateTempImages
     *
     * @param  string $image_conversion_profile_id The ID of the image conversion profile (required)
     * @param  \Swagger\Client\Model\DocumentCreateTempImagesBodyWrapper $body  (required)
     * @param  string $item_id The ID of the document for which to create the PDF (optional)
     * @param  int $task_priority The priority (1-10) of the task (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentCreateTempImagesAsync($image_conversion_profile_id, $body, $item_id = null, $task_priority = null)
    {
        return $this->restApiDocumentCreateTempImagesAsyncWithHttpInfo($image_conversion_profile_id, $body, $item_id, $task_priority)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiDocumentCreateTempImagesAsyncWithHttpInfo
     *
     * DocumentCreateTempImages
     *
     * @param  string $image_conversion_profile_id The ID of the image conversion profile (required)
     * @param  \Swagger\Client\Model\DocumentCreateTempImagesBodyWrapper $body  (required)
     * @param  string $item_id The ID of the document for which to create the PDF (optional)
     * @param  int $task_priority The priority (1-10) of the task (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentCreateTempImagesAsyncWithHttpInfo($image_conversion_profile_id, $body, $item_id = null, $task_priority = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentCreateTempImagesRequest($image_conversion_profile_id, $body, $item_id, $task_priority);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiDocumentCreateTempImages'
     *
     * @param  string $image_conversion_profile_id The ID of the image conversion profile (required)
     * @param  \Swagger\Client\Model\DocumentCreateTempImagesBodyWrapper $body  (required)
     * @param  string $item_id The ID of the document for which to create the PDF (optional)
     * @param  int $task_priority The priority (1-10) of the task (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiDocumentCreateTempImagesRequest($image_conversion_profile_id, $body, $item_id = null, $task_priority = null)
    {
        // verify the required parameter 'image_conversion_profile_id' is set
        if ($image_conversion_profile_id === null || (is_array($image_conversion_profile_id) && count($image_conversion_profile_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_conversion_profile_id when calling restApiDocumentCreateTempImages'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling restApiDocumentCreateTempImages'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/documents/tempxml/images';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($image_conversion_profile_id !== null) {
            $queryParams['imageConversionProfileID'] = ObjectSerializer::toQueryValue($image_conversion_profile_id);
        }
        // query params
        if ($item_id !== null) {
            $queryParams['itemID'] = ObjectSerializer::toQueryValue($item_id);
        }
        // query params
        if ($task_priority !== null) {
            $queryParams['taskPriority'] = ObjectSerializer::toQueryValue($task_priority);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiDocumentCreateTempImagesAndPDF
     *
     * DocumentCreateTempImagesAndPDF
     *
     * @param  string $image_conversion_profile_id The ID of the image conversion profile (required)
     * @param  \Swagger\Client\Model\DocumentCreateTempImagesAndPDFBodyWrapper $body  (required)
     * @param  string $item_id The ID of the document for which to create the PDF (optional)
     * @param  int $task_priority The priority (1-10) of the task (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiDocumentCreateTempImagesAndPDF($image_conversion_profile_id, $body, $item_id = null, $task_priority = null)
    {
        list($response) = $this->restApiDocumentCreateTempImagesAndPDFWithHttpInfo($image_conversion_profile_id, $body, $item_id, $task_priority);
        return $response;
    }

    /**
     * Operation restApiDocumentCreateTempImagesAndPDFWithHttpInfo
     *
     * DocumentCreateTempImagesAndPDF
     *
     * @param  string $image_conversion_profile_id The ID of the image conversion profile (required)
     * @param  \Swagger\Client\Model\DocumentCreateTempImagesAndPDFBodyWrapper $body  (required)
     * @param  string $item_id The ID of the document for which to create the PDF (optional)
     * @param  int $task_priority The priority (1-10) of the task (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiDocumentCreateTempImagesAndPDFWithHttpInfo($image_conversion_profile_id, $body, $item_id = null, $task_priority = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentCreateTempImagesAndPDFRequest($image_conversion_profile_id, $body, $item_id, $task_priority);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiDocumentCreateTempImagesAndPDFAsync
     *
     * DocumentCreateTempImagesAndPDF
     *
     * @param  string $image_conversion_profile_id The ID of the image conversion profile (required)
     * @param  \Swagger\Client\Model\DocumentCreateTempImagesAndPDFBodyWrapper $body  (required)
     * @param  string $item_id The ID of the document for which to create the PDF (optional)
     * @param  int $task_priority The priority (1-10) of the task (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentCreateTempImagesAndPDFAsync($image_conversion_profile_id, $body, $item_id = null, $task_priority = null)
    {
        return $this->restApiDocumentCreateTempImagesAndPDFAsyncWithHttpInfo($image_conversion_profile_id, $body, $item_id, $task_priority)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiDocumentCreateTempImagesAndPDFAsyncWithHttpInfo
     *
     * DocumentCreateTempImagesAndPDF
     *
     * @param  string $image_conversion_profile_id The ID of the image conversion profile (required)
     * @param  \Swagger\Client\Model\DocumentCreateTempImagesAndPDFBodyWrapper $body  (required)
     * @param  string $item_id The ID of the document for which to create the PDF (optional)
     * @param  int $task_priority The priority (1-10) of the task (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentCreateTempImagesAndPDFAsyncWithHttpInfo($image_conversion_profile_id, $body, $item_id = null, $task_priority = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentCreateTempImagesAndPDFRequest($image_conversion_profile_id, $body, $item_id, $task_priority);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiDocumentCreateTempImagesAndPDF'
     *
     * @param  string $image_conversion_profile_id The ID of the image conversion profile (required)
     * @param  \Swagger\Client\Model\DocumentCreateTempImagesAndPDFBodyWrapper $body  (required)
     * @param  string $item_id The ID of the document for which to create the PDF (optional)
     * @param  int $task_priority The priority (1-10) of the task (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiDocumentCreateTempImagesAndPDFRequest($image_conversion_profile_id, $body, $item_id = null, $task_priority = null)
    {
        // verify the required parameter 'image_conversion_profile_id' is set
        if ($image_conversion_profile_id === null || (is_array($image_conversion_profile_id) && count($image_conversion_profile_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_conversion_profile_id when calling restApiDocumentCreateTempImagesAndPDF'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling restApiDocumentCreateTempImagesAndPDF'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/documents/tempxml/imagesandpdf';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($image_conversion_profile_id !== null) {
            $queryParams['imageConversionProfileID'] = ObjectSerializer::toQueryValue($image_conversion_profile_id);
        }
        // query params
        if ($item_id !== null) {
            $queryParams['itemID'] = ObjectSerializer::toQueryValue($item_id);
        }
        // query params
        if ($task_priority !== null) {
            $queryParams['taskPriority'] = ObjectSerializer::toQueryValue($task_priority);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiDocumentCreateTempODF
     *
     * DocumentCreateTempODF
     *
     * @param  \Swagger\Client\Model\DocumentCreateTempODFBodyWrapper $body  (required)
     * @param  string $item_id  (optional)
     * @param  int $task_priority  (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiDocumentCreateTempODF($body, $item_id = null, $task_priority = null)
    {
        list($response) = $this->restApiDocumentCreateTempODFWithHttpInfo($body, $item_id, $task_priority);
        return $response;
    }

    /**
     * Operation restApiDocumentCreateTempODFWithHttpInfo
     *
     * DocumentCreateTempODF
     *
     * @param  \Swagger\Client\Model\DocumentCreateTempODFBodyWrapper $body  (required)
     * @param  string $item_id  (optional)
     * @param  int $task_priority  (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiDocumentCreateTempODFWithHttpInfo($body, $item_id = null, $task_priority = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentCreateTempODFRequest($body, $item_id, $task_priority);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiDocumentCreateTempODFAsync
     *
     * DocumentCreateTempODF
     *
     * @param  \Swagger\Client\Model\DocumentCreateTempODFBodyWrapper $body  (required)
     * @param  string $item_id  (optional)
     * @param  int $task_priority  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentCreateTempODFAsync($body, $item_id = null, $task_priority = null)
    {
        return $this->restApiDocumentCreateTempODFAsyncWithHttpInfo($body, $item_id, $task_priority)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiDocumentCreateTempODFAsyncWithHttpInfo
     *
     * DocumentCreateTempODF
     *
     * @param  \Swagger\Client\Model\DocumentCreateTempODFBodyWrapper $body  (required)
     * @param  string $item_id  (optional)
     * @param  int $task_priority  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentCreateTempODFAsyncWithHttpInfo($body, $item_id = null, $task_priority = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentCreateTempODFRequest($body, $item_id, $task_priority);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiDocumentCreateTempODF'
     *
     * @param  \Swagger\Client\Model\DocumentCreateTempODFBodyWrapper $body  (required)
     * @param  string $item_id  (optional)
     * @param  int $task_priority  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiDocumentCreateTempODFRequest($body, $item_id = null, $task_priority = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling restApiDocumentCreateTempODF'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/documents/tempxml/odf';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($item_id !== null) {
            $queryParams['itemID'] = ObjectSerializer::toQueryValue($item_id);
        }
        // query params
        if ($task_priority !== null) {
            $queryParams['taskPriority'] = ObjectSerializer::toQueryValue($task_priority);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiDocumentCreateTempPDF
     *
     * DocumentCreateTempPDF
     *
     * @param  \Swagger\Client\Model\DocumentCreateTempPDFBodyWrapper $body  (required)
     * @param  string $item_id The ID of the document for which to create the PDF (optional)
     * @param  int $task_priority The priority (1-10) of the task (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiDocumentCreateTempPDF($body, $item_id = null, $task_priority = null)
    {
        list($response) = $this->restApiDocumentCreateTempPDFWithHttpInfo($body, $item_id, $task_priority);
        return $response;
    }

    /**
     * Operation restApiDocumentCreateTempPDFWithHttpInfo
     *
     * DocumentCreateTempPDF
     *
     * @param  \Swagger\Client\Model\DocumentCreateTempPDFBodyWrapper $body  (required)
     * @param  string $item_id The ID of the document for which to create the PDF (optional)
     * @param  int $task_priority The priority (1-10) of the task (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiDocumentCreateTempPDFWithHttpInfo($body, $item_id = null, $task_priority = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentCreateTempPDFRequest($body, $item_id, $task_priority);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiDocumentCreateTempPDFAsync
     *
     * DocumentCreateTempPDF
     *
     * @param  \Swagger\Client\Model\DocumentCreateTempPDFBodyWrapper $body  (required)
     * @param  string $item_id The ID of the document for which to create the PDF (optional)
     * @param  int $task_priority The priority (1-10) of the task (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentCreateTempPDFAsync($body, $item_id = null, $task_priority = null)
    {
        return $this->restApiDocumentCreateTempPDFAsyncWithHttpInfo($body, $item_id, $task_priority)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiDocumentCreateTempPDFAsyncWithHttpInfo
     *
     * DocumentCreateTempPDF
     *
     * @param  \Swagger\Client\Model\DocumentCreateTempPDFBodyWrapper $body  (required)
     * @param  string $item_id The ID of the document for which to create the PDF (optional)
     * @param  int $task_priority The priority (1-10) of the task (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentCreateTempPDFAsyncWithHttpInfo($body, $item_id = null, $task_priority = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentCreateTempPDFRequest($body, $item_id, $task_priority);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiDocumentCreateTempPDF'
     *
     * @param  \Swagger\Client\Model\DocumentCreateTempPDFBodyWrapper $body  (required)
     * @param  string $item_id The ID of the document for which to create the PDF (optional)
     * @param  int $task_priority The priority (1-10) of the task (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiDocumentCreateTempPDFRequest($body, $item_id = null, $task_priority = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling restApiDocumentCreateTempPDF'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/documents/tempxml/pdf';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($item_id !== null) {
            $queryParams['itemID'] = ObjectSerializer::toQueryValue($item_id);
        }
        // query params
        if ($task_priority !== null) {
            $queryParams['taskPriority'] = ObjectSerializer::toQueryValue($task_priority);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiDocumentCreateTempPackage
     *
     * DocumentCreateTempPackage
     *
     * @param  \Swagger\Client\Model\DocumentCreateTempPackageBodyWrapper $body  (required)
     * @param  string $item_id The ID of the document for which to create the Package (optional)
     * @param  int $task_priority The priority (1-10) of the task (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiDocumentCreateTempPackage($body, $item_id = null, $task_priority = null)
    {
        list($response) = $this->restApiDocumentCreateTempPackageWithHttpInfo($body, $item_id, $task_priority);
        return $response;
    }

    /**
     * Operation restApiDocumentCreateTempPackageWithHttpInfo
     *
     * DocumentCreateTempPackage
     *
     * @param  \Swagger\Client\Model\DocumentCreateTempPackageBodyWrapper $body  (required)
     * @param  string $item_id The ID of the document for which to create the Package (optional)
     * @param  int $task_priority The priority (1-10) of the task (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiDocumentCreateTempPackageWithHttpInfo($body, $item_id = null, $task_priority = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentCreateTempPackageRequest($body, $item_id, $task_priority);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiDocumentCreateTempPackageAsync
     *
     * DocumentCreateTempPackage
     *
     * @param  \Swagger\Client\Model\DocumentCreateTempPackageBodyWrapper $body  (required)
     * @param  string $item_id The ID of the document for which to create the Package (optional)
     * @param  int $task_priority The priority (1-10) of the task (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentCreateTempPackageAsync($body, $item_id = null, $task_priority = null)
    {
        return $this->restApiDocumentCreateTempPackageAsyncWithHttpInfo($body, $item_id, $task_priority)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiDocumentCreateTempPackageAsyncWithHttpInfo
     *
     * DocumentCreateTempPackage
     *
     * @param  \Swagger\Client\Model\DocumentCreateTempPackageBodyWrapper $body  (required)
     * @param  string $item_id The ID of the document for which to create the Package (optional)
     * @param  int $task_priority The priority (1-10) of the task (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentCreateTempPackageAsyncWithHttpInfo($body, $item_id = null, $task_priority = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentCreateTempPackageRequest($body, $item_id, $task_priority);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiDocumentCreateTempPackage'
     *
     * @param  \Swagger\Client\Model\DocumentCreateTempPackageBodyWrapper $body  (required)
     * @param  string $item_id The ID of the document for which to create the Package (optional)
     * @param  int $task_priority The priority (1-10) of the task (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiDocumentCreateTempPackageRequest($body, $item_id = null, $task_priority = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling restApiDocumentCreateTempPackage'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/documents/tempxml/package';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($item_id !== null) {
            $queryParams['itemID'] = ObjectSerializer::toQueryValue($item_id);
        }
        // query params
        if ($task_priority !== null) {
            $queryParams['taskPriority'] = ObjectSerializer::toQueryValue($task_priority);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiDocumentGetAnnotations
     *
     * DocumentGetAnnotations
     *
     * @param  string $item_id The ID of the document for which to return the placed annotations (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiDocumentGetAnnotations($item_id)
    {
        list($response) = $this->restApiDocumentGetAnnotationsWithHttpInfo($item_id);
        return $response;
    }

    /**
     * Operation restApiDocumentGetAnnotationsWithHttpInfo
     *
     * DocumentGetAnnotations
     *
     * @param  string $item_id The ID of the document for which to return the placed annotations (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiDocumentGetAnnotationsWithHttpInfo($item_id)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentGetAnnotationsRequest($item_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiDocumentGetAnnotationsAsync
     *
     * DocumentGetAnnotations
     *
     * @param  string $item_id The ID of the document for which to return the placed annotations (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentGetAnnotationsAsync($item_id)
    {
        return $this->restApiDocumentGetAnnotationsAsyncWithHttpInfo($item_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiDocumentGetAnnotationsAsyncWithHttpInfo
     *
     * DocumentGetAnnotations
     *
     * @param  string $item_id The ID of the document for which to return the placed annotations (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentGetAnnotationsAsyncWithHttpInfo($item_id)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentGetAnnotationsRequest($item_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiDocumentGetAnnotations'
     *
     * @param  string $item_id The ID of the document for which to return the placed annotations (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiDocumentGetAnnotationsRequest($item_id)
    {
        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling restApiDocumentGetAnnotations'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/documents/{itemID}/annotations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemID' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiDocumentGetDefaultSettings
     *
     * DocumentGetDefaultSettings
     *
     * @param  string $item_id The document&#39;s ID (optional)
     * @param  string $view_type If &#39;view&#39;,  the settings required for a Viewer are returned (optional)
     * @param  string $view_prefs_id Optional ID for the viewpreferences to be loaded (if not present, the default will be used) (optional)
     * @param  string $constraint_id Optional ID for the constraints to apply to the document (if not provided, the default will be used) (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiDocumentGetDefaultSettings($item_id = null, $view_type = null, $view_prefs_id = null, $constraint_id = null)
    {
        list($response) = $this->restApiDocumentGetDefaultSettingsWithHttpInfo($item_id, $view_type, $view_prefs_id, $constraint_id);
        return $response;
    }

    /**
     * Operation restApiDocumentGetDefaultSettingsWithHttpInfo
     *
     * DocumentGetDefaultSettings
     *
     * @param  string $item_id The document&#39;s ID (optional)
     * @param  string $view_type If &#39;view&#39;,  the settings required for a Viewer are returned (optional)
     * @param  string $view_prefs_id Optional ID for the viewpreferences to be loaded (if not present, the default will be used) (optional)
     * @param  string $constraint_id Optional ID for the constraints to apply to the document (if not provided, the default will be used) (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiDocumentGetDefaultSettingsWithHttpInfo($item_id = null, $view_type = null, $view_prefs_id = null, $constraint_id = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentGetDefaultSettingsRequest($item_id, $view_type, $view_prefs_id, $constraint_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiDocumentGetDefaultSettingsAsync
     *
     * DocumentGetDefaultSettings
     *
     * @param  string $item_id The document&#39;s ID (optional)
     * @param  string $view_type If &#39;view&#39;,  the settings required for a Viewer are returned (optional)
     * @param  string $view_prefs_id Optional ID for the viewpreferences to be loaded (if not present, the default will be used) (optional)
     * @param  string $constraint_id Optional ID for the constraints to apply to the document (if not provided, the default will be used) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentGetDefaultSettingsAsync($item_id = null, $view_type = null, $view_prefs_id = null, $constraint_id = null)
    {
        return $this->restApiDocumentGetDefaultSettingsAsyncWithHttpInfo($item_id, $view_type, $view_prefs_id, $constraint_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiDocumentGetDefaultSettingsAsyncWithHttpInfo
     *
     * DocumentGetDefaultSettings
     *
     * @param  string $item_id The document&#39;s ID (optional)
     * @param  string $view_type If &#39;view&#39;,  the settings required for a Viewer are returned (optional)
     * @param  string $view_prefs_id Optional ID for the viewpreferences to be loaded (if not present, the default will be used) (optional)
     * @param  string $constraint_id Optional ID for the constraints to apply to the document (if not provided, the default will be used) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentGetDefaultSettingsAsyncWithHttpInfo($item_id = null, $view_type = null, $view_prefs_id = null, $constraint_id = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentGetDefaultSettingsRequest($item_id, $view_type, $view_prefs_id, $constraint_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiDocumentGetDefaultSettings'
     *
     * @param  string $item_id The document&#39;s ID (optional)
     * @param  string $view_type If &#39;view&#39;,  the settings required for a Viewer are returned (optional)
     * @param  string $view_prefs_id Optional ID for the viewpreferences to be loaded (if not present, the default will be used) (optional)
     * @param  string $constraint_id Optional ID for the constraints to apply to the document (if not provided, the default will be used) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiDocumentGetDefaultSettingsRequest($item_id = null, $view_type = null, $view_prefs_id = null, $constraint_id = null)
    {

        $resourcePath = '/rest-api/v1.2/resources/documents/defaultsettings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($item_id !== null) {
            $queryParams['itemID'] = ObjectSerializer::toQueryValue($item_id);
        }
        // query params
        if ($view_type !== null) {
            $queryParams['viewType'] = ObjectSerializer::toQueryValue($view_type);
        }
        // query params
        if ($view_prefs_id !== null) {
            $queryParams['viewPrefsID'] = ObjectSerializer::toQueryValue($view_prefs_id);
        }
        // query params
        if ($constraint_id !== null) {
            $queryParams['constraintID'] = ObjectSerializer::toQueryValue($constraint_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiDocumentGetDocumentEventActions
     *
     * DocumentGetDocumentEventActions
     *
     * @param  string $item_id The document&#39;s ID (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiDocumentGetDocumentEventActions($item_id)
    {
        list($response) = $this->restApiDocumentGetDocumentEventActionsWithHttpInfo($item_id);
        return $response;
    }

    /**
     * Operation restApiDocumentGetDocumentEventActionsWithHttpInfo
     *
     * DocumentGetDocumentEventActions
     *
     * @param  string $item_id The document&#39;s ID (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiDocumentGetDocumentEventActionsWithHttpInfo($item_id)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentGetDocumentEventActionsRequest($item_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiDocumentGetDocumentEventActionsAsync
     *
     * DocumentGetDocumentEventActions
     *
     * @param  string $item_id The document&#39;s ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentGetDocumentEventActionsAsync($item_id)
    {
        return $this->restApiDocumentGetDocumentEventActionsAsyncWithHttpInfo($item_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiDocumentGetDocumentEventActionsAsyncWithHttpInfo
     *
     * DocumentGetDocumentEventActions
     *
     * @param  string $item_id The document&#39;s ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentGetDocumentEventActionsAsyncWithHttpInfo($item_id)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentGetDocumentEventActionsRequest($item_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiDocumentGetDocumentEventActions'
     *
     * @param  string $item_id The document&#39;s ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiDocumentGetDocumentEventActionsRequest($item_id)
    {
        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling restApiDocumentGetDocumentEventActions'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/documents/{itemID}/eventactions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemID' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiDocumentGetFoldingViewerURL
     *
     * DocumentGetFoldingViewerURL
     *
     * @param  \Swagger\Client\Model\DocumentGetFoldingViewerURLBodyWrapper $body  (required)
     * @param  string $item_id  (required)
     * @param  string $folding_settings_id  (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiDocumentGetFoldingViewerURL($body, $item_id, $folding_settings_id = null)
    {
        list($response) = $this->restApiDocumentGetFoldingViewerURLWithHttpInfo($body, $item_id, $folding_settings_id);
        return $response;
    }

    /**
     * Operation restApiDocumentGetFoldingViewerURLWithHttpInfo
     *
     * DocumentGetFoldingViewerURL
     *
     * @param  \Swagger\Client\Model\DocumentGetFoldingViewerURLBodyWrapper $body  (required)
     * @param  string $item_id  (required)
     * @param  string $folding_settings_id  (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiDocumentGetFoldingViewerURLWithHttpInfo($body, $item_id, $folding_settings_id = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentGetFoldingViewerURLRequest($body, $item_id, $folding_settings_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiDocumentGetFoldingViewerURLAsync
     *
     * DocumentGetFoldingViewerURL
     *
     * @param  \Swagger\Client\Model\DocumentGetFoldingViewerURLBodyWrapper $body  (required)
     * @param  string $item_id  (required)
     * @param  string $folding_settings_id  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentGetFoldingViewerURLAsync($body, $item_id, $folding_settings_id = null)
    {
        return $this->restApiDocumentGetFoldingViewerURLAsyncWithHttpInfo($body, $item_id, $folding_settings_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiDocumentGetFoldingViewerURLAsyncWithHttpInfo
     *
     * DocumentGetFoldingViewerURL
     *
     * @param  \Swagger\Client\Model\DocumentGetFoldingViewerURLBodyWrapper $body  (required)
     * @param  string $item_id  (required)
     * @param  string $folding_settings_id  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentGetFoldingViewerURLAsyncWithHttpInfo($body, $item_id, $folding_settings_id = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentGetFoldingViewerURLRequest($body, $item_id, $folding_settings_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiDocumentGetFoldingViewerURL'
     *
     * @param  \Swagger\Client\Model\DocumentGetFoldingViewerURLBodyWrapper $body  (required)
     * @param  string $item_id  (required)
     * @param  string $folding_settings_id  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiDocumentGetFoldingViewerURLRequest($body, $item_id, $folding_settings_id = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling restApiDocumentGetFoldingViewerURL'
            );
        }
        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling restApiDocumentGetFoldingViewerURL'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/documents/{itemID}/urls/foldingviewer';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($folding_settings_id !== null) {
            $queryParams['foldingSettingsID'] = ObjectSerializer::toQueryValue($folding_settings_id);
        }

        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemID' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiDocumentGetHTMLEditorURL
     *
     * DocumentGetHTMLEditorURL
     *
     * @param  string $item_id The document&#39;s ID (required)
     * @param  string $work_space_id The (optional) WorkSpace ID for the Editor (emtpy string to use the default) (optional)
     * @param  string $view_prefs_id The (optional) ViewPreferences ID for the Editor (emtpy string to use the default) (optional)
     * @param  string $constraints_id The (optional) Constraints ID for the Editor (emtpy string to use the default) (optional)
     * @param  bool $viewer_only The (optional) DocumentConstraints ID for the Editor (emtpy string to use the default) (optional)
     * @param  bool $for_anonymous_user If true, the anonymous user&#39;s apiKey will be appended. This does require the anonymous user to have view or edit privileges on the Documents resource (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiDocumentGetHTMLEditorURL($item_id, $work_space_id = null, $view_prefs_id = null, $constraints_id = null, $viewer_only = null, $for_anonymous_user = null)
    {
        list($response) = $this->restApiDocumentGetHTMLEditorURLWithHttpInfo($item_id, $work_space_id, $view_prefs_id, $constraints_id, $viewer_only, $for_anonymous_user);
        return $response;
    }

    /**
     * Operation restApiDocumentGetHTMLEditorURLWithHttpInfo
     *
     * DocumentGetHTMLEditorURL
     *
     * @param  string $item_id The document&#39;s ID (required)
     * @param  string $work_space_id The (optional) WorkSpace ID for the Editor (emtpy string to use the default) (optional)
     * @param  string $view_prefs_id The (optional) ViewPreferences ID for the Editor (emtpy string to use the default) (optional)
     * @param  string $constraints_id The (optional) Constraints ID for the Editor (emtpy string to use the default) (optional)
     * @param  bool $viewer_only The (optional) DocumentConstraints ID for the Editor (emtpy string to use the default) (optional)
     * @param  bool $for_anonymous_user If true, the anonymous user&#39;s apiKey will be appended. This does require the anonymous user to have view or edit privileges on the Documents resource (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiDocumentGetHTMLEditorURLWithHttpInfo($item_id, $work_space_id = null, $view_prefs_id = null, $constraints_id = null, $viewer_only = null, $for_anonymous_user = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentGetHTMLEditorURLRequest($item_id, $work_space_id, $view_prefs_id, $constraints_id, $viewer_only, $for_anonymous_user);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiDocumentGetHTMLEditorURLAsync
     *
     * DocumentGetHTMLEditorURL
     *
     * @param  string $item_id The document&#39;s ID (required)
     * @param  string $work_space_id The (optional) WorkSpace ID for the Editor (emtpy string to use the default) (optional)
     * @param  string $view_prefs_id The (optional) ViewPreferences ID for the Editor (emtpy string to use the default) (optional)
     * @param  string $constraints_id The (optional) Constraints ID for the Editor (emtpy string to use the default) (optional)
     * @param  bool $viewer_only The (optional) DocumentConstraints ID for the Editor (emtpy string to use the default) (optional)
     * @param  bool $for_anonymous_user If true, the anonymous user&#39;s apiKey will be appended. This does require the anonymous user to have view or edit privileges on the Documents resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentGetHTMLEditorURLAsync($item_id, $work_space_id = null, $view_prefs_id = null, $constraints_id = null, $viewer_only = null, $for_anonymous_user = null)
    {
        return $this->restApiDocumentGetHTMLEditorURLAsyncWithHttpInfo($item_id, $work_space_id, $view_prefs_id, $constraints_id, $viewer_only, $for_anonymous_user)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiDocumentGetHTMLEditorURLAsyncWithHttpInfo
     *
     * DocumentGetHTMLEditorURL
     *
     * @param  string $item_id The document&#39;s ID (required)
     * @param  string $work_space_id The (optional) WorkSpace ID for the Editor (emtpy string to use the default) (optional)
     * @param  string $view_prefs_id The (optional) ViewPreferences ID for the Editor (emtpy string to use the default) (optional)
     * @param  string $constraints_id The (optional) Constraints ID for the Editor (emtpy string to use the default) (optional)
     * @param  bool $viewer_only The (optional) DocumentConstraints ID for the Editor (emtpy string to use the default) (optional)
     * @param  bool $for_anonymous_user If true, the anonymous user&#39;s apiKey will be appended. This does require the anonymous user to have view or edit privileges on the Documents resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentGetHTMLEditorURLAsyncWithHttpInfo($item_id, $work_space_id = null, $view_prefs_id = null, $constraints_id = null, $viewer_only = null, $for_anonymous_user = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentGetHTMLEditorURLRequest($item_id, $work_space_id, $view_prefs_id, $constraints_id, $viewer_only, $for_anonymous_user);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiDocumentGetHTMLEditorURL'
     *
     * @param  string $item_id The document&#39;s ID (required)
     * @param  string $work_space_id The (optional) WorkSpace ID for the Editor (emtpy string to use the default) (optional)
     * @param  string $view_prefs_id The (optional) ViewPreferences ID for the Editor (emtpy string to use the default) (optional)
     * @param  string $constraints_id The (optional) Constraints ID for the Editor (emtpy string to use the default) (optional)
     * @param  bool $viewer_only The (optional) DocumentConstraints ID for the Editor (emtpy string to use the default) (optional)
     * @param  bool $for_anonymous_user If true, the anonymous user&#39;s apiKey will be appended. This does require the anonymous user to have view or edit privileges on the Documents resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiDocumentGetHTMLEditorURLRequest($item_id, $work_space_id = null, $view_prefs_id = null, $constraints_id = null, $viewer_only = null, $for_anonymous_user = null)
    {
        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling restApiDocumentGetHTMLEditorURL'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/documents/{itemID}/urls/editor';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($work_space_id !== null) {
            $queryParams['workSpaceID'] = ObjectSerializer::toQueryValue($work_space_id);
        }
        // query params
        if ($view_prefs_id !== null) {
            $queryParams['viewPrefsID'] = ObjectSerializer::toQueryValue($view_prefs_id);
        }
        // query params
        if ($constraints_id !== null) {
            $queryParams['constraintsID'] = ObjectSerializer::toQueryValue($constraints_id);
        }
        // query params
        if ($viewer_only !== null) {
            $queryParams['viewerOnly'] = ObjectSerializer::toQueryValue($viewer_only);
        }
        // query params
        if ($for_anonymous_user !== null) {
            $queryParams['forAnonymousUser'] = ObjectSerializer::toQueryValue($for_anonymous_user);
        }

        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemID' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiDocumentGetHTMLFoldingViewerURL
     *
     * DocumentGetHTMLFoldingViewerURL
     *
     * @param  \Swagger\Client\Model\DocumentGetHTMLFoldingViewerURLBodyWrapper $body  (required)
     * @param  string $item_id  (required)
     * @param  string $folding_settings_id  (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiDocumentGetHTMLFoldingViewerURL($body, $item_id, $folding_settings_id = null)
    {
        list($response) = $this->restApiDocumentGetHTMLFoldingViewerURLWithHttpInfo($body, $item_id, $folding_settings_id);
        return $response;
    }

    /**
     * Operation restApiDocumentGetHTMLFoldingViewerURLWithHttpInfo
     *
     * DocumentGetHTMLFoldingViewerURL
     *
     * @param  \Swagger\Client\Model\DocumentGetHTMLFoldingViewerURLBodyWrapper $body  (required)
     * @param  string $item_id  (required)
     * @param  string $folding_settings_id  (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiDocumentGetHTMLFoldingViewerURLWithHttpInfo($body, $item_id, $folding_settings_id = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentGetHTMLFoldingViewerURLRequest($body, $item_id, $folding_settings_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiDocumentGetHTMLFoldingViewerURLAsync
     *
     * DocumentGetHTMLFoldingViewerURL
     *
     * @param  \Swagger\Client\Model\DocumentGetHTMLFoldingViewerURLBodyWrapper $body  (required)
     * @param  string $item_id  (required)
     * @param  string $folding_settings_id  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentGetHTMLFoldingViewerURLAsync($body, $item_id, $folding_settings_id = null)
    {
        return $this->restApiDocumentGetHTMLFoldingViewerURLAsyncWithHttpInfo($body, $item_id, $folding_settings_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiDocumentGetHTMLFoldingViewerURLAsyncWithHttpInfo
     *
     * DocumentGetHTMLFoldingViewerURL
     *
     * @param  \Swagger\Client\Model\DocumentGetHTMLFoldingViewerURLBodyWrapper $body  (required)
     * @param  string $item_id  (required)
     * @param  string $folding_settings_id  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentGetHTMLFoldingViewerURLAsyncWithHttpInfo($body, $item_id, $folding_settings_id = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentGetHTMLFoldingViewerURLRequest($body, $item_id, $folding_settings_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiDocumentGetHTMLFoldingViewerURL'
     *
     * @param  \Swagger\Client\Model\DocumentGetHTMLFoldingViewerURLBodyWrapper $body  (required)
     * @param  string $item_id  (required)
     * @param  string $folding_settings_id  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiDocumentGetHTMLFoldingViewerURLRequest($body, $item_id, $folding_settings_id = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling restApiDocumentGetHTMLFoldingViewerURL'
            );
        }
        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling restApiDocumentGetHTMLFoldingViewerURL'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/documents/{itemID}/urls/htmlfoldingviewer';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($folding_settings_id !== null) {
            $queryParams['foldingSettingsID'] = ObjectSerializer::toQueryValue($folding_settings_id);
        }

        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemID' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiDocumentGetHTMLPreload
     *
     * DocumentGetHTMLPreload
     *
     * @param  string $item_id The (optional) document&#39;s ID use &#39;none&#39; for REST API (required)
     * @param  string $work_space_id The (optional) WorkSpace ID for the Editor (emtpy string to use the default) (optional)
     * @param  string $view_prefs_id The (optional) ViewPreferences ID for the Editor (emtpy string to use the default) (optional)
     * @param  string $constraints_id The (optional) Constraints ID for the Editor (emtpy string to use the default) (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiDocumentGetHTMLPreload($item_id, $work_space_id = null, $view_prefs_id = null, $constraints_id = null)
    {
        list($response) = $this->restApiDocumentGetHTMLPreloadWithHttpInfo($item_id, $work_space_id, $view_prefs_id, $constraints_id);
        return $response;
    }

    /**
     * Operation restApiDocumentGetHTMLPreloadWithHttpInfo
     *
     * DocumentGetHTMLPreload
     *
     * @param  string $item_id The (optional) document&#39;s ID use &#39;none&#39; for REST API (required)
     * @param  string $work_space_id The (optional) WorkSpace ID for the Editor (emtpy string to use the default) (optional)
     * @param  string $view_prefs_id The (optional) ViewPreferences ID for the Editor (emtpy string to use the default) (optional)
     * @param  string $constraints_id The (optional) Constraints ID for the Editor (emtpy string to use the default) (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiDocumentGetHTMLPreloadWithHttpInfo($item_id, $work_space_id = null, $view_prefs_id = null, $constraints_id = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentGetHTMLPreloadRequest($item_id, $work_space_id, $view_prefs_id, $constraints_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiDocumentGetHTMLPreloadAsync
     *
     * DocumentGetHTMLPreload
     *
     * @param  string $item_id The (optional) document&#39;s ID use &#39;none&#39; for REST API (required)
     * @param  string $work_space_id The (optional) WorkSpace ID for the Editor (emtpy string to use the default) (optional)
     * @param  string $view_prefs_id The (optional) ViewPreferences ID for the Editor (emtpy string to use the default) (optional)
     * @param  string $constraints_id The (optional) Constraints ID for the Editor (emtpy string to use the default) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentGetHTMLPreloadAsync($item_id, $work_space_id = null, $view_prefs_id = null, $constraints_id = null)
    {
        return $this->restApiDocumentGetHTMLPreloadAsyncWithHttpInfo($item_id, $work_space_id, $view_prefs_id, $constraints_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiDocumentGetHTMLPreloadAsyncWithHttpInfo
     *
     * DocumentGetHTMLPreload
     *
     * @param  string $item_id The (optional) document&#39;s ID use &#39;none&#39; for REST API (required)
     * @param  string $work_space_id The (optional) WorkSpace ID for the Editor (emtpy string to use the default) (optional)
     * @param  string $view_prefs_id The (optional) ViewPreferences ID for the Editor (emtpy string to use the default) (optional)
     * @param  string $constraints_id The (optional) Constraints ID for the Editor (emtpy string to use the default) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentGetHTMLPreloadAsyncWithHttpInfo($item_id, $work_space_id = null, $view_prefs_id = null, $constraints_id = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentGetHTMLPreloadRequest($item_id, $work_space_id, $view_prefs_id, $constraints_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiDocumentGetHTMLPreload'
     *
     * @param  string $item_id The (optional) document&#39;s ID use &#39;none&#39; for REST API (required)
     * @param  string $work_space_id The (optional) WorkSpace ID for the Editor (emtpy string to use the default) (optional)
     * @param  string $view_prefs_id The (optional) ViewPreferences ID for the Editor (emtpy string to use the default) (optional)
     * @param  string $constraints_id The (optional) Constraints ID for the Editor (emtpy string to use the default) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiDocumentGetHTMLPreloadRequest($item_id, $work_space_id = null, $view_prefs_id = null, $constraints_id = null)
    {
        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling restApiDocumentGetHTMLPreload'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/documents/{itemID}/htmlpreload';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($work_space_id !== null) {
            $queryParams['workSpaceID'] = ObjectSerializer::toQueryValue($work_space_id);
        }
        // query params
        if ($view_prefs_id !== null) {
            $queryParams['viewPrefsID'] = ObjectSerializer::toQueryValue($view_prefs_id);
        }
        // query params
        if ($constraints_id !== null) {
            $queryParams['constraintsID'] = ObjectSerializer::toQueryValue($constraints_id);
        }

        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemID' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiDocumentGetHTMLPreloadURL
     *
     * DocumentGetHTMLPreloadURL
     *
     * @param  string $item_id The (optional) document&#39;s ID use &#39;none&#39; in REST API (required)
     * @param  string $work_space_id The (optional) WorkSpace ID for the Editor (emtpy string to use the default) (optional)
     * @param  string $view_prefs_id The (optional) ViewPreferences ID for the Editor (emtpy string to use the default) (optional)
     * @param  string $constraints_id The (optional) Constraints ID for the Editor (emtpy string to use the default) (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiDocumentGetHTMLPreloadURL($item_id, $work_space_id = null, $view_prefs_id = null, $constraints_id = null)
    {
        list($response) = $this->restApiDocumentGetHTMLPreloadURLWithHttpInfo($item_id, $work_space_id, $view_prefs_id, $constraints_id);
        return $response;
    }

    /**
     * Operation restApiDocumentGetHTMLPreloadURLWithHttpInfo
     *
     * DocumentGetHTMLPreloadURL
     *
     * @param  string $item_id The (optional) document&#39;s ID use &#39;none&#39; in REST API (required)
     * @param  string $work_space_id The (optional) WorkSpace ID for the Editor (emtpy string to use the default) (optional)
     * @param  string $view_prefs_id The (optional) ViewPreferences ID for the Editor (emtpy string to use the default) (optional)
     * @param  string $constraints_id The (optional) Constraints ID for the Editor (emtpy string to use the default) (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiDocumentGetHTMLPreloadURLWithHttpInfo($item_id, $work_space_id = null, $view_prefs_id = null, $constraints_id = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentGetHTMLPreloadURLRequest($item_id, $work_space_id, $view_prefs_id, $constraints_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiDocumentGetHTMLPreloadURLAsync
     *
     * DocumentGetHTMLPreloadURL
     *
     * @param  string $item_id The (optional) document&#39;s ID use &#39;none&#39; in REST API (required)
     * @param  string $work_space_id The (optional) WorkSpace ID for the Editor (emtpy string to use the default) (optional)
     * @param  string $view_prefs_id The (optional) ViewPreferences ID for the Editor (emtpy string to use the default) (optional)
     * @param  string $constraints_id The (optional) Constraints ID for the Editor (emtpy string to use the default) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentGetHTMLPreloadURLAsync($item_id, $work_space_id = null, $view_prefs_id = null, $constraints_id = null)
    {
        return $this->restApiDocumentGetHTMLPreloadURLAsyncWithHttpInfo($item_id, $work_space_id, $view_prefs_id, $constraints_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiDocumentGetHTMLPreloadURLAsyncWithHttpInfo
     *
     * DocumentGetHTMLPreloadURL
     *
     * @param  string $item_id The (optional) document&#39;s ID use &#39;none&#39; in REST API (required)
     * @param  string $work_space_id The (optional) WorkSpace ID for the Editor (emtpy string to use the default) (optional)
     * @param  string $view_prefs_id The (optional) ViewPreferences ID for the Editor (emtpy string to use the default) (optional)
     * @param  string $constraints_id The (optional) Constraints ID for the Editor (emtpy string to use the default) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentGetHTMLPreloadURLAsyncWithHttpInfo($item_id, $work_space_id = null, $view_prefs_id = null, $constraints_id = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentGetHTMLPreloadURLRequest($item_id, $work_space_id, $view_prefs_id, $constraints_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiDocumentGetHTMLPreloadURL'
     *
     * @param  string $item_id The (optional) document&#39;s ID use &#39;none&#39; in REST API (required)
     * @param  string $work_space_id The (optional) WorkSpace ID for the Editor (emtpy string to use the default) (optional)
     * @param  string $view_prefs_id The (optional) ViewPreferences ID for the Editor (emtpy string to use the default) (optional)
     * @param  string $constraints_id The (optional) Constraints ID for the Editor (emtpy string to use the default) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiDocumentGetHTMLPreloadURLRequest($item_id, $work_space_id = null, $view_prefs_id = null, $constraints_id = null)
    {
        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling restApiDocumentGetHTMLPreloadURL'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/documents/{itemID}/urls/htmlpreload';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($work_space_id !== null) {
            $queryParams['workSpaceID'] = ObjectSerializer::toQueryValue($work_space_id);
        }
        // query params
        if ($view_prefs_id !== null) {
            $queryParams['viewPrefsID'] = ObjectSerializer::toQueryValue($view_prefs_id);
        }
        // query params
        if ($constraints_id !== null) {
            $queryParams['constraintsID'] = ObjectSerializer::toQueryValue($constraints_id);
        }

        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemID' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiDocumentGetHTMLThreeDModelViewerURL
     *
     * DocumentGetHTMLThreeDModelViewerURL
     *
     * @param  \Swagger\Client\Model\DocumentGetHTMLThreeDModelViewerURLBodyWrapper $body  (required)
     * @param  string $item_id  (required)
     * @param  string $three_d_model_id  (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiDocumentGetHTMLThreeDModelViewerURL($body, $item_id, $three_d_model_id = null)
    {
        list($response) = $this->restApiDocumentGetHTMLThreeDModelViewerURLWithHttpInfo($body, $item_id, $three_d_model_id);
        return $response;
    }

    /**
     * Operation restApiDocumentGetHTMLThreeDModelViewerURLWithHttpInfo
     *
     * DocumentGetHTMLThreeDModelViewerURL
     *
     * @param  \Swagger\Client\Model\DocumentGetHTMLThreeDModelViewerURLBodyWrapper $body  (required)
     * @param  string $item_id  (required)
     * @param  string $three_d_model_id  (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiDocumentGetHTMLThreeDModelViewerURLWithHttpInfo($body, $item_id, $three_d_model_id = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentGetHTMLThreeDModelViewerURLRequest($body, $item_id, $three_d_model_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiDocumentGetHTMLThreeDModelViewerURLAsync
     *
     * DocumentGetHTMLThreeDModelViewerURL
     *
     * @param  \Swagger\Client\Model\DocumentGetHTMLThreeDModelViewerURLBodyWrapper $body  (required)
     * @param  string $item_id  (required)
     * @param  string $three_d_model_id  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentGetHTMLThreeDModelViewerURLAsync($body, $item_id, $three_d_model_id = null)
    {
        return $this->restApiDocumentGetHTMLThreeDModelViewerURLAsyncWithHttpInfo($body, $item_id, $three_d_model_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiDocumentGetHTMLThreeDModelViewerURLAsyncWithHttpInfo
     *
     * DocumentGetHTMLThreeDModelViewerURL
     *
     * @param  \Swagger\Client\Model\DocumentGetHTMLThreeDModelViewerURLBodyWrapper $body  (required)
     * @param  string $item_id  (required)
     * @param  string $three_d_model_id  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentGetHTMLThreeDModelViewerURLAsyncWithHttpInfo($body, $item_id, $three_d_model_id = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentGetHTMLThreeDModelViewerURLRequest($body, $item_id, $three_d_model_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiDocumentGetHTMLThreeDModelViewerURL'
     *
     * @param  \Swagger\Client\Model\DocumentGetHTMLThreeDModelViewerURLBodyWrapper $body  (required)
     * @param  string $item_id  (required)
     * @param  string $three_d_model_id  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiDocumentGetHTMLThreeDModelViewerURLRequest($body, $item_id, $three_d_model_id = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling restApiDocumentGetHTMLThreeDModelViewerURL'
            );
        }
        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling restApiDocumentGetHTMLThreeDModelViewerURL'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/documents/{itemID}/urls/htmlthreedmodelviewer';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($three_d_model_id !== null) {
            $queryParams['threeDModelID'] = ObjectSerializer::toQueryValue($three_d_model_id);
        }

        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemID' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiDocumentGetInfo
     *
     * DocumentGetInfo
     *
     * @param  string $item_id The document&#39;s ID (required)
     * @param  bool $extended If true, additional information is returned (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiDocumentGetInfo($item_id, $extended = null)
    {
        list($response) = $this->restApiDocumentGetInfoWithHttpInfo($item_id, $extended);
        return $response;
    }

    /**
     * Operation restApiDocumentGetInfoWithHttpInfo
     *
     * DocumentGetInfo
     *
     * @param  string $item_id The document&#39;s ID (required)
     * @param  bool $extended If true, additional information is returned (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiDocumentGetInfoWithHttpInfo($item_id, $extended = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentGetInfoRequest($item_id, $extended);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiDocumentGetInfoAsync
     *
     * DocumentGetInfo
     *
     * @param  string $item_id The document&#39;s ID (required)
     * @param  bool $extended If true, additional information is returned (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentGetInfoAsync($item_id, $extended = null)
    {
        return $this->restApiDocumentGetInfoAsyncWithHttpInfo($item_id, $extended)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiDocumentGetInfoAsyncWithHttpInfo
     *
     * DocumentGetInfo
     *
     * @param  string $item_id The document&#39;s ID (required)
     * @param  bool $extended If true, additional information is returned (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentGetInfoAsyncWithHttpInfo($item_id, $extended = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentGetInfoRequest($item_id, $extended);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiDocumentGetInfo'
     *
     * @param  string $item_id The document&#39;s ID (required)
     * @param  bool $extended If true, additional information is returned (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiDocumentGetInfoRequest($item_id, $extended = null)
    {
        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling restApiDocumentGetInfo'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/documents/{itemID}/info';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($extended !== null) {
            $queryParams['extended'] = ObjectSerializer::toQueryValue($extended);
        }

        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemID' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiDocumentGetPreflightResults
     *
     * DocumentGetPreflightResults
     *
     * @param  string $item_id The document&#39;s ID (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiDocumentGetPreflightResults($item_id)
    {
        list($response) = $this->restApiDocumentGetPreflightResultsWithHttpInfo($item_id);
        return $response;
    }

    /**
     * Operation restApiDocumentGetPreflightResultsWithHttpInfo
     *
     * DocumentGetPreflightResults
     *
     * @param  string $item_id The document&#39;s ID (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiDocumentGetPreflightResultsWithHttpInfo($item_id)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentGetPreflightResultsRequest($item_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiDocumentGetPreflightResultsAsync
     *
     * DocumentGetPreflightResults
     *
     * @param  string $item_id The document&#39;s ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentGetPreflightResultsAsync($item_id)
    {
        return $this->restApiDocumentGetPreflightResultsAsyncWithHttpInfo($item_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiDocumentGetPreflightResultsAsyncWithHttpInfo
     *
     * DocumentGetPreflightResults
     *
     * @param  string $item_id The document&#39;s ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentGetPreflightResultsAsyncWithHttpInfo($item_id)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentGetPreflightResultsRequest($item_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiDocumentGetPreflightResults'
     *
     * @param  string $item_id The document&#39;s ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiDocumentGetPreflightResultsRequest($item_id)
    {
        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling restApiDocumentGetPreflightResults'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/documents/{itemID}/preflightresults';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemID' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiDocumentGetThreeDModelViewerURL
     *
     * DocumentGetThreeDModelViewerURL
     *
     * @param  \Swagger\Client\Model\DocumentGetThreeDModelViewerURLBodyWrapper $body  (required)
     * @param  string $item_id  (required)
     * @param  string $three_d_model_id  (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiDocumentGetThreeDModelViewerURL($body, $item_id, $three_d_model_id = null)
    {
        list($response) = $this->restApiDocumentGetThreeDModelViewerURLWithHttpInfo($body, $item_id, $three_d_model_id);
        return $response;
    }

    /**
     * Operation restApiDocumentGetThreeDModelViewerURLWithHttpInfo
     *
     * DocumentGetThreeDModelViewerURL
     *
     * @param  \Swagger\Client\Model\DocumentGetThreeDModelViewerURLBodyWrapper $body  (required)
     * @param  string $item_id  (required)
     * @param  string $three_d_model_id  (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiDocumentGetThreeDModelViewerURLWithHttpInfo($body, $item_id, $three_d_model_id = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentGetThreeDModelViewerURLRequest($body, $item_id, $three_d_model_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiDocumentGetThreeDModelViewerURLAsync
     *
     * DocumentGetThreeDModelViewerURL
     *
     * @param  \Swagger\Client\Model\DocumentGetThreeDModelViewerURLBodyWrapper $body  (required)
     * @param  string $item_id  (required)
     * @param  string $three_d_model_id  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentGetThreeDModelViewerURLAsync($body, $item_id, $three_d_model_id = null)
    {
        return $this->restApiDocumentGetThreeDModelViewerURLAsyncWithHttpInfo($body, $item_id, $three_d_model_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiDocumentGetThreeDModelViewerURLAsyncWithHttpInfo
     *
     * DocumentGetThreeDModelViewerURL
     *
     * @param  \Swagger\Client\Model\DocumentGetThreeDModelViewerURLBodyWrapper $body  (required)
     * @param  string $item_id  (required)
     * @param  string $three_d_model_id  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentGetThreeDModelViewerURLAsyncWithHttpInfo($body, $item_id, $three_d_model_id = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentGetThreeDModelViewerURLRequest($body, $item_id, $three_d_model_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiDocumentGetThreeDModelViewerURL'
     *
     * @param  \Swagger\Client\Model\DocumentGetThreeDModelViewerURLBodyWrapper $body  (required)
     * @param  string $item_id  (required)
     * @param  string $three_d_model_id  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiDocumentGetThreeDModelViewerURLRequest($body, $item_id, $three_d_model_id = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling restApiDocumentGetThreeDModelViewerURL'
            );
        }
        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling restApiDocumentGetThreeDModelViewerURL'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/documents/{itemID}/urls/threedmodelviewer';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($three_d_model_id !== null) {
            $queryParams['threeDModelID'] = ObjectSerializer::toQueryValue($three_d_model_id);
        }

        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemID' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiDocumentGetUsedAssets
     *
     * DocumentGetUsedAssets
     *
     * @param  string $item_id The document&#39;s ID (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiDocumentGetUsedAssets($item_id)
    {
        list($response) = $this->restApiDocumentGetUsedAssetsWithHttpInfo($item_id);
        return $response;
    }

    /**
     * Operation restApiDocumentGetUsedAssetsWithHttpInfo
     *
     * DocumentGetUsedAssets
     *
     * @param  string $item_id The document&#39;s ID (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiDocumentGetUsedAssetsWithHttpInfo($item_id)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentGetUsedAssetsRequest($item_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiDocumentGetUsedAssetsAsync
     *
     * DocumentGetUsedAssets
     *
     * @param  string $item_id The document&#39;s ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentGetUsedAssetsAsync($item_id)
    {
        return $this->restApiDocumentGetUsedAssetsAsyncWithHttpInfo($item_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiDocumentGetUsedAssetsAsyncWithHttpInfo
     *
     * DocumentGetUsedAssets
     *
     * @param  string $item_id The document&#39;s ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentGetUsedAssetsAsyncWithHttpInfo($item_id)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentGetUsedAssetsRequest($item_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiDocumentGetUsedAssets'
     *
     * @param  string $item_id The document&#39;s ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiDocumentGetUsedAssetsRequest($item_id)
    {
        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling restApiDocumentGetUsedAssets'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/documents/{itemID}/usedassets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemID' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiDocumentGetVariableDefinitions
     *
     * DocumentGetVariableDefinitions
     *
     * @param  string $item_id The document&#39;s ID (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiDocumentGetVariableDefinitions($item_id)
    {
        list($response) = $this->restApiDocumentGetVariableDefinitionsWithHttpInfo($item_id);
        return $response;
    }

    /**
     * Operation restApiDocumentGetVariableDefinitionsWithHttpInfo
     *
     * DocumentGetVariableDefinitions
     *
     * @param  string $item_id The document&#39;s ID (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiDocumentGetVariableDefinitionsWithHttpInfo($item_id)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentGetVariableDefinitionsRequest($item_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiDocumentGetVariableDefinitionsAsync
     *
     * DocumentGetVariableDefinitions
     *
     * @param  string $item_id The document&#39;s ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentGetVariableDefinitionsAsync($item_id)
    {
        return $this->restApiDocumentGetVariableDefinitionsAsyncWithHttpInfo($item_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiDocumentGetVariableDefinitionsAsyncWithHttpInfo
     *
     * DocumentGetVariableDefinitions
     *
     * @param  string $item_id The document&#39;s ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentGetVariableDefinitionsAsyncWithHttpInfo($item_id)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentGetVariableDefinitionsRequest($item_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiDocumentGetVariableDefinitions'
     *
     * @param  string $item_id The document&#39;s ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiDocumentGetVariableDefinitionsRequest($item_id)
    {
        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling restApiDocumentGetVariableDefinitions'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/documents/{itemID}/variabledefinitions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemID' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiDocumentGetVariableValues
     *
     * DocumentGetVariableValues
     *
     * @param  string $item_id The document&#39;s ID (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiDocumentGetVariableValues($item_id)
    {
        list($response) = $this->restApiDocumentGetVariableValuesWithHttpInfo($item_id);
        return $response;
    }

    /**
     * Operation restApiDocumentGetVariableValuesWithHttpInfo
     *
     * DocumentGetVariableValues
     *
     * @param  string $item_id The document&#39;s ID (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiDocumentGetVariableValuesWithHttpInfo($item_id)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentGetVariableValuesRequest($item_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiDocumentGetVariableValuesAsync
     *
     * DocumentGetVariableValues
     *
     * @param  string $item_id The document&#39;s ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentGetVariableValuesAsync($item_id)
    {
        return $this->restApiDocumentGetVariableValuesAsyncWithHttpInfo($item_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiDocumentGetVariableValuesAsyncWithHttpInfo
     *
     * DocumentGetVariableValues
     *
     * @param  string $item_id The document&#39;s ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentGetVariableValuesAsyncWithHttpInfo($item_id)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentGetVariableValuesRequest($item_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiDocumentGetVariableValues'
     *
     * @param  string $item_id The document&#39;s ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiDocumentGetVariableValuesRequest($item_id)
    {
        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling restApiDocumentGetVariableValues'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/documents/{itemID}/variablevalues';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemID' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiDocumentProcessServerSide
     *
     * DocumentProcessServerSide
     *
     * @param  \Swagger\Client\Model\DocumentProcessServerSideBodyWrapper $body  (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiDocumentProcessServerSide($body)
    {
        list($response) = $this->restApiDocumentProcessServerSideWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation restApiDocumentProcessServerSideWithHttpInfo
     *
     * DocumentProcessServerSide
     *
     * @param  \Swagger\Client\Model\DocumentProcessServerSideBodyWrapper $body  (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiDocumentProcessServerSideWithHttpInfo($body)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentProcessServerSideRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiDocumentProcessServerSideAsync
     *
     * DocumentProcessServerSide
     *
     * @param  \Swagger\Client\Model\DocumentProcessServerSideBodyWrapper $body  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentProcessServerSideAsync($body)
    {
        return $this->restApiDocumentProcessServerSideAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiDocumentProcessServerSideAsyncWithHttpInfo
     *
     * DocumentProcessServerSide
     *
     * @param  \Swagger\Client\Model\DocumentProcessServerSideBodyWrapper $body  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentProcessServerSideAsyncWithHttpInfo($body)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentProcessServerSideRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiDocumentProcessServerSide'
     *
     * @param  \Swagger\Client\Model\DocumentProcessServerSideBodyWrapper $body  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiDocumentProcessServerSideRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling restApiDocumentProcessServerSide'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/documents/documentprocessor';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiDocumentSetAnnotations
     *
     * DocumentSetAnnotations
     *
     * @param  string $item_id The document&#39;s ID (required)
     * @param  \Swagger\Client\Model\DocumentSetAnnotationsBodyWrapper $body  (required)
     * @param  bool $replace_existing_annotations If true, all existing annotations will be removed from the target document before the insertion (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiDocumentSetAnnotations($item_id, $body, $replace_existing_annotations = null)
    {
        list($response) = $this->restApiDocumentSetAnnotationsWithHttpInfo($item_id, $body, $replace_existing_annotations);
        return $response;
    }

    /**
     * Operation restApiDocumentSetAnnotationsWithHttpInfo
     *
     * DocumentSetAnnotations
     *
     * @param  string $item_id The document&#39;s ID (required)
     * @param  \Swagger\Client\Model\DocumentSetAnnotationsBodyWrapper $body  (required)
     * @param  bool $replace_existing_annotations If true, all existing annotations will be removed from the target document before the insertion (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiDocumentSetAnnotationsWithHttpInfo($item_id, $body, $replace_existing_annotations = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentSetAnnotationsRequest($item_id, $body, $replace_existing_annotations);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiDocumentSetAnnotationsAsync
     *
     * DocumentSetAnnotations
     *
     * @param  string $item_id The document&#39;s ID (required)
     * @param  \Swagger\Client\Model\DocumentSetAnnotationsBodyWrapper $body  (required)
     * @param  bool $replace_existing_annotations If true, all existing annotations will be removed from the target document before the insertion (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentSetAnnotationsAsync($item_id, $body, $replace_existing_annotations = null)
    {
        return $this->restApiDocumentSetAnnotationsAsyncWithHttpInfo($item_id, $body, $replace_existing_annotations)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiDocumentSetAnnotationsAsyncWithHttpInfo
     *
     * DocumentSetAnnotations
     *
     * @param  string $item_id The document&#39;s ID (required)
     * @param  \Swagger\Client\Model\DocumentSetAnnotationsBodyWrapper $body  (required)
     * @param  bool $replace_existing_annotations If true, all existing annotations will be removed from the target document before the insertion (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentSetAnnotationsAsyncWithHttpInfo($item_id, $body, $replace_existing_annotations = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentSetAnnotationsRequest($item_id, $body, $replace_existing_annotations);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiDocumentSetAnnotations'
     *
     * @param  string $item_id The document&#39;s ID (required)
     * @param  \Swagger\Client\Model\DocumentSetAnnotationsBodyWrapper $body  (required)
     * @param  bool $replace_existing_annotations If true, all existing annotations will be removed from the target document before the insertion (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiDocumentSetAnnotationsRequest($item_id, $body, $replace_existing_annotations = null)
    {
        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling restApiDocumentSetAnnotations'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling restApiDocumentSetAnnotations'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/documents/{itemID}/annotations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($replace_existing_annotations !== null) {
            $queryParams['replaceExistingAnnotations'] = ObjectSerializer::toQueryValue($replace_existing_annotations);
        }

        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemID' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiDocumentSetAssetDirectories
     *
     * DocumentSetAssetDirectories
     *
     * @param  string $document_id The ID of the document to modify (required)
     * @param  string $user_asset_directory The user asset directory (optional)
     * @param  string $user_group_asset_directory The user group asset directory (optional)
     * @param  string $document_asset_directory The document asset directory (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiDocumentSetAssetDirectories($document_id, $user_asset_directory = null, $user_group_asset_directory = null, $document_asset_directory = null)
    {
        list($response) = $this->restApiDocumentSetAssetDirectoriesWithHttpInfo($document_id, $user_asset_directory, $user_group_asset_directory, $document_asset_directory);
        return $response;
    }

    /**
     * Operation restApiDocumentSetAssetDirectoriesWithHttpInfo
     *
     * DocumentSetAssetDirectories
     *
     * @param  string $document_id The ID of the document to modify (required)
     * @param  string $user_asset_directory The user asset directory (optional)
     * @param  string $user_group_asset_directory The user group asset directory (optional)
     * @param  string $document_asset_directory The document asset directory (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiDocumentSetAssetDirectoriesWithHttpInfo($document_id, $user_asset_directory = null, $user_group_asset_directory = null, $document_asset_directory = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentSetAssetDirectoriesRequest($document_id, $user_asset_directory, $user_group_asset_directory, $document_asset_directory);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiDocumentSetAssetDirectoriesAsync
     *
     * DocumentSetAssetDirectories
     *
     * @param  string $document_id The ID of the document to modify (required)
     * @param  string $user_asset_directory The user asset directory (optional)
     * @param  string $user_group_asset_directory The user group asset directory (optional)
     * @param  string $document_asset_directory The document asset directory (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentSetAssetDirectoriesAsync($document_id, $user_asset_directory = null, $user_group_asset_directory = null, $document_asset_directory = null)
    {
        return $this->restApiDocumentSetAssetDirectoriesAsyncWithHttpInfo($document_id, $user_asset_directory, $user_group_asset_directory, $document_asset_directory)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiDocumentSetAssetDirectoriesAsyncWithHttpInfo
     *
     * DocumentSetAssetDirectories
     *
     * @param  string $document_id The ID of the document to modify (required)
     * @param  string $user_asset_directory The user asset directory (optional)
     * @param  string $user_group_asset_directory The user group asset directory (optional)
     * @param  string $document_asset_directory The document asset directory (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentSetAssetDirectoriesAsyncWithHttpInfo($document_id, $user_asset_directory = null, $user_group_asset_directory = null, $document_asset_directory = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentSetAssetDirectoriesRequest($document_id, $user_asset_directory, $user_group_asset_directory, $document_asset_directory);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiDocumentSetAssetDirectories'
     *
     * @param  string $document_id The ID of the document to modify (required)
     * @param  string $user_asset_directory The user asset directory (optional)
     * @param  string $user_group_asset_directory The user group asset directory (optional)
     * @param  string $document_asset_directory The document asset directory (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiDocumentSetAssetDirectoriesRequest($document_id, $user_asset_directory = null, $user_group_asset_directory = null, $document_asset_directory = null)
    {
        // verify the required parameter 'document_id' is set
        if ($document_id === null || (is_array($document_id) && count($document_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_id when calling restApiDocumentSetAssetDirectories'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/documents/{documentID}/assetdirectories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($user_asset_directory !== null) {
            $queryParams['userAssetDirectory'] = ObjectSerializer::toQueryValue($user_asset_directory);
        }
        // query params
        if ($user_group_asset_directory !== null) {
            $queryParams['userGroupAssetDirectory'] = ObjectSerializer::toQueryValue($user_group_asset_directory);
        }
        // query params
        if ($document_asset_directory !== null) {
            $queryParams['documentAssetDirectory'] = ObjectSerializer::toQueryValue($document_asset_directory);
        }

        // path params
        if ($document_id !== null) {
            $resourcePath = str_replace(
                '{' . 'documentID' . '}',
                ObjectSerializer::toPathValue($document_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiDocumentSetConstraints
     *
     * DocumentSetConstraints
     *
     * @param  string $item_id The document&#39;s ID (required)
     * @param  string $constraints_id The ID of the DocumentConstraints resource item (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiDocumentSetConstraints($item_id, $constraints_id)
    {
        list($response) = $this->restApiDocumentSetConstraintsWithHttpInfo($item_id, $constraints_id);
        return $response;
    }

    /**
     * Operation restApiDocumentSetConstraintsWithHttpInfo
     *
     * DocumentSetConstraints
     *
     * @param  string $item_id The document&#39;s ID (required)
     * @param  string $constraints_id The ID of the DocumentConstraints resource item (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiDocumentSetConstraintsWithHttpInfo($item_id, $constraints_id)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentSetConstraintsRequest($item_id, $constraints_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiDocumentSetConstraintsAsync
     *
     * DocumentSetConstraints
     *
     * @param  string $item_id The document&#39;s ID (required)
     * @param  string $constraints_id The ID of the DocumentConstraints resource item (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentSetConstraintsAsync($item_id, $constraints_id)
    {
        return $this->restApiDocumentSetConstraintsAsyncWithHttpInfo($item_id, $constraints_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiDocumentSetConstraintsAsyncWithHttpInfo
     *
     * DocumentSetConstraints
     *
     * @param  string $item_id The document&#39;s ID (required)
     * @param  string $constraints_id The ID of the DocumentConstraints resource item (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentSetConstraintsAsyncWithHttpInfo($item_id, $constraints_id)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentSetConstraintsRequest($item_id, $constraints_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiDocumentSetConstraints'
     *
     * @param  string $item_id The document&#39;s ID (required)
     * @param  string $constraints_id The ID of the DocumentConstraints resource item (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiDocumentSetConstraintsRequest($item_id, $constraints_id)
    {
        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling restApiDocumentSetConstraints'
            );
        }
        // verify the required parameter 'constraints_id' is set
        if ($constraints_id === null || (is_array($constraints_id) && count($constraints_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $constraints_id when calling restApiDocumentSetConstraints'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/documents/{itemID}/constraints';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($constraints_id !== null) {
            $queryParams['constraintsID'] = ObjectSerializer::toQueryValue($constraints_id);
        }

        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemID' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiDocumentSetDataSource
     *
     * DocumentSetDataSource
     *
     * @param  string $item_id  (required)
     * @param  \Swagger\Client\Model\DocumentSetDataSourceBodyWrapper $body  (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiDocumentSetDataSource($item_id, $body)
    {
        list($response) = $this->restApiDocumentSetDataSourceWithHttpInfo($item_id, $body);
        return $response;
    }

    /**
     * Operation restApiDocumentSetDataSourceWithHttpInfo
     *
     * DocumentSetDataSource
     *
     * @param  string $item_id  (required)
     * @param  \Swagger\Client\Model\DocumentSetDataSourceBodyWrapper $body  (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiDocumentSetDataSourceWithHttpInfo($item_id, $body)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentSetDataSourceRequest($item_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiDocumentSetDataSourceAsync
     *
     * DocumentSetDataSource
     *
     * @param  string $item_id  (required)
     * @param  \Swagger\Client\Model\DocumentSetDataSourceBodyWrapper $body  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentSetDataSourceAsync($item_id, $body)
    {
        return $this->restApiDocumentSetDataSourceAsyncWithHttpInfo($item_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiDocumentSetDataSourceAsyncWithHttpInfo
     *
     * DocumentSetDataSource
     *
     * @param  string $item_id  (required)
     * @param  \Swagger\Client\Model\DocumentSetDataSourceBodyWrapper $body  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentSetDataSourceAsyncWithHttpInfo($item_id, $body)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentSetDataSourceRequest($item_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiDocumentSetDataSource'
     *
     * @param  string $item_id  (required)
     * @param  \Swagger\Client\Model\DocumentSetDataSourceBodyWrapper $body  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiDocumentSetDataSourceRequest($item_id, $body)
    {
        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling restApiDocumentSetDataSource'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling restApiDocumentSetDataSource'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/documents/{itemID}/datasource';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemID' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiDocumentSetDocumentEventActions
     *
     * DocumentSetDocumentEventActions
     *
     * @param  string $item_id The document&#39;s ID (required)
     * @param  \Swagger\Client\Model\DocumentSetDocumentEventActionsBodyWrapper $body  (required)
     * @param  bool $replace_existing_actions If true, all existing actions will be removed from the target document before insertion of the new ones (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiDocumentSetDocumentEventActions($item_id, $body, $replace_existing_actions = null)
    {
        list($response) = $this->restApiDocumentSetDocumentEventActionsWithHttpInfo($item_id, $body, $replace_existing_actions);
        return $response;
    }

    /**
     * Operation restApiDocumentSetDocumentEventActionsWithHttpInfo
     *
     * DocumentSetDocumentEventActions
     *
     * @param  string $item_id The document&#39;s ID (required)
     * @param  \Swagger\Client\Model\DocumentSetDocumentEventActionsBodyWrapper $body  (required)
     * @param  bool $replace_existing_actions If true, all existing actions will be removed from the target document before insertion of the new ones (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiDocumentSetDocumentEventActionsWithHttpInfo($item_id, $body, $replace_existing_actions = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentSetDocumentEventActionsRequest($item_id, $body, $replace_existing_actions);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiDocumentSetDocumentEventActionsAsync
     *
     * DocumentSetDocumentEventActions
     *
     * @param  string $item_id The document&#39;s ID (required)
     * @param  \Swagger\Client\Model\DocumentSetDocumentEventActionsBodyWrapper $body  (required)
     * @param  bool $replace_existing_actions If true, all existing actions will be removed from the target document before insertion of the new ones (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentSetDocumentEventActionsAsync($item_id, $body, $replace_existing_actions = null)
    {
        return $this->restApiDocumentSetDocumentEventActionsAsyncWithHttpInfo($item_id, $body, $replace_existing_actions)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiDocumentSetDocumentEventActionsAsyncWithHttpInfo
     *
     * DocumentSetDocumentEventActions
     *
     * @param  string $item_id The document&#39;s ID (required)
     * @param  \Swagger\Client\Model\DocumentSetDocumentEventActionsBodyWrapper $body  (required)
     * @param  bool $replace_existing_actions If true, all existing actions will be removed from the target document before insertion of the new ones (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentSetDocumentEventActionsAsyncWithHttpInfo($item_id, $body, $replace_existing_actions = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentSetDocumentEventActionsRequest($item_id, $body, $replace_existing_actions);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiDocumentSetDocumentEventActions'
     *
     * @param  string $item_id The document&#39;s ID (required)
     * @param  \Swagger\Client\Model\DocumentSetDocumentEventActionsBodyWrapper $body  (required)
     * @param  bool $replace_existing_actions If true, all existing actions will be removed from the target document before insertion of the new ones (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiDocumentSetDocumentEventActionsRequest($item_id, $body, $replace_existing_actions = null)
    {
        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling restApiDocumentSetDocumentEventActions'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling restApiDocumentSetDocumentEventActions'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/documents/{itemID}/eventactions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($replace_existing_actions !== null) {
            $queryParams['replaceExistingActions'] = ObjectSerializer::toQueryValue($replace_existing_actions);
        }

        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemID' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiDocumentSetVariableDefinitions
     *
     * DocumentSetVariableDefinitions
     *
     * @param  string $item_id The document&#39;s ID (required)
     * @param  \Swagger\Client\Model\DocumentSetVariableDefinitionsBodyWrapper $body  (required)
     * @param  bool $replace_existing_variables If true, all existing variables will be removed from the target document before insertion of the new ones (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiDocumentSetVariableDefinitions($item_id, $body, $replace_existing_variables = null)
    {
        list($response) = $this->restApiDocumentSetVariableDefinitionsWithHttpInfo($item_id, $body, $replace_existing_variables);
        return $response;
    }

    /**
     * Operation restApiDocumentSetVariableDefinitionsWithHttpInfo
     *
     * DocumentSetVariableDefinitions
     *
     * @param  string $item_id The document&#39;s ID (required)
     * @param  \Swagger\Client\Model\DocumentSetVariableDefinitionsBodyWrapper $body  (required)
     * @param  bool $replace_existing_variables If true, all existing variables will be removed from the target document before insertion of the new ones (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiDocumentSetVariableDefinitionsWithHttpInfo($item_id, $body, $replace_existing_variables = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentSetVariableDefinitionsRequest($item_id, $body, $replace_existing_variables);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiDocumentSetVariableDefinitionsAsync
     *
     * DocumentSetVariableDefinitions
     *
     * @param  string $item_id The document&#39;s ID (required)
     * @param  \Swagger\Client\Model\DocumentSetVariableDefinitionsBodyWrapper $body  (required)
     * @param  bool $replace_existing_variables If true, all existing variables will be removed from the target document before insertion of the new ones (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentSetVariableDefinitionsAsync($item_id, $body, $replace_existing_variables = null)
    {
        return $this->restApiDocumentSetVariableDefinitionsAsyncWithHttpInfo($item_id, $body, $replace_existing_variables)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiDocumentSetVariableDefinitionsAsyncWithHttpInfo
     *
     * DocumentSetVariableDefinitions
     *
     * @param  string $item_id The document&#39;s ID (required)
     * @param  \Swagger\Client\Model\DocumentSetVariableDefinitionsBodyWrapper $body  (required)
     * @param  bool $replace_existing_variables If true, all existing variables will be removed from the target document before insertion of the new ones (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentSetVariableDefinitionsAsyncWithHttpInfo($item_id, $body, $replace_existing_variables = null)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentSetVariableDefinitionsRequest($item_id, $body, $replace_existing_variables);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiDocumentSetVariableDefinitions'
     *
     * @param  string $item_id The document&#39;s ID (required)
     * @param  \Swagger\Client\Model\DocumentSetVariableDefinitionsBodyWrapper $body  (required)
     * @param  bool $replace_existing_variables If true, all existing variables will be removed from the target document before insertion of the new ones (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiDocumentSetVariableDefinitionsRequest($item_id, $body, $replace_existing_variables = null)
    {
        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling restApiDocumentSetVariableDefinitions'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling restApiDocumentSetVariableDefinitions'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/documents/{itemID}/variabledefinitions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($replace_existing_variables !== null) {
            $queryParams['replaceExistingVariables'] = ObjectSerializer::toQueryValue($replace_existing_variables);
        }

        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemID' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiDocumentSetVariableValues
     *
     * DocumentSetVariableValues
     *
     * @param  string $item_id The document&#39;s ID (required)
     * @param  \Swagger\Client\Model\DocumentSetVariableValuesBodyWrapper $body  (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiDocumentSetVariableValues($item_id, $body)
    {
        list($response) = $this->restApiDocumentSetVariableValuesWithHttpInfo($item_id, $body);
        return $response;
    }

    /**
     * Operation restApiDocumentSetVariableValuesWithHttpInfo
     *
     * DocumentSetVariableValues
     *
     * @param  string $item_id The document&#39;s ID (required)
     * @param  \Swagger\Client\Model\DocumentSetVariableValuesBodyWrapper $body  (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiDocumentSetVariableValuesWithHttpInfo($item_id, $body)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentSetVariableValuesRequest($item_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiDocumentSetVariableValuesAsync
     *
     * DocumentSetVariableValues
     *
     * @param  string $item_id The document&#39;s ID (required)
     * @param  \Swagger\Client\Model\DocumentSetVariableValuesBodyWrapper $body  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentSetVariableValuesAsync($item_id, $body)
    {
        return $this->restApiDocumentSetVariableValuesAsyncWithHttpInfo($item_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiDocumentSetVariableValuesAsyncWithHttpInfo
     *
     * DocumentSetVariableValues
     *
     * @param  string $item_id The document&#39;s ID (required)
     * @param  \Swagger\Client\Model\DocumentSetVariableValuesBodyWrapper $body  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDocumentSetVariableValuesAsyncWithHttpInfo($item_id, $body)
    {
        $returnType = 'object';
        $request = $this->restApiDocumentSetVariableValuesRequest($item_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiDocumentSetVariableValues'
     *
     * @param  string $item_id The document&#39;s ID (required)
     * @param  \Swagger\Client\Model\DocumentSetVariableValuesBodyWrapper $body  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiDocumentSetVariableValuesRequest($item_id, $body)
    {
        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling restApiDocumentSetVariableValues'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling restApiDocumentSetVariableValues'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/documents/{itemID}/variablevalues';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemID' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiDownloadAssets
     *
     * DownloadAssets
     *
     * @param  string $resource_type  (required)
     * @param  string $id  (optional)
     * @param  string $path  (optional)
     * @param  string $name  (optional)
     * @param  string $type  (optional)
     * @param  int $page  (optional)
     * @param  string $client_app  (optional)
     * @param  string $color_type  (optional)
     * @param  bool $no_content_header  (optional)
     * @param  string $task_id  (optional)
     * @param  string $doc_id  (optional)
     * @param  int $scale  (optional)
     * @param  string $ipad_item_path  (optional)
     * @param  string $transformation_id  (optional)
     * @param  string $transformation_name  (optional)
     * @param  bool $async  (optional)
     * @param  int $task_priority  (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiDownloadAssets($resource_type, $id = null, $path = null, $name = null, $type = null, $page = null, $client_app = null, $color_type = null, $no_content_header = null, $task_id = null, $doc_id = null, $scale = null, $ipad_item_path = null, $transformation_id = null, $transformation_name = null, $async = null, $task_priority = null)
    {
        list($response) = $this->restApiDownloadAssetsWithHttpInfo($resource_type, $id, $path, $name, $type, $page, $client_app, $color_type, $no_content_header, $task_id, $doc_id, $scale, $ipad_item_path, $transformation_id, $transformation_name, $async, $task_priority);
        return $response;
    }

    /**
     * Operation restApiDownloadAssetsWithHttpInfo
     *
     * DownloadAssets
     *
     * @param  string $resource_type  (required)
     * @param  string $id  (optional)
     * @param  string $path  (optional)
     * @param  string $name  (optional)
     * @param  string $type  (optional)
     * @param  int $page  (optional)
     * @param  string $client_app  (optional)
     * @param  string $color_type  (optional)
     * @param  bool $no_content_header  (optional)
     * @param  string $task_id  (optional)
     * @param  string $doc_id  (optional)
     * @param  int $scale  (optional)
     * @param  string $ipad_item_path  (optional)
     * @param  string $transformation_id  (optional)
     * @param  string $transformation_name  (optional)
     * @param  bool $async  (optional)
     * @param  int $task_priority  (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiDownloadAssetsWithHttpInfo($resource_type, $id = null, $path = null, $name = null, $type = null, $page = null, $client_app = null, $color_type = null, $no_content_header = null, $task_id = null, $doc_id = null, $scale = null, $ipad_item_path = null, $transformation_id = null, $transformation_name = null, $async = null, $task_priority = null)
    {
        $returnType = 'object';
        $request = $this->restApiDownloadAssetsRequest($resource_type, $id, $path, $name, $type, $page, $client_app, $color_type, $no_content_header, $task_id, $doc_id, $scale, $ipad_item_path, $transformation_id, $transformation_name, $async, $task_priority);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiDownloadAssetsAsync
     *
     * DownloadAssets
     *
     * @param  string $resource_type  (required)
     * @param  string $id  (optional)
     * @param  string $path  (optional)
     * @param  string $name  (optional)
     * @param  string $type  (optional)
     * @param  int $page  (optional)
     * @param  string $client_app  (optional)
     * @param  string $color_type  (optional)
     * @param  bool $no_content_header  (optional)
     * @param  string $task_id  (optional)
     * @param  string $doc_id  (optional)
     * @param  int $scale  (optional)
     * @param  string $ipad_item_path  (optional)
     * @param  string $transformation_id  (optional)
     * @param  string $transformation_name  (optional)
     * @param  bool $async  (optional)
     * @param  int $task_priority  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDownloadAssetsAsync($resource_type, $id = null, $path = null, $name = null, $type = null, $page = null, $client_app = null, $color_type = null, $no_content_header = null, $task_id = null, $doc_id = null, $scale = null, $ipad_item_path = null, $transformation_id = null, $transformation_name = null, $async = null, $task_priority = null)
    {
        return $this->restApiDownloadAssetsAsyncWithHttpInfo($resource_type, $id, $path, $name, $type, $page, $client_app, $color_type, $no_content_header, $task_id, $doc_id, $scale, $ipad_item_path, $transformation_id, $transformation_name, $async, $task_priority)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiDownloadAssetsAsyncWithHttpInfo
     *
     * DownloadAssets
     *
     * @param  string $resource_type  (required)
     * @param  string $id  (optional)
     * @param  string $path  (optional)
     * @param  string $name  (optional)
     * @param  string $type  (optional)
     * @param  int $page  (optional)
     * @param  string $client_app  (optional)
     * @param  string $color_type  (optional)
     * @param  bool $no_content_header  (optional)
     * @param  string $task_id  (optional)
     * @param  string $doc_id  (optional)
     * @param  int $scale  (optional)
     * @param  string $ipad_item_path  (optional)
     * @param  string $transformation_id  (optional)
     * @param  string $transformation_name  (optional)
     * @param  bool $async  (optional)
     * @param  int $task_priority  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDownloadAssetsAsyncWithHttpInfo($resource_type, $id = null, $path = null, $name = null, $type = null, $page = null, $client_app = null, $color_type = null, $no_content_header = null, $task_id = null, $doc_id = null, $scale = null, $ipad_item_path = null, $transformation_id = null, $transformation_name = null, $async = null, $task_priority = null)
    {
        $returnType = 'object';
        $request = $this->restApiDownloadAssetsRequest($resource_type, $id, $path, $name, $type, $page, $client_app, $color_type, $no_content_header, $task_id, $doc_id, $scale, $ipad_item_path, $transformation_id, $transformation_name, $async, $task_priority);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiDownloadAssets'
     *
     * @param  string $resource_type  (required)
     * @param  string $id  (optional)
     * @param  string $path  (optional)
     * @param  string $name  (optional)
     * @param  string $type  (optional)
     * @param  int $page  (optional)
     * @param  string $client_app  (optional)
     * @param  string $color_type  (optional)
     * @param  bool $no_content_header  (optional)
     * @param  string $task_id  (optional)
     * @param  string $doc_id  (optional)
     * @param  int $scale  (optional)
     * @param  string $ipad_item_path  (optional)
     * @param  string $transformation_id  (optional)
     * @param  string $transformation_name  (optional)
     * @param  bool $async  (optional)
     * @param  int $task_priority  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiDownloadAssetsRequest($resource_type, $id = null, $path = null, $name = null, $type = null, $page = null, $client_app = null, $color_type = null, $no_content_header = null, $task_id = null, $doc_id = null, $scale = null, $ipad_item_path = null, $transformation_id = null, $transformation_name = null, $async = null, $task_priority = null)
    {
        // verify the required parameter 'resource_type' is set
        if ($resource_type === null || (is_array($resource_type) && count($resource_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource_type when calling restApiDownloadAssets'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/{resourceType}/download';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($id !== null) {
            $queryParams['id'] = ObjectSerializer::toQueryValue($id);
        }
        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($client_app !== null) {
            $queryParams['client_app'] = ObjectSerializer::toQueryValue($client_app);
        }
        // query params
        if ($color_type !== null) {
            $queryParams['colorType'] = ObjectSerializer::toQueryValue($color_type);
        }
        // query params
        if ($no_content_header !== null) {
            $queryParams['noContentHeader'] = ObjectSerializer::toQueryValue($no_content_header);
        }
        // query params
        if ($task_id !== null) {
            $queryParams['taskId'] = ObjectSerializer::toQueryValue($task_id);
        }
        // query params
        if ($doc_id !== null) {
            $queryParams['docId'] = ObjectSerializer::toQueryValue($doc_id);
        }
        // query params
        if ($scale !== null) {
            $queryParams['scale'] = ObjectSerializer::toQueryValue($scale);
        }
        // query params
        if ($ipad_item_path !== null) {
            $queryParams['ipadItemPath'] = ObjectSerializer::toQueryValue($ipad_item_path);
        }
        // query params
        if ($transformation_id !== null) {
            $queryParams['transformationID'] = ObjectSerializer::toQueryValue($transformation_id);
        }
        // query params
        if ($transformation_name !== null) {
            $queryParams['transformationName'] = ObjectSerializer::toQueryValue($transformation_name);
        }
        // query params
        if ($async !== null) {
            $queryParams['async'] = ObjectSerializer::toQueryValue($async);
        }
        // query params
        if ($task_priority !== null) {
            $queryParams['taskPriority'] = ObjectSerializer::toQueryValue($task_priority);
        }

        // path params
        if ($resource_type !== null) {
            $resourcePath = str_replace(
                '{' . 'resourceType' . '}',
                ObjectSerializer::toPathValue($resource_type),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiDownloadDatasourceSample
     *
     * DownloadDatasourceSample
     *
     * @param  string $name  (optional)
     * @param  string $id  (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiDownloadDatasourceSample($name = null, $id = null)
    {
        list($response) = $this->restApiDownloadDatasourceSampleWithHttpInfo($name, $id);
        return $response;
    }

    /**
     * Operation restApiDownloadDatasourceSampleWithHttpInfo
     *
     * DownloadDatasourceSample
     *
     * @param  string $name  (optional)
     * @param  string $id  (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiDownloadDatasourceSampleWithHttpInfo($name = null, $id = null)
    {
        $returnType = 'object';
        $request = $this->restApiDownloadDatasourceSampleRequest($name, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiDownloadDatasourceSampleAsync
     *
     * DownloadDatasourceSample
     *
     * @param  string $name  (optional)
     * @param  string $id  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDownloadDatasourceSampleAsync($name = null, $id = null)
    {
        return $this->restApiDownloadDatasourceSampleAsyncWithHttpInfo($name, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiDownloadDatasourceSampleAsyncWithHttpInfo
     *
     * DownloadDatasourceSample
     *
     * @param  string $name  (optional)
     * @param  string $id  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDownloadDatasourceSampleAsyncWithHttpInfo($name = null, $id = null)
    {
        $returnType = 'object';
        $request = $this->restApiDownloadDatasourceSampleRequest($name, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiDownloadDatasourceSample'
     *
     * @param  string $name  (optional)
     * @param  string $id  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiDownloadDatasourceSampleRequest($name = null, $id = null)
    {

        $resourcePath = '/rest-api/v1.2/resources/DatasourceSample/download';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($id !== null) {
            $queryParams['id'] = ObjectSerializer::toQueryValue($id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiDownloadExternal
     *
     * DownloadExternal
     *
     * @param  string $path  (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiDownloadExternal($path = null)
    {
        list($response) = $this->restApiDownloadExternalWithHttpInfo($path);
        return $response;
    }

    /**
     * Operation restApiDownloadExternalWithHttpInfo
     *
     * DownloadExternal
     *
     * @param  string $path  (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiDownloadExternalWithHttpInfo($path = null)
    {
        $returnType = 'object';
        $request = $this->restApiDownloadExternalRequest($path);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiDownloadExternalAsync
     *
     * DownloadExternal
     *
     * @param  string $path  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDownloadExternalAsync($path = null)
    {
        return $this->restApiDownloadExternalAsyncWithHttpInfo($path)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiDownloadExternalAsyncWithHttpInfo
     *
     * DownloadExternal
     *
     * @param  string $path  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDownloadExternalAsyncWithHttpInfo($path = null)
    {
        $returnType = 'object';
        $request = $this->restApiDownloadExternalRequest($path);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiDownloadExternal'
     *
     * @param  string $path  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiDownloadExternalRequest($path = null)
    {

        $resourcePath = '/rest-api/v1.2/resources/External/download';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiDownloadFolding
     *
     * DownloadFolding
     *
     * @param  string $id  (optional)
     * @param  string $type  (optional)
     * @param  string $folding_id  (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiDownloadFolding($id = null, $type = null, $folding_id = null)
    {
        list($response) = $this->restApiDownloadFoldingWithHttpInfo($id, $type, $folding_id);
        return $response;
    }

    /**
     * Operation restApiDownloadFoldingWithHttpInfo
     *
     * DownloadFolding
     *
     * @param  string $id  (optional)
     * @param  string $type  (optional)
     * @param  string $folding_id  (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiDownloadFoldingWithHttpInfo($id = null, $type = null, $folding_id = null)
    {
        $returnType = 'object';
        $request = $this->restApiDownloadFoldingRequest($id, $type, $folding_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiDownloadFoldingAsync
     *
     * DownloadFolding
     *
     * @param  string $id  (optional)
     * @param  string $type  (optional)
     * @param  string $folding_id  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDownloadFoldingAsync($id = null, $type = null, $folding_id = null)
    {
        return $this->restApiDownloadFoldingAsyncWithHttpInfo($id, $type, $folding_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiDownloadFoldingAsyncWithHttpInfo
     *
     * DownloadFolding
     *
     * @param  string $id  (optional)
     * @param  string $type  (optional)
     * @param  string $folding_id  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDownloadFoldingAsyncWithHttpInfo($id = null, $type = null, $folding_id = null)
    {
        $returnType = 'object';
        $request = $this->restApiDownloadFoldingRequest($id, $type, $folding_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiDownloadFolding'
     *
     * @param  string $id  (optional)
     * @param  string $type  (optional)
     * @param  string $folding_id  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiDownloadFoldingRequest($id = null, $type = null, $folding_id = null)
    {

        $resourcePath = '/rest-api/v1.2/resources/Folding/download';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($id !== null) {
            $queryParams['id'] = ObjectSerializer::toQueryValue($id);
        }
        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }
        // query params
        if ($folding_id !== null) {
            $queryParams['foldingId'] = ObjectSerializer::toQueryValue($folding_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiDownloadFontPreview
     *
     * DownloadFontPreview
     *
     * @param  string $type  (required)
     * @param  int $width  (required)
     * @param  int $height  (required)
     * @param  string $alphabet  (optional)
     * @param  string $id  (optional)
     * @param  string $name  (optional)
     * @param  string $task_id  (optional)
     * @param  int $task_priority  (optional)
     * @param  bool $async  (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiDownloadFontPreview($type, $width, $height, $alphabet = null, $id = null, $name = null, $task_id = null, $task_priority = null, $async = null)
    {
        list($response) = $this->restApiDownloadFontPreviewWithHttpInfo($type, $width, $height, $alphabet, $id, $name, $task_id, $task_priority, $async);
        return $response;
    }

    /**
     * Operation restApiDownloadFontPreviewWithHttpInfo
     *
     * DownloadFontPreview
     *
     * @param  string $type  (required)
     * @param  int $width  (required)
     * @param  int $height  (required)
     * @param  string $alphabet  (optional)
     * @param  string $id  (optional)
     * @param  string $name  (optional)
     * @param  string $task_id  (optional)
     * @param  int $task_priority  (optional)
     * @param  bool $async  (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiDownloadFontPreviewWithHttpInfo($type, $width, $height, $alphabet = null, $id = null, $name = null, $task_id = null, $task_priority = null, $async = null)
    {
        $returnType = 'object';
        $request = $this->restApiDownloadFontPreviewRequest($type, $width, $height, $alphabet, $id, $name, $task_id, $task_priority, $async);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiDownloadFontPreviewAsync
     *
     * DownloadFontPreview
     *
     * @param  string $type  (required)
     * @param  int $width  (required)
     * @param  int $height  (required)
     * @param  string $alphabet  (optional)
     * @param  string $id  (optional)
     * @param  string $name  (optional)
     * @param  string $task_id  (optional)
     * @param  int $task_priority  (optional)
     * @param  bool $async  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDownloadFontPreviewAsync($type, $width, $height, $alphabet = null, $id = null, $name = null, $task_id = null, $task_priority = null, $async = null)
    {
        return $this->restApiDownloadFontPreviewAsyncWithHttpInfo($type, $width, $height, $alphabet, $id, $name, $task_id, $task_priority, $async)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiDownloadFontPreviewAsyncWithHttpInfo
     *
     * DownloadFontPreview
     *
     * @param  string $type  (required)
     * @param  int $width  (required)
     * @param  int $height  (required)
     * @param  string $alphabet  (optional)
     * @param  string $id  (optional)
     * @param  string $name  (optional)
     * @param  string $task_id  (optional)
     * @param  int $task_priority  (optional)
     * @param  bool $async  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDownloadFontPreviewAsyncWithHttpInfo($type, $width, $height, $alphabet = null, $id = null, $name = null, $task_id = null, $task_priority = null, $async = null)
    {
        $returnType = 'object';
        $request = $this->restApiDownloadFontPreviewRequest($type, $width, $height, $alphabet, $id, $name, $task_id, $task_priority, $async);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiDownloadFontPreview'
     *
     * @param  string $type  (required)
     * @param  int $width  (required)
     * @param  int $height  (required)
     * @param  string $alphabet  (optional)
     * @param  string $id  (optional)
     * @param  string $name  (optional)
     * @param  string $task_id  (optional)
     * @param  int $task_priority  (optional)
     * @param  bool $async  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiDownloadFontPreviewRequest($type, $width, $height, $alphabet = null, $id = null, $name = null, $task_id = null, $task_priority = null, $async = null)
    {
        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling restApiDownloadFontPreview'
            );
        }
        // verify the required parameter 'width' is set
        if ($width === null || (is_array($width) && count($width) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $width when calling restApiDownloadFontPreview'
            );
        }
        // verify the required parameter 'height' is set
        if ($height === null || (is_array($height) && count($height) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $height when calling restApiDownloadFontPreview'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/Fonts/download';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }
        // query params
        if ($alphabet !== null) {
            $queryParams['alphabet'] = ObjectSerializer::toQueryValue($alphabet);
        }
        // query params
        if ($id !== null) {
            $queryParams['id'] = ObjectSerializer::toQueryValue($id);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($task_id !== null) {
            $queryParams['taskId'] = ObjectSerializer::toQueryValue($task_id);
        }
        // query params
        if ($task_priority !== null) {
            $queryParams['taskPriority'] = ObjectSerializer::toQueryValue($task_priority);
        }
        // query params
        if ($async !== null) {
            $queryParams['async'] = ObjectSerializer::toQueryValue($async);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiDownloadIcons
     *
     * DownloadIcons
     *
     * @param  string $environment  (optional)
     * @param  string $set  (optional)
     * @param  string $icon  (optional)
     * @param  bool $prefer_svg  (optional)
     * @param  bool $is_cursor  (optional)
     * @param  string $temp_path  (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiDownloadIcons($environment = null, $set = null, $icon = null, $prefer_svg = null, $is_cursor = null, $temp_path = null)
    {
        list($response) = $this->restApiDownloadIconsWithHttpInfo($environment, $set, $icon, $prefer_svg, $is_cursor, $temp_path);
        return $response;
    }

    /**
     * Operation restApiDownloadIconsWithHttpInfo
     *
     * DownloadIcons
     *
     * @param  string $environment  (optional)
     * @param  string $set  (optional)
     * @param  string $icon  (optional)
     * @param  bool $prefer_svg  (optional)
     * @param  bool $is_cursor  (optional)
     * @param  string $temp_path  (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiDownloadIconsWithHttpInfo($environment = null, $set = null, $icon = null, $prefer_svg = null, $is_cursor = null, $temp_path = null)
    {
        $returnType = 'object';
        $request = $this->restApiDownloadIconsRequest($environment, $set, $icon, $prefer_svg, $is_cursor, $temp_path);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiDownloadIconsAsync
     *
     * DownloadIcons
     *
     * @param  string $environment  (optional)
     * @param  string $set  (optional)
     * @param  string $icon  (optional)
     * @param  bool $prefer_svg  (optional)
     * @param  bool $is_cursor  (optional)
     * @param  string $temp_path  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDownloadIconsAsync($environment = null, $set = null, $icon = null, $prefer_svg = null, $is_cursor = null, $temp_path = null)
    {
        return $this->restApiDownloadIconsAsyncWithHttpInfo($environment, $set, $icon, $prefer_svg, $is_cursor, $temp_path)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiDownloadIconsAsyncWithHttpInfo
     *
     * DownloadIcons
     *
     * @param  string $environment  (optional)
     * @param  string $set  (optional)
     * @param  string $icon  (optional)
     * @param  bool $prefer_svg  (optional)
     * @param  bool $is_cursor  (optional)
     * @param  string $temp_path  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDownloadIconsAsyncWithHttpInfo($environment = null, $set = null, $icon = null, $prefer_svg = null, $is_cursor = null, $temp_path = null)
    {
        $returnType = 'object';
        $request = $this->restApiDownloadIconsRequest($environment, $set, $icon, $prefer_svg, $is_cursor, $temp_path);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiDownloadIcons'
     *
     * @param  string $environment  (optional)
     * @param  string $set  (optional)
     * @param  string $icon  (optional)
     * @param  bool $prefer_svg  (optional)
     * @param  bool $is_cursor  (optional)
     * @param  string $temp_path  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiDownloadIconsRequest($environment = null, $set = null, $icon = null, $prefer_svg = null, $is_cursor = null, $temp_path = null)
    {

        $resourcePath = '/rest-api/v1.2/resources/Icons/download';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($environment !== null) {
            $queryParams['environment'] = ObjectSerializer::toQueryValue($environment);
        }
        // query params
        if ($set !== null) {
            $queryParams['set'] = ObjectSerializer::toQueryValue($set);
        }
        // query params
        if ($icon !== null) {
            $queryParams['icon'] = ObjectSerializer::toQueryValue($icon);
        }
        // query params
        if ($prefer_svg !== null) {
            $queryParams['preferSvg'] = ObjectSerializer::toQueryValue($prefer_svg);
        }
        // query params
        if ($is_cursor !== null) {
            $queryParams['isCursor'] = ObjectSerializer::toQueryValue($is_cursor);
        }
        // query params
        if ($temp_path !== null) {
            $queryParams['tempPath'] = ObjectSerializer::toQueryValue($temp_path);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiDownloadLoginBackground
     *
     * DownloadLoginBackground
     *
     * @param  string $env  (optional)
     * @param  string $type  (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiDownloadLoginBackground($env = null, $type = null)
    {
        list($response) = $this->restApiDownloadLoginBackgroundWithHttpInfo($env, $type);
        return $response;
    }

    /**
     * Operation restApiDownloadLoginBackgroundWithHttpInfo
     *
     * DownloadLoginBackground
     *
     * @param  string $env  (optional)
     * @param  string $type  (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiDownloadLoginBackgroundWithHttpInfo($env = null, $type = null)
    {
        $returnType = 'object';
        $request = $this->restApiDownloadLoginBackgroundRequest($env, $type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiDownloadLoginBackgroundAsync
     *
     * DownloadLoginBackground
     *
     * @param  string $env  (optional)
     * @param  string $type  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDownloadLoginBackgroundAsync($env = null, $type = null)
    {
        return $this->restApiDownloadLoginBackgroundAsyncWithHttpInfo($env, $type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiDownloadLoginBackgroundAsyncWithHttpInfo
     *
     * DownloadLoginBackground
     *
     * @param  string $env  (optional)
     * @param  string $type  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDownloadLoginBackgroundAsyncWithHttpInfo($env = null, $type = null)
    {
        $returnType = 'object';
        $request = $this->restApiDownloadLoginBackgroundRequest($env, $type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiDownloadLoginBackground'
     *
     * @param  string $env  (optional)
     * @param  string $type  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiDownloadLoginBackgroundRequest($env = null, $type = null)
    {

        $resourcePath = '/rest-api/v1.2/resources/Login/download';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($env !== null) {
            $queryParams['env'] = ObjectSerializer::toQueryValue($env);
        }
        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiDownloadReflectionMap
     *
     * DownloadReflectionMap
     *
     * @param  string $name  (optional)
     * @param  string $side  (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiDownloadReflectionMap($name = null, $side = null)
    {
        list($response) = $this->restApiDownloadReflectionMapWithHttpInfo($name, $side);
        return $response;
    }

    /**
     * Operation restApiDownloadReflectionMapWithHttpInfo
     *
     * DownloadReflectionMap
     *
     * @param  string $name  (optional)
     * @param  string $side  (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiDownloadReflectionMapWithHttpInfo($name = null, $side = null)
    {
        $returnType = 'object';
        $request = $this->restApiDownloadReflectionMapRequest($name, $side);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiDownloadReflectionMapAsync
     *
     * DownloadReflectionMap
     *
     * @param  string $name  (optional)
     * @param  string $side  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDownloadReflectionMapAsync($name = null, $side = null)
    {
        return $this->restApiDownloadReflectionMapAsyncWithHttpInfo($name, $side)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiDownloadReflectionMapAsyncWithHttpInfo
     *
     * DownloadReflectionMap
     *
     * @param  string $name  (optional)
     * @param  string $side  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDownloadReflectionMapAsyncWithHttpInfo($name = null, $side = null)
    {
        $returnType = 'object';
        $request = $this->restApiDownloadReflectionMapRequest($name, $side);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiDownloadReflectionMap'
     *
     * @param  string $name  (optional)
     * @param  string $side  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiDownloadReflectionMapRequest($name = null, $side = null)
    {

        $resourcePath = '/rest-api/v1.2/resources/ReflectionMap/download';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($side !== null) {
            $queryParams['side'] = ObjectSerializer::toQueryValue($side);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiDownloadTempFile
     *
     * DownloadTempFile
     *
     * @param  string $asset_type  (required)
     * @param  string $path  (optional)
     * @param  string $data  (optional)
     * @param  string $dynamic_asset_provider_id  (optional)
     * @param  bool $no_content_header  (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiDownloadTempFile($asset_type, $path = null, $data = null, $dynamic_asset_provider_id = null, $no_content_header = null)
    {
        list($response) = $this->restApiDownloadTempFileWithHttpInfo($asset_type, $path, $data, $dynamic_asset_provider_id, $no_content_header);
        return $response;
    }

    /**
     * Operation restApiDownloadTempFileWithHttpInfo
     *
     * DownloadTempFile
     *
     * @param  string $asset_type  (required)
     * @param  string $path  (optional)
     * @param  string $data  (optional)
     * @param  string $dynamic_asset_provider_id  (optional)
     * @param  bool $no_content_header  (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiDownloadTempFileWithHttpInfo($asset_type, $path = null, $data = null, $dynamic_asset_provider_id = null, $no_content_header = null)
    {
        $returnType = 'object';
        $request = $this->restApiDownloadTempFileRequest($asset_type, $path, $data, $dynamic_asset_provider_id, $no_content_header);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiDownloadTempFileAsync
     *
     * DownloadTempFile
     *
     * @param  string $asset_type  (required)
     * @param  string $path  (optional)
     * @param  string $data  (optional)
     * @param  string $dynamic_asset_provider_id  (optional)
     * @param  bool $no_content_header  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDownloadTempFileAsync($asset_type, $path = null, $data = null, $dynamic_asset_provider_id = null, $no_content_header = null)
    {
        return $this->restApiDownloadTempFileAsyncWithHttpInfo($asset_type, $path, $data, $dynamic_asset_provider_id, $no_content_header)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiDownloadTempFileAsyncWithHttpInfo
     *
     * DownloadTempFile
     *
     * @param  string $asset_type  (required)
     * @param  string $path  (optional)
     * @param  string $data  (optional)
     * @param  string $dynamic_asset_provider_id  (optional)
     * @param  bool $no_content_header  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiDownloadTempFileAsyncWithHttpInfo($asset_type, $path = null, $data = null, $dynamic_asset_provider_id = null, $no_content_header = null)
    {
        $returnType = 'object';
        $request = $this->restApiDownloadTempFileRequest($asset_type, $path, $data, $dynamic_asset_provider_id, $no_content_header);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiDownloadTempFile'
     *
     * @param  string $asset_type  (required)
     * @param  string $path  (optional)
     * @param  string $data  (optional)
     * @param  string $dynamic_asset_provider_id  (optional)
     * @param  bool $no_content_header  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiDownloadTempFileRequest($asset_type, $path = null, $data = null, $dynamic_asset_provider_id = null, $no_content_header = null)
    {
        // verify the required parameter 'asset_type' is set
        if ($asset_type === null || (is_array($asset_type) && count($asset_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $asset_type when calling restApiDownloadTempFile'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/{assetType}/download/tempfile';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }
        // query params
        if ($data !== null) {
            $queryParams['data'] = ObjectSerializer::toQueryValue($data);
        }
        // query params
        if ($dynamic_asset_provider_id !== null) {
            $queryParams['dynamicAssetProviderID'] = ObjectSerializer::toQueryValue($dynamic_asset_provider_id);
        }
        // query params
        if ($no_content_header !== null) {
            $queryParams['noContentHeader'] = ObjectSerializer::toQueryValue($no_content_header);
        }

        // path params
        if ($asset_type !== null) {
            $resourcePath = str_replace(
                '{' . 'assetType' . '}',
                ObjectSerializer::toPathValue($asset_type),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiFontGetIncludedGlyphs
     *
     * FontGetIncludedGlyphs
     *
     * @param  string $font_id The ID of the font (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiFontGetIncludedGlyphs($font_id)
    {
        list($response) = $this->restApiFontGetIncludedGlyphsWithHttpInfo($font_id);
        return $response;
    }

    /**
     * Operation restApiFontGetIncludedGlyphsWithHttpInfo
     *
     * FontGetIncludedGlyphs
     *
     * @param  string $font_id The ID of the font (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiFontGetIncludedGlyphsWithHttpInfo($font_id)
    {
        $returnType = 'object';
        $request = $this->restApiFontGetIncludedGlyphsRequest($font_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiFontGetIncludedGlyphsAsync
     *
     * FontGetIncludedGlyphs
     *
     * @param  string $font_id The ID of the font (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiFontGetIncludedGlyphsAsync($font_id)
    {
        return $this->restApiFontGetIncludedGlyphsAsyncWithHttpInfo($font_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiFontGetIncludedGlyphsAsyncWithHttpInfo
     *
     * FontGetIncludedGlyphs
     *
     * @param  string $font_id The ID of the font (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiFontGetIncludedGlyphsAsyncWithHttpInfo($font_id)
    {
        $returnType = 'object';
        $request = $this->restApiFontGetIncludedGlyphsRequest($font_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiFontGetIncludedGlyphs'
     *
     * @param  string $font_id The ID of the font (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiFontGetIncludedGlyphsRequest($font_id)
    {
        // verify the required parameter 'font_id' is set
        if ($font_id === null || (is_array($font_id) && count($font_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $font_id when calling restApiFontGetIncludedGlyphs'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/fonts/{fontID}/includedglyphs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($font_id !== null) {
            $resourcePath = str_replace(
                '{' . 'fontID' . '}',
                ObjectSerializer::toPathValue($font_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiResourceFolderAdd
     *
     * ResourceFolderAdd
     *
     * @param  string $resource_name The name of the resource in which to add a folder (required)
     * @param  string $new_name The name for the new folder (required)
     * @param  string $parent_path The location of the folder (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiResourceFolderAdd($resource_name, $new_name, $parent_path = null)
    {
        list($response) = $this->restApiResourceFolderAddWithHttpInfo($resource_name, $new_name, $parent_path);
        return $response;
    }

    /**
     * Operation restApiResourceFolderAddWithHttpInfo
     *
     * ResourceFolderAdd
     *
     * @param  string $resource_name The name of the resource in which to add a folder (required)
     * @param  string $new_name The name for the new folder (required)
     * @param  string $parent_path The location of the folder (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiResourceFolderAddWithHttpInfo($resource_name, $new_name, $parent_path = null)
    {
        $returnType = 'object';
        $request = $this->restApiResourceFolderAddRequest($resource_name, $new_name, $parent_path);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiResourceFolderAddAsync
     *
     * ResourceFolderAdd
     *
     * @param  string $resource_name The name of the resource in which to add a folder (required)
     * @param  string $new_name The name for the new folder (required)
     * @param  string $parent_path The location of the folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceFolderAddAsync($resource_name, $new_name, $parent_path = null)
    {
        return $this->restApiResourceFolderAddAsyncWithHttpInfo($resource_name, $new_name, $parent_path)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiResourceFolderAddAsyncWithHttpInfo
     *
     * ResourceFolderAdd
     *
     * @param  string $resource_name The name of the resource in which to add a folder (required)
     * @param  string $new_name The name for the new folder (required)
     * @param  string $parent_path The location of the folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceFolderAddAsyncWithHttpInfo($resource_name, $new_name, $parent_path = null)
    {
        $returnType = 'object';
        $request = $this->restApiResourceFolderAddRequest($resource_name, $new_name, $parent_path);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiResourceFolderAdd'
     *
     * @param  string $resource_name The name of the resource in which to add a folder (required)
     * @param  string $new_name The name for the new folder (required)
     * @param  string $parent_path The location of the folder (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiResourceFolderAddRequest($resource_name, $new_name, $parent_path = null)
    {
        // verify the required parameter 'resource_name' is set
        if ($resource_name === null || (is_array($resource_name) && count($resource_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource_name when calling restApiResourceFolderAdd'
            );
        }
        // verify the required parameter 'new_name' is set
        if ($new_name === null || (is_array($new_name) && count($new_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $new_name when calling restApiResourceFolderAdd'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/{resourceName}/folders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($new_name !== null) {
            $queryParams['newName'] = ObjectSerializer::toQueryValue($new_name);
        }
        // query params
        if ($parent_path !== null) {
            $queryParams['parentPath'] = ObjectSerializer::toQueryValue($parent_path);
        }

        // path params
        if ($resource_name !== null) {
            $resourcePath = str_replace(
                '{' . 'resourceName' . '}',
                ObjectSerializer::toPathValue($resource_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiResourceFolderCopy
     *
     * ResourceFolderCopy
     *
     * @param  string $resource_name Name of the Resource in which to find the folder (required)
     * @param  string $folder_path The folder to move (required)
     * @param  string $new_folder_path The new folder location (required)
     * @param  bool $include_sub_folders  (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiResourceFolderCopy($resource_name, $folder_path, $new_folder_path, $include_sub_folders)
    {
        list($response) = $this->restApiResourceFolderCopyWithHttpInfo($resource_name, $folder_path, $new_folder_path, $include_sub_folders);
        return $response;
    }

    /**
     * Operation restApiResourceFolderCopyWithHttpInfo
     *
     * ResourceFolderCopy
     *
     * @param  string $resource_name Name of the Resource in which to find the folder (required)
     * @param  string $folder_path The folder to move (required)
     * @param  string $new_folder_path The new folder location (required)
     * @param  bool $include_sub_folders  (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiResourceFolderCopyWithHttpInfo($resource_name, $folder_path, $new_folder_path, $include_sub_folders)
    {
        $returnType = 'object';
        $request = $this->restApiResourceFolderCopyRequest($resource_name, $folder_path, $new_folder_path, $include_sub_folders);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiResourceFolderCopyAsync
     *
     * ResourceFolderCopy
     *
     * @param  string $resource_name Name of the Resource in which to find the folder (required)
     * @param  string $folder_path The folder to move (required)
     * @param  string $new_folder_path The new folder location (required)
     * @param  bool $include_sub_folders  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceFolderCopyAsync($resource_name, $folder_path, $new_folder_path, $include_sub_folders)
    {
        return $this->restApiResourceFolderCopyAsyncWithHttpInfo($resource_name, $folder_path, $new_folder_path, $include_sub_folders)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiResourceFolderCopyAsyncWithHttpInfo
     *
     * ResourceFolderCopy
     *
     * @param  string $resource_name Name of the Resource in which to find the folder (required)
     * @param  string $folder_path The folder to move (required)
     * @param  string $new_folder_path The new folder location (required)
     * @param  bool $include_sub_folders  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceFolderCopyAsyncWithHttpInfo($resource_name, $folder_path, $new_folder_path, $include_sub_folders)
    {
        $returnType = 'object';
        $request = $this->restApiResourceFolderCopyRequest($resource_name, $folder_path, $new_folder_path, $include_sub_folders);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiResourceFolderCopy'
     *
     * @param  string $resource_name Name of the Resource in which to find the folder (required)
     * @param  string $folder_path The folder to move (required)
     * @param  string $new_folder_path The new folder location (required)
     * @param  bool $include_sub_folders  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiResourceFolderCopyRequest($resource_name, $folder_path, $new_folder_path, $include_sub_folders)
    {
        // verify the required parameter 'resource_name' is set
        if ($resource_name === null || (is_array($resource_name) && count($resource_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource_name when calling restApiResourceFolderCopy'
            );
        }
        // verify the required parameter 'folder_path' is set
        if ($folder_path === null || (is_array($folder_path) && count($folder_path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $folder_path when calling restApiResourceFolderCopy'
            );
        }
        // verify the required parameter 'new_folder_path' is set
        if ($new_folder_path === null || (is_array($new_folder_path) && count($new_folder_path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $new_folder_path when calling restApiResourceFolderCopy'
            );
        }
        // verify the required parameter 'include_sub_folders' is set
        if ($include_sub_folders === null || (is_array($include_sub_folders) && count($include_sub_folders) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $include_sub_folders when calling restApiResourceFolderCopy'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/{resourceName}/folders/copy';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($folder_path !== null) {
            $queryParams['folderPath'] = ObjectSerializer::toQueryValue($folder_path);
        }
        // query params
        if ($new_folder_path !== null) {
            $queryParams['newFolderPath'] = ObjectSerializer::toQueryValue($new_folder_path);
        }
        // query params
        if ($include_sub_folders !== null) {
            $queryParams['includeSubFolders'] = ObjectSerializer::toQueryValue($include_sub_folders);
        }

        // path params
        if ($resource_name !== null) {
            $resourcePath = str_replace(
                '{' . 'resourceName' . '}',
                ObjectSerializer::toPathValue($resource_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiResourceFolderDelete
     *
     * ResourceFolderDelete
     *
     * @param  string $resource_name The name of the resource in which to delete the folder (required)
     * @param  string $relative_path The relative path (in the resource&#39;s tree) of the folder to delete (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiResourceFolderDelete($resource_name, $relative_path)
    {
        list($response) = $this->restApiResourceFolderDeleteWithHttpInfo($resource_name, $relative_path);
        return $response;
    }

    /**
     * Operation restApiResourceFolderDeleteWithHttpInfo
     *
     * ResourceFolderDelete
     *
     * @param  string $resource_name The name of the resource in which to delete the folder (required)
     * @param  string $relative_path The relative path (in the resource&#39;s tree) of the folder to delete (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiResourceFolderDeleteWithHttpInfo($resource_name, $relative_path)
    {
        $returnType = 'object';
        $request = $this->restApiResourceFolderDeleteRequest($resource_name, $relative_path);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiResourceFolderDeleteAsync
     *
     * ResourceFolderDelete
     *
     * @param  string $resource_name The name of the resource in which to delete the folder (required)
     * @param  string $relative_path The relative path (in the resource&#39;s tree) of the folder to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceFolderDeleteAsync($resource_name, $relative_path)
    {
        return $this->restApiResourceFolderDeleteAsyncWithHttpInfo($resource_name, $relative_path)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiResourceFolderDeleteAsyncWithHttpInfo
     *
     * ResourceFolderDelete
     *
     * @param  string $resource_name The name of the resource in which to delete the folder (required)
     * @param  string $relative_path The relative path (in the resource&#39;s tree) of the folder to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceFolderDeleteAsyncWithHttpInfo($resource_name, $relative_path)
    {
        $returnType = 'object';
        $request = $this->restApiResourceFolderDeleteRequest($resource_name, $relative_path);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiResourceFolderDelete'
     *
     * @param  string $resource_name The name of the resource in which to delete the folder (required)
     * @param  string $relative_path The relative path (in the resource&#39;s tree) of the folder to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiResourceFolderDeleteRequest($resource_name, $relative_path)
    {
        // verify the required parameter 'resource_name' is set
        if ($resource_name === null || (is_array($resource_name) && count($resource_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource_name when calling restApiResourceFolderDelete'
            );
        }
        // verify the required parameter 'relative_path' is set
        if ($relative_path === null || (is_array($relative_path) && count($relative_path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $relative_path when calling restApiResourceFolderDelete'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/{resourceName}/folders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($relative_path !== null) {
            $queryParams['relativePath'] = ObjectSerializer::toQueryValue($relative_path);
        }

        // path params
        if ($resource_name !== null) {
            $resourcePath = str_replace(
                '{' . 'resourceName' . '}',
                ObjectSerializer::toPathValue($resource_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiResourceFolderMove
     *
     * ResourceFolderMove
     *
     * @param  string $resource_name Name of the Resource in which to find the folder (required)
     * @param  string $folder_path The folder to move (required)
     * @param  string $new_folder_path The new folder location (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiResourceFolderMove($resource_name, $folder_path, $new_folder_path)
    {
        list($response) = $this->restApiResourceFolderMoveWithHttpInfo($resource_name, $folder_path, $new_folder_path);
        return $response;
    }

    /**
     * Operation restApiResourceFolderMoveWithHttpInfo
     *
     * ResourceFolderMove
     *
     * @param  string $resource_name Name of the Resource in which to find the folder (required)
     * @param  string $folder_path The folder to move (required)
     * @param  string $new_folder_path The new folder location (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiResourceFolderMoveWithHttpInfo($resource_name, $folder_path, $new_folder_path)
    {
        $returnType = 'object';
        $request = $this->restApiResourceFolderMoveRequest($resource_name, $folder_path, $new_folder_path);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiResourceFolderMoveAsync
     *
     * ResourceFolderMove
     *
     * @param  string $resource_name Name of the Resource in which to find the folder (required)
     * @param  string $folder_path The folder to move (required)
     * @param  string $new_folder_path The new folder location (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceFolderMoveAsync($resource_name, $folder_path, $new_folder_path)
    {
        return $this->restApiResourceFolderMoveAsyncWithHttpInfo($resource_name, $folder_path, $new_folder_path)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiResourceFolderMoveAsyncWithHttpInfo
     *
     * ResourceFolderMove
     *
     * @param  string $resource_name Name of the Resource in which to find the folder (required)
     * @param  string $folder_path The folder to move (required)
     * @param  string $new_folder_path The new folder location (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceFolderMoveAsyncWithHttpInfo($resource_name, $folder_path, $new_folder_path)
    {
        $returnType = 'object';
        $request = $this->restApiResourceFolderMoveRequest($resource_name, $folder_path, $new_folder_path);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiResourceFolderMove'
     *
     * @param  string $resource_name Name of the Resource in which to find the folder (required)
     * @param  string $folder_path The folder to move (required)
     * @param  string $new_folder_path The new folder location (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiResourceFolderMoveRequest($resource_name, $folder_path, $new_folder_path)
    {
        // verify the required parameter 'resource_name' is set
        if ($resource_name === null || (is_array($resource_name) && count($resource_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource_name when calling restApiResourceFolderMove'
            );
        }
        // verify the required parameter 'folder_path' is set
        if ($folder_path === null || (is_array($folder_path) && count($folder_path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $folder_path when calling restApiResourceFolderMove'
            );
        }
        // verify the required parameter 'new_folder_path' is set
        if ($new_folder_path === null || (is_array($new_folder_path) && count($new_folder_path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $new_folder_path when calling restApiResourceFolderMove'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/{resourceName}/folders/move';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($folder_path !== null) {
            $queryParams['folderPath'] = ObjectSerializer::toQueryValue($folder_path);
        }
        // query params
        if ($new_folder_path !== null) {
            $queryParams['newFolderPath'] = ObjectSerializer::toQueryValue($new_folder_path);
        }

        // path params
        if ($resource_name !== null) {
            $resourcePath = str_replace(
                '{' . 'resourceName' . '}',
                ObjectSerializer::toPathValue($resource_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiResourceGetHistory
     *
     * ResourceGetHistory
     *
     * @param  string $resource_name The name of the resource (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiResourceGetHistory($resource_name)
    {
        list($response) = $this->restApiResourceGetHistoryWithHttpInfo($resource_name);
        return $response;
    }

    /**
     * Operation restApiResourceGetHistoryWithHttpInfo
     *
     * ResourceGetHistory
     *
     * @param  string $resource_name The name of the resource (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiResourceGetHistoryWithHttpInfo($resource_name)
    {
        $returnType = 'object';
        $request = $this->restApiResourceGetHistoryRequest($resource_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiResourceGetHistoryAsync
     *
     * ResourceGetHistory
     *
     * @param  string $resource_name The name of the resource (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceGetHistoryAsync($resource_name)
    {
        return $this->restApiResourceGetHistoryAsyncWithHttpInfo($resource_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiResourceGetHistoryAsyncWithHttpInfo
     *
     * ResourceGetHistory
     *
     * @param  string $resource_name The name of the resource (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceGetHistoryAsyncWithHttpInfo($resource_name)
    {
        $returnType = 'object';
        $request = $this->restApiResourceGetHistoryRequest($resource_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiResourceGetHistory'
     *
     * @param  string $resource_name The name of the resource (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiResourceGetHistoryRequest($resource_name)
    {
        // verify the required parameter 'resource_name' is set
        if ($resource_name === null || (is_array($resource_name) && count($resource_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource_name when calling restApiResourceGetHistory'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/{resourceName}/history';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($resource_name !== null) {
            $resourcePath = str_replace(
                '{' . 'resourceName' . '}',
                ObjectSerializer::toPathValue($resource_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiResourceGetTree
     *
     * ResourceGetTree
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $parent_folder The folder where to start listing contents (optional)
     * @param  bool $include_sub_directories If true, the tree also contains the directories under parentFolder (optional)
     * @param  bool $include_files If true, the tree structure is returned including files (ResourceItems) (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiResourceGetTree($resource_name, $parent_folder = null, $include_sub_directories = null, $include_files = null)
    {
        list($response) = $this->restApiResourceGetTreeWithHttpInfo($resource_name, $parent_folder, $include_sub_directories, $include_files);
        return $response;
    }

    /**
     * Operation restApiResourceGetTreeWithHttpInfo
     *
     * ResourceGetTree
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $parent_folder The folder where to start listing contents (optional)
     * @param  bool $include_sub_directories If true, the tree also contains the directories under parentFolder (optional)
     * @param  bool $include_files If true, the tree structure is returned including files (ResourceItems) (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiResourceGetTreeWithHttpInfo($resource_name, $parent_folder = null, $include_sub_directories = null, $include_files = null)
    {
        $returnType = 'object';
        $request = $this->restApiResourceGetTreeRequest($resource_name, $parent_folder, $include_sub_directories, $include_files);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiResourceGetTreeAsync
     *
     * ResourceGetTree
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $parent_folder The folder where to start listing contents (optional)
     * @param  bool $include_sub_directories If true, the tree also contains the directories under parentFolder (optional)
     * @param  bool $include_files If true, the tree structure is returned including files (ResourceItems) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceGetTreeAsync($resource_name, $parent_folder = null, $include_sub_directories = null, $include_files = null)
    {
        return $this->restApiResourceGetTreeAsyncWithHttpInfo($resource_name, $parent_folder, $include_sub_directories, $include_files)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiResourceGetTreeAsyncWithHttpInfo
     *
     * ResourceGetTree
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $parent_folder The folder where to start listing contents (optional)
     * @param  bool $include_sub_directories If true, the tree also contains the directories under parentFolder (optional)
     * @param  bool $include_files If true, the tree structure is returned including files (ResourceItems) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceGetTreeAsyncWithHttpInfo($resource_name, $parent_folder = null, $include_sub_directories = null, $include_files = null)
    {
        $returnType = 'object';
        $request = $this->restApiResourceGetTreeRequest($resource_name, $parent_folder, $include_sub_directories, $include_files);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiResourceGetTree'
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $parent_folder The folder where to start listing contents (optional)
     * @param  bool $include_sub_directories If true, the tree also contains the directories under parentFolder (optional)
     * @param  bool $include_files If true, the tree structure is returned including files (ResourceItems) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiResourceGetTreeRequest($resource_name, $parent_folder = null, $include_sub_directories = null, $include_files = null)
    {
        // verify the required parameter 'resource_name' is set
        if ($resource_name === null || (is_array($resource_name) && count($resource_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource_name when calling restApiResourceGetTree'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/{resourceName}/tree';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($parent_folder !== null) {
            $queryParams['parentFolder'] = ObjectSerializer::toQueryValue($parent_folder);
        }
        // query params
        if ($include_sub_directories !== null) {
            $queryParams['includeSubDirectories'] = ObjectSerializer::toQueryValue($include_sub_directories);
        }
        // query params
        if ($include_files !== null) {
            $queryParams['includeFiles'] = ObjectSerializer::toQueryValue($include_files);
        }

        // path params
        if ($resource_name !== null) {
            $resourcePath = str_replace(
                '{' . 'resourceName' . '}',
                ObjectSerializer::toPathValue($resource_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiResourceGetTreeLevel
     *
     * ResourceGetTreeLevel
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $parent_folder The folder where to start listing contents (optional)
     * @param  int $num_levels The amount of levels to return (optional)
     * @param  bool $include_sub_directories If true, the tree also contains the directories under parentFolder (optional)
     * @param  bool $include_files If true, the tree structure is returned including files (ResourceItems) (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiResourceGetTreeLevel($resource_name, $parent_folder = null, $num_levels = null, $include_sub_directories = null, $include_files = null)
    {
        list($response) = $this->restApiResourceGetTreeLevelWithHttpInfo($resource_name, $parent_folder, $num_levels, $include_sub_directories, $include_files);
        return $response;
    }

    /**
     * Operation restApiResourceGetTreeLevelWithHttpInfo
     *
     * ResourceGetTreeLevel
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $parent_folder The folder where to start listing contents (optional)
     * @param  int $num_levels The amount of levels to return (optional)
     * @param  bool $include_sub_directories If true, the tree also contains the directories under parentFolder (optional)
     * @param  bool $include_files If true, the tree structure is returned including files (ResourceItems) (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiResourceGetTreeLevelWithHttpInfo($resource_name, $parent_folder = null, $num_levels = null, $include_sub_directories = null, $include_files = null)
    {
        $returnType = 'object';
        $request = $this->restApiResourceGetTreeLevelRequest($resource_name, $parent_folder, $num_levels, $include_sub_directories, $include_files);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiResourceGetTreeLevelAsync
     *
     * ResourceGetTreeLevel
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $parent_folder The folder where to start listing contents (optional)
     * @param  int $num_levels The amount of levels to return (optional)
     * @param  bool $include_sub_directories If true, the tree also contains the directories under parentFolder (optional)
     * @param  bool $include_files If true, the tree structure is returned including files (ResourceItems) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceGetTreeLevelAsync($resource_name, $parent_folder = null, $num_levels = null, $include_sub_directories = null, $include_files = null)
    {
        return $this->restApiResourceGetTreeLevelAsyncWithHttpInfo($resource_name, $parent_folder, $num_levels, $include_sub_directories, $include_files)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiResourceGetTreeLevelAsyncWithHttpInfo
     *
     * ResourceGetTreeLevel
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $parent_folder The folder where to start listing contents (optional)
     * @param  int $num_levels The amount of levels to return (optional)
     * @param  bool $include_sub_directories If true, the tree also contains the directories under parentFolder (optional)
     * @param  bool $include_files If true, the tree structure is returned including files (ResourceItems) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceGetTreeLevelAsyncWithHttpInfo($resource_name, $parent_folder = null, $num_levels = null, $include_sub_directories = null, $include_files = null)
    {
        $returnType = 'object';
        $request = $this->restApiResourceGetTreeLevelRequest($resource_name, $parent_folder, $num_levels, $include_sub_directories, $include_files);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiResourceGetTreeLevel'
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $parent_folder The folder where to start listing contents (optional)
     * @param  int $num_levels The amount of levels to return (optional)
     * @param  bool $include_sub_directories If true, the tree also contains the directories under parentFolder (optional)
     * @param  bool $include_files If true, the tree structure is returned including files (ResourceItems) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiResourceGetTreeLevelRequest($resource_name, $parent_folder = null, $num_levels = null, $include_sub_directories = null, $include_files = null)
    {
        // verify the required parameter 'resource_name' is set
        if ($resource_name === null || (is_array($resource_name) && count($resource_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource_name when calling restApiResourceGetTreeLevel'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/{resourceName}/treelevel';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($parent_folder !== null) {
            $queryParams['parentFolder'] = ObjectSerializer::toQueryValue($parent_folder);
        }
        // query params
        if ($num_levels !== null) {
            $queryParams['numLevels'] = ObjectSerializer::toQueryValue($num_levels);
        }
        // query params
        if ($include_sub_directories !== null) {
            $queryParams['includeSubDirectories'] = ObjectSerializer::toQueryValue($include_sub_directories);
        }
        // query params
        if ($include_files !== null) {
            $queryParams['includeFiles'] = ObjectSerializer::toQueryValue($include_files);
        }

        // path params
        if ($resource_name !== null) {
            $resourcePath = str_replace(
                '{' . 'resourceName' . '}',
                ObjectSerializer::toPathValue($resource_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiResourceItemAdd
     *
     * ResourceItemAdd
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $new_name The name of the new resource item (required)
     * @param  \Swagger\Client\Model\ResourceItemAddBodyWrapper $body  (required)
     * @param  string $folder_path The relative path of the resource item in the resource&#39;s tree (for resources of type directory_object or directory_file) (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiResourceItemAdd($resource_name, $new_name, $body, $folder_path = null)
    {
        list($response) = $this->restApiResourceItemAddWithHttpInfo($resource_name, $new_name, $body, $folder_path);
        return $response;
    }

    /**
     * Operation restApiResourceItemAddWithHttpInfo
     *
     * ResourceItemAdd
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $new_name The name of the new resource item (required)
     * @param  \Swagger\Client\Model\ResourceItemAddBodyWrapper $body  (required)
     * @param  string $folder_path The relative path of the resource item in the resource&#39;s tree (for resources of type directory_object or directory_file) (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiResourceItemAddWithHttpInfo($resource_name, $new_name, $body, $folder_path = null)
    {
        $returnType = 'object';
        $request = $this->restApiResourceItemAddRequest($resource_name, $new_name, $body, $folder_path);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiResourceItemAddAsync
     *
     * ResourceItemAdd
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $new_name The name of the new resource item (required)
     * @param  \Swagger\Client\Model\ResourceItemAddBodyWrapper $body  (required)
     * @param  string $folder_path The relative path of the resource item in the resource&#39;s tree (for resources of type directory_object or directory_file) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceItemAddAsync($resource_name, $new_name, $body, $folder_path = null)
    {
        return $this->restApiResourceItemAddAsyncWithHttpInfo($resource_name, $new_name, $body, $folder_path)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiResourceItemAddAsyncWithHttpInfo
     *
     * ResourceItemAdd
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $new_name The name of the new resource item (required)
     * @param  \Swagger\Client\Model\ResourceItemAddBodyWrapper $body  (required)
     * @param  string $folder_path The relative path of the resource item in the resource&#39;s tree (for resources of type directory_object or directory_file) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceItemAddAsyncWithHttpInfo($resource_name, $new_name, $body, $folder_path = null)
    {
        $returnType = 'object';
        $request = $this->restApiResourceItemAddRequest($resource_name, $new_name, $body, $folder_path);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiResourceItemAdd'
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $new_name The name of the new resource item (required)
     * @param  \Swagger\Client\Model\ResourceItemAddBodyWrapper $body  (required)
     * @param  string $folder_path The relative path of the resource item in the resource&#39;s tree (for resources of type directory_object or directory_file) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiResourceItemAddRequest($resource_name, $new_name, $body, $folder_path = null)
    {
        // verify the required parameter 'resource_name' is set
        if ($resource_name === null || (is_array($resource_name) && count($resource_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource_name when calling restApiResourceItemAdd'
            );
        }
        // verify the required parameter 'new_name' is set
        if ($new_name === null || (is_array($new_name) && count($new_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $new_name when calling restApiResourceItemAdd'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling restApiResourceItemAdd'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/{resourceName}/items';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($new_name !== null) {
            $queryParams['newName'] = ObjectSerializer::toQueryValue($new_name);
        }
        // query params
        if ($folder_path !== null) {
            $queryParams['folderPath'] = ObjectSerializer::toQueryValue($folder_path);
        }

        // path params
        if ($resource_name !== null) {
            $resourcePath = str_replace(
                '{' . 'resourceName' . '}',
                ObjectSerializer::toPathValue($resource_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiResourceItemAddFromURL
     *
     * ResourceItemAddFromURL
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $new_name The name for the new resource item (required)
     * @param  string $folder_path Location for the new ResourceItem. (required)
     * @param  string $url URL to download (needs to be accessible from the CHILI server) (required)
     * @param  string $login Optional user name for authentication into the URL (passed on using Basic Authentication) (optional)
     * @param  string $pw Optional user password for authentication into the URL (passed on using Basic Authentication) (optional)
     * @param  bool $reuse_existing If true, the function will check if an item already exists in the Resource with the provided path/name. If it does, the existing ResourceItem is returned, and the URL is not downloaded. (optional)
     * @param  string $preview_file_url Optional URL to a preview file. If provided, this is downloaded and used as a preview override file. (optional)
     * @param  string $preview_extension The extension of the downloaded preview file (if provided) (optional)
     * @param  bool $is_permanent_preview If true, the provided preview override file remains valid even after the ResourceItem is modified (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiResourceItemAddFromURL($resource_name, $new_name, $folder_path, $url, $login = null, $pw = null, $reuse_existing = null, $preview_file_url = null, $preview_extension = null, $is_permanent_preview = null)
    {
        list($response) = $this->restApiResourceItemAddFromURLWithHttpInfo($resource_name, $new_name, $folder_path, $url, $login, $pw, $reuse_existing, $preview_file_url, $preview_extension, $is_permanent_preview);
        return $response;
    }

    /**
     * Operation restApiResourceItemAddFromURLWithHttpInfo
     *
     * ResourceItemAddFromURL
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $new_name The name for the new resource item (required)
     * @param  string $folder_path Location for the new ResourceItem. (required)
     * @param  string $url URL to download (needs to be accessible from the CHILI server) (required)
     * @param  string $login Optional user name for authentication into the URL (passed on using Basic Authentication) (optional)
     * @param  string $pw Optional user password for authentication into the URL (passed on using Basic Authentication) (optional)
     * @param  bool $reuse_existing If true, the function will check if an item already exists in the Resource with the provided path/name. If it does, the existing ResourceItem is returned, and the URL is not downloaded. (optional)
     * @param  string $preview_file_url Optional URL to a preview file. If provided, this is downloaded and used as a preview override file. (optional)
     * @param  string $preview_extension The extension of the downloaded preview file (if provided) (optional)
     * @param  bool $is_permanent_preview If true, the provided preview override file remains valid even after the ResourceItem is modified (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiResourceItemAddFromURLWithHttpInfo($resource_name, $new_name, $folder_path, $url, $login = null, $pw = null, $reuse_existing = null, $preview_file_url = null, $preview_extension = null, $is_permanent_preview = null)
    {
        $returnType = 'object';
        $request = $this->restApiResourceItemAddFromURLRequest($resource_name, $new_name, $folder_path, $url, $login, $pw, $reuse_existing, $preview_file_url, $preview_extension, $is_permanent_preview);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiResourceItemAddFromURLAsync
     *
     * ResourceItemAddFromURL
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $new_name The name for the new resource item (required)
     * @param  string $folder_path Location for the new ResourceItem. (required)
     * @param  string $url URL to download (needs to be accessible from the CHILI server) (required)
     * @param  string $login Optional user name for authentication into the URL (passed on using Basic Authentication) (optional)
     * @param  string $pw Optional user password for authentication into the URL (passed on using Basic Authentication) (optional)
     * @param  bool $reuse_existing If true, the function will check if an item already exists in the Resource with the provided path/name. If it does, the existing ResourceItem is returned, and the URL is not downloaded. (optional)
     * @param  string $preview_file_url Optional URL to a preview file. If provided, this is downloaded and used as a preview override file. (optional)
     * @param  string $preview_extension The extension of the downloaded preview file (if provided) (optional)
     * @param  bool $is_permanent_preview If true, the provided preview override file remains valid even after the ResourceItem is modified (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceItemAddFromURLAsync($resource_name, $new_name, $folder_path, $url, $login = null, $pw = null, $reuse_existing = null, $preview_file_url = null, $preview_extension = null, $is_permanent_preview = null)
    {
        return $this->restApiResourceItemAddFromURLAsyncWithHttpInfo($resource_name, $new_name, $folder_path, $url, $login, $pw, $reuse_existing, $preview_file_url, $preview_extension, $is_permanent_preview)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiResourceItemAddFromURLAsyncWithHttpInfo
     *
     * ResourceItemAddFromURL
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $new_name The name for the new resource item (required)
     * @param  string $folder_path Location for the new ResourceItem. (required)
     * @param  string $url URL to download (needs to be accessible from the CHILI server) (required)
     * @param  string $login Optional user name for authentication into the URL (passed on using Basic Authentication) (optional)
     * @param  string $pw Optional user password for authentication into the URL (passed on using Basic Authentication) (optional)
     * @param  bool $reuse_existing If true, the function will check if an item already exists in the Resource with the provided path/name. If it does, the existing ResourceItem is returned, and the URL is not downloaded. (optional)
     * @param  string $preview_file_url Optional URL to a preview file. If provided, this is downloaded and used as a preview override file. (optional)
     * @param  string $preview_extension The extension of the downloaded preview file (if provided) (optional)
     * @param  bool $is_permanent_preview If true, the provided preview override file remains valid even after the ResourceItem is modified (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceItemAddFromURLAsyncWithHttpInfo($resource_name, $new_name, $folder_path, $url, $login = null, $pw = null, $reuse_existing = null, $preview_file_url = null, $preview_extension = null, $is_permanent_preview = null)
    {
        $returnType = 'object';
        $request = $this->restApiResourceItemAddFromURLRequest($resource_name, $new_name, $folder_path, $url, $login, $pw, $reuse_existing, $preview_file_url, $preview_extension, $is_permanent_preview);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiResourceItemAddFromURL'
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $new_name The name for the new resource item (required)
     * @param  string $folder_path Location for the new ResourceItem. (required)
     * @param  string $url URL to download (needs to be accessible from the CHILI server) (required)
     * @param  string $login Optional user name for authentication into the URL (passed on using Basic Authentication) (optional)
     * @param  string $pw Optional user password for authentication into the URL (passed on using Basic Authentication) (optional)
     * @param  bool $reuse_existing If true, the function will check if an item already exists in the Resource with the provided path/name. If it does, the existing ResourceItem is returned, and the URL is not downloaded. (optional)
     * @param  string $preview_file_url Optional URL to a preview file. If provided, this is downloaded and used as a preview override file. (optional)
     * @param  string $preview_extension The extension of the downloaded preview file (if provided) (optional)
     * @param  bool $is_permanent_preview If true, the provided preview override file remains valid even after the ResourceItem is modified (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiResourceItemAddFromURLRequest($resource_name, $new_name, $folder_path, $url, $login = null, $pw = null, $reuse_existing = null, $preview_file_url = null, $preview_extension = null, $is_permanent_preview = null)
    {
        // verify the required parameter 'resource_name' is set
        if ($resource_name === null || (is_array($resource_name) && count($resource_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource_name when calling restApiResourceItemAddFromURL'
            );
        }
        // verify the required parameter 'new_name' is set
        if ($new_name === null || (is_array($new_name) && count($new_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $new_name when calling restApiResourceItemAddFromURL'
            );
        }
        // verify the required parameter 'folder_path' is set
        if ($folder_path === null || (is_array($folder_path) && count($folder_path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $folder_path when calling restApiResourceItemAddFromURL'
            );
        }
        // verify the required parameter 'url' is set
        if ($url === null || (is_array($url) && count($url) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $url when calling restApiResourceItemAddFromURL'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/{resourceName}/items/fromurl';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($new_name !== null) {
            $queryParams['newName'] = ObjectSerializer::toQueryValue($new_name);
        }
        // query params
        if ($folder_path !== null) {
            $queryParams['folderPath'] = ObjectSerializer::toQueryValue($folder_path);
        }
        // query params
        if ($url !== null) {
            $queryParams['url'] = ObjectSerializer::toQueryValue($url);
        }
        // query params
        if ($login !== null) {
            $queryParams['login'] = ObjectSerializer::toQueryValue($login);
        }
        // query params
        if ($pw !== null) {
            $queryParams['pw'] = ObjectSerializer::toQueryValue($pw);
        }
        // query params
        if ($reuse_existing !== null) {
            $queryParams['reuseExisting'] = ObjectSerializer::toQueryValue($reuse_existing);
        }
        // query params
        if ($preview_file_url !== null) {
            $queryParams['previewFileURL'] = ObjectSerializer::toQueryValue($preview_file_url);
        }
        // query params
        if ($preview_extension !== null) {
            $queryParams['previewExtension'] = ObjectSerializer::toQueryValue($preview_extension);
        }
        // query params
        if ($is_permanent_preview !== null) {
            $queryParams['isPermanentPreview'] = ObjectSerializer::toQueryValue($is_permanent_preview);
        }

        // path params
        if ($resource_name !== null) {
            $resourcePath = str_replace(
                '{' . 'resourceName' . '}',
                ObjectSerializer::toPathValue($resource_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiResourceItemAddFromURLWithModificationDate
     *
     * ResourceItemAddFromURLWithModificationDate
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $new_name The name for the new resource item (required)
     * @param  string $folder_path Location for the new ResourceItem. (required)
     * @param  string $url URL to download (needs to be accessible from the CHILI server) (required)
     * @param  \Swagger\Client\Model\ResourceItemAddFromURLWithModificationDateBodyWrapper $body  (required)
     * @param  string $login Optional user name for authentication into the URL (passed on using Basic Authentication) (optional)
     * @param  string $pw Optional user password for authentication into the URL (passed on using Basic Authentication) (optional)
     * @param  bool $reuse_existing If true, the function will check if an item already exists in the Resource with the provided path/name. If it does, the existing ResourceItem is returned, and the URL is not downloaded. (optional)
     * @param  string $preview_file_url Optional URL to a preview file. If provided, this is downloaded and used as a preview override file. (optional)
     * @param  string $preview_extension The extension of the downloaded preview file (if provided) (optional)
     * @param  bool $is_permanent_preview If true, the provided preview override file remains valid even after the ResourceItem is modified (optional)
     * @param  string $modification_date Modification date (should be the same format and timezone as GetServerDate api call returns) of the external resource (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiResourceItemAddFromURLWithModificationDate($resource_name, $new_name, $folder_path, $url, $body, $login = null, $pw = null, $reuse_existing = null, $preview_file_url = null, $preview_extension = null, $is_permanent_preview = null, $modification_date = null)
    {
        list($response) = $this->restApiResourceItemAddFromURLWithModificationDateWithHttpInfo($resource_name, $new_name, $folder_path, $url, $body, $login, $pw, $reuse_existing, $preview_file_url, $preview_extension, $is_permanent_preview, $modification_date);
        return $response;
    }

    /**
     * Operation restApiResourceItemAddFromURLWithModificationDateWithHttpInfo
     *
     * ResourceItemAddFromURLWithModificationDate
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $new_name The name for the new resource item (required)
     * @param  string $folder_path Location for the new ResourceItem. (required)
     * @param  string $url URL to download (needs to be accessible from the CHILI server) (required)
     * @param  \Swagger\Client\Model\ResourceItemAddFromURLWithModificationDateBodyWrapper $body  (required)
     * @param  string $login Optional user name for authentication into the URL (passed on using Basic Authentication) (optional)
     * @param  string $pw Optional user password for authentication into the URL (passed on using Basic Authentication) (optional)
     * @param  bool $reuse_existing If true, the function will check if an item already exists in the Resource with the provided path/name. If it does, the existing ResourceItem is returned, and the URL is not downloaded. (optional)
     * @param  string $preview_file_url Optional URL to a preview file. If provided, this is downloaded and used as a preview override file. (optional)
     * @param  string $preview_extension The extension of the downloaded preview file (if provided) (optional)
     * @param  bool $is_permanent_preview If true, the provided preview override file remains valid even after the ResourceItem is modified (optional)
     * @param  string $modification_date Modification date (should be the same format and timezone as GetServerDate api call returns) of the external resource (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiResourceItemAddFromURLWithModificationDateWithHttpInfo($resource_name, $new_name, $folder_path, $url, $body, $login = null, $pw = null, $reuse_existing = null, $preview_file_url = null, $preview_extension = null, $is_permanent_preview = null, $modification_date = null)
    {
        $returnType = 'object';
        $request = $this->restApiResourceItemAddFromURLWithModificationDateRequest($resource_name, $new_name, $folder_path, $url, $body, $login, $pw, $reuse_existing, $preview_file_url, $preview_extension, $is_permanent_preview, $modification_date);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiResourceItemAddFromURLWithModificationDateAsync
     *
     * ResourceItemAddFromURLWithModificationDate
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $new_name The name for the new resource item (required)
     * @param  string $folder_path Location for the new ResourceItem. (required)
     * @param  string $url URL to download (needs to be accessible from the CHILI server) (required)
     * @param  \Swagger\Client\Model\ResourceItemAddFromURLWithModificationDateBodyWrapper $body  (required)
     * @param  string $login Optional user name for authentication into the URL (passed on using Basic Authentication) (optional)
     * @param  string $pw Optional user password for authentication into the URL (passed on using Basic Authentication) (optional)
     * @param  bool $reuse_existing If true, the function will check if an item already exists in the Resource with the provided path/name. If it does, the existing ResourceItem is returned, and the URL is not downloaded. (optional)
     * @param  string $preview_file_url Optional URL to a preview file. If provided, this is downloaded and used as a preview override file. (optional)
     * @param  string $preview_extension The extension of the downloaded preview file (if provided) (optional)
     * @param  bool $is_permanent_preview If true, the provided preview override file remains valid even after the ResourceItem is modified (optional)
     * @param  string $modification_date Modification date (should be the same format and timezone as GetServerDate api call returns) of the external resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceItemAddFromURLWithModificationDateAsync($resource_name, $new_name, $folder_path, $url, $body, $login = null, $pw = null, $reuse_existing = null, $preview_file_url = null, $preview_extension = null, $is_permanent_preview = null, $modification_date = null)
    {
        return $this->restApiResourceItemAddFromURLWithModificationDateAsyncWithHttpInfo($resource_name, $new_name, $folder_path, $url, $body, $login, $pw, $reuse_existing, $preview_file_url, $preview_extension, $is_permanent_preview, $modification_date)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiResourceItemAddFromURLWithModificationDateAsyncWithHttpInfo
     *
     * ResourceItemAddFromURLWithModificationDate
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $new_name The name for the new resource item (required)
     * @param  string $folder_path Location for the new ResourceItem. (required)
     * @param  string $url URL to download (needs to be accessible from the CHILI server) (required)
     * @param  \Swagger\Client\Model\ResourceItemAddFromURLWithModificationDateBodyWrapper $body  (required)
     * @param  string $login Optional user name for authentication into the URL (passed on using Basic Authentication) (optional)
     * @param  string $pw Optional user password for authentication into the URL (passed on using Basic Authentication) (optional)
     * @param  bool $reuse_existing If true, the function will check if an item already exists in the Resource with the provided path/name. If it does, the existing ResourceItem is returned, and the URL is not downloaded. (optional)
     * @param  string $preview_file_url Optional URL to a preview file. If provided, this is downloaded and used as a preview override file. (optional)
     * @param  string $preview_extension The extension of the downloaded preview file (if provided) (optional)
     * @param  bool $is_permanent_preview If true, the provided preview override file remains valid even after the ResourceItem is modified (optional)
     * @param  string $modification_date Modification date (should be the same format and timezone as GetServerDate api call returns) of the external resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceItemAddFromURLWithModificationDateAsyncWithHttpInfo($resource_name, $new_name, $folder_path, $url, $body, $login = null, $pw = null, $reuse_existing = null, $preview_file_url = null, $preview_extension = null, $is_permanent_preview = null, $modification_date = null)
    {
        $returnType = 'object';
        $request = $this->restApiResourceItemAddFromURLWithModificationDateRequest($resource_name, $new_name, $folder_path, $url, $body, $login, $pw, $reuse_existing, $preview_file_url, $preview_extension, $is_permanent_preview, $modification_date);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiResourceItemAddFromURLWithModificationDate'
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $new_name The name for the new resource item (required)
     * @param  string $folder_path Location for the new ResourceItem. (required)
     * @param  string $url URL to download (needs to be accessible from the CHILI server) (required)
     * @param  \Swagger\Client\Model\ResourceItemAddFromURLWithModificationDateBodyWrapper $body  (required)
     * @param  string $login Optional user name for authentication into the URL (passed on using Basic Authentication) (optional)
     * @param  string $pw Optional user password for authentication into the URL (passed on using Basic Authentication) (optional)
     * @param  bool $reuse_existing If true, the function will check if an item already exists in the Resource with the provided path/name. If it does, the existing ResourceItem is returned, and the URL is not downloaded. (optional)
     * @param  string $preview_file_url Optional URL to a preview file. If provided, this is downloaded and used as a preview override file. (optional)
     * @param  string $preview_extension The extension of the downloaded preview file (if provided) (optional)
     * @param  bool $is_permanent_preview If true, the provided preview override file remains valid even after the ResourceItem is modified (optional)
     * @param  string $modification_date Modification date (should be the same format and timezone as GetServerDate api call returns) of the external resource (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiResourceItemAddFromURLWithModificationDateRequest($resource_name, $new_name, $folder_path, $url, $body, $login = null, $pw = null, $reuse_existing = null, $preview_file_url = null, $preview_extension = null, $is_permanent_preview = null, $modification_date = null)
    {
        // verify the required parameter 'resource_name' is set
        if ($resource_name === null || (is_array($resource_name) && count($resource_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource_name when calling restApiResourceItemAddFromURLWithModificationDate'
            );
        }
        // verify the required parameter 'new_name' is set
        if ($new_name === null || (is_array($new_name) && count($new_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $new_name when calling restApiResourceItemAddFromURLWithModificationDate'
            );
        }
        // verify the required parameter 'folder_path' is set
        if ($folder_path === null || (is_array($folder_path) && count($folder_path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $folder_path when calling restApiResourceItemAddFromURLWithModificationDate'
            );
        }
        // verify the required parameter 'url' is set
        if ($url === null || (is_array($url) && count($url) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $url when calling restApiResourceItemAddFromURLWithModificationDate'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling restApiResourceItemAddFromURLWithModificationDate'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/{resourceName}/items/fromurlmod';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($new_name !== null) {
            $queryParams['newName'] = ObjectSerializer::toQueryValue($new_name);
        }
        // query params
        if ($folder_path !== null) {
            $queryParams['folderPath'] = ObjectSerializer::toQueryValue($folder_path);
        }
        // query params
        if ($url !== null) {
            $queryParams['url'] = ObjectSerializer::toQueryValue($url);
        }
        // query params
        if ($login !== null) {
            $queryParams['login'] = ObjectSerializer::toQueryValue($login);
        }
        // query params
        if ($pw !== null) {
            $queryParams['pw'] = ObjectSerializer::toQueryValue($pw);
        }
        // query params
        if ($reuse_existing !== null) {
            $queryParams['reuseExisting'] = ObjectSerializer::toQueryValue($reuse_existing);
        }
        // query params
        if ($preview_file_url !== null) {
            $queryParams['previewFileURL'] = ObjectSerializer::toQueryValue($preview_file_url);
        }
        // query params
        if ($preview_extension !== null) {
            $queryParams['previewExtension'] = ObjectSerializer::toQueryValue($preview_extension);
        }
        // query params
        if ($is_permanent_preview !== null) {
            $queryParams['isPermanentPreview'] = ObjectSerializer::toQueryValue($is_permanent_preview);
        }
        // query params
        if ($modification_date !== null) {
            $queryParams['modificationDate'] = ObjectSerializer::toQueryValue($modification_date);
        }

        // path params
        if ($resource_name !== null) {
            $resourcePath = str_replace(
                '{' . 'resourceName' . '}',
                ObjectSerializer::toPathValue($resource_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiResourceItemAddPreviewOverride
     *
     * ResourceItemAddPreviewOverride
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_id The ID of the item (required)
     * @param  \Swagger\Client\Model\ResourceItemAddPreviewOverrideBodyWrapper $body  (required)
     * @param  string $preview_extension Extension (\&quot;jpg\&quot;, \&quot;png\&quot;, ...) of the preview file (optional)
     * @param  bool $is_permanent_preview If true, the preview override remains valid even after the resource item is modified (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiResourceItemAddPreviewOverride($resource_name, $item_id, $body, $preview_extension = null, $is_permanent_preview = null)
    {
        list($response) = $this->restApiResourceItemAddPreviewOverrideWithHttpInfo($resource_name, $item_id, $body, $preview_extension, $is_permanent_preview);
        return $response;
    }

    /**
     * Operation restApiResourceItemAddPreviewOverrideWithHttpInfo
     *
     * ResourceItemAddPreviewOverride
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_id The ID of the item (required)
     * @param  \Swagger\Client\Model\ResourceItemAddPreviewOverrideBodyWrapper $body  (required)
     * @param  string $preview_extension Extension (\&quot;jpg\&quot;, \&quot;png\&quot;, ...) of the preview file (optional)
     * @param  bool $is_permanent_preview If true, the preview override remains valid even after the resource item is modified (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiResourceItemAddPreviewOverrideWithHttpInfo($resource_name, $item_id, $body, $preview_extension = null, $is_permanent_preview = null)
    {
        $returnType = 'object';
        $request = $this->restApiResourceItemAddPreviewOverrideRequest($resource_name, $item_id, $body, $preview_extension, $is_permanent_preview);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiResourceItemAddPreviewOverrideAsync
     *
     * ResourceItemAddPreviewOverride
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_id The ID of the item (required)
     * @param  \Swagger\Client\Model\ResourceItemAddPreviewOverrideBodyWrapper $body  (required)
     * @param  string $preview_extension Extension (\&quot;jpg\&quot;, \&quot;png\&quot;, ...) of the preview file (optional)
     * @param  bool $is_permanent_preview If true, the preview override remains valid even after the resource item is modified (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceItemAddPreviewOverrideAsync($resource_name, $item_id, $body, $preview_extension = null, $is_permanent_preview = null)
    {
        return $this->restApiResourceItemAddPreviewOverrideAsyncWithHttpInfo($resource_name, $item_id, $body, $preview_extension, $is_permanent_preview)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiResourceItemAddPreviewOverrideAsyncWithHttpInfo
     *
     * ResourceItemAddPreviewOverride
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_id The ID of the item (required)
     * @param  \Swagger\Client\Model\ResourceItemAddPreviewOverrideBodyWrapper $body  (required)
     * @param  string $preview_extension Extension (\&quot;jpg\&quot;, \&quot;png\&quot;, ...) of the preview file (optional)
     * @param  bool $is_permanent_preview If true, the preview override remains valid even after the resource item is modified (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceItemAddPreviewOverrideAsyncWithHttpInfo($resource_name, $item_id, $body, $preview_extension = null, $is_permanent_preview = null)
    {
        $returnType = 'object';
        $request = $this->restApiResourceItemAddPreviewOverrideRequest($resource_name, $item_id, $body, $preview_extension, $is_permanent_preview);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiResourceItemAddPreviewOverride'
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_id The ID of the item (required)
     * @param  \Swagger\Client\Model\ResourceItemAddPreviewOverrideBodyWrapper $body  (required)
     * @param  string $preview_extension Extension (\&quot;jpg\&quot;, \&quot;png\&quot;, ...) of the preview file (optional)
     * @param  bool $is_permanent_preview If true, the preview override remains valid even after the resource item is modified (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiResourceItemAddPreviewOverrideRequest($resource_name, $item_id, $body, $preview_extension = null, $is_permanent_preview = null)
    {
        // verify the required parameter 'resource_name' is set
        if ($resource_name === null || (is_array($resource_name) && count($resource_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource_name when calling restApiResourceItemAddPreviewOverride'
            );
        }
        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling restApiResourceItemAddPreviewOverride'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling restApiResourceItemAddPreviewOverride'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/{resourceName}/items/{itemID}/previews';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($preview_extension !== null) {
            $queryParams['previewExtension'] = ObjectSerializer::toQueryValue($preview_extension);
        }
        // query params
        if ($is_permanent_preview !== null) {
            $queryParams['isPermanentPreview'] = ObjectSerializer::toQueryValue($is_permanent_preview);
        }

        // path params
        if ($resource_name !== null) {
            $resourcePath = str_replace(
                '{' . 'resourceName' . '}',
                ObjectSerializer::toPathValue($resource_name),
                $resourcePath
            );
        }
        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemID' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiResourceItemAddWithPreview
     *
     * ResourceItemAddWithPreview
     *
     * @param  string $resource_name The resource name (required)
     * @param  string $new_name The name of the new resource item (required)
     * @param  string $folder_path The relative path of the resource item in the resource&#39;s tree (for resources of type directory_object or directory_file) (required)
     * @param  \Swagger\Client\Model\ResourceItemAddWithPreviewBodyWrapper $body  (required)
     * @param  string $preview_extension The extension of the preview file. If previewFileData contains a path, the extension is optional (optional)
     * @param  bool $is_permanent_preview If true, the preview override remains valid even after the resource item is modified (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiResourceItemAddWithPreview($resource_name, $new_name, $folder_path, $body, $preview_extension = null, $is_permanent_preview = null)
    {
        list($response) = $this->restApiResourceItemAddWithPreviewWithHttpInfo($resource_name, $new_name, $folder_path, $body, $preview_extension, $is_permanent_preview);
        return $response;
    }

    /**
     * Operation restApiResourceItemAddWithPreviewWithHttpInfo
     *
     * ResourceItemAddWithPreview
     *
     * @param  string $resource_name The resource name (required)
     * @param  string $new_name The name of the new resource item (required)
     * @param  string $folder_path The relative path of the resource item in the resource&#39;s tree (for resources of type directory_object or directory_file) (required)
     * @param  \Swagger\Client\Model\ResourceItemAddWithPreviewBodyWrapper $body  (required)
     * @param  string $preview_extension The extension of the preview file. If previewFileData contains a path, the extension is optional (optional)
     * @param  bool $is_permanent_preview If true, the preview override remains valid even after the resource item is modified (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiResourceItemAddWithPreviewWithHttpInfo($resource_name, $new_name, $folder_path, $body, $preview_extension = null, $is_permanent_preview = null)
    {
        $returnType = 'object';
        $request = $this->restApiResourceItemAddWithPreviewRequest($resource_name, $new_name, $folder_path, $body, $preview_extension, $is_permanent_preview);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiResourceItemAddWithPreviewAsync
     *
     * ResourceItemAddWithPreview
     *
     * @param  string $resource_name The resource name (required)
     * @param  string $new_name The name of the new resource item (required)
     * @param  string $folder_path The relative path of the resource item in the resource&#39;s tree (for resources of type directory_object or directory_file) (required)
     * @param  \Swagger\Client\Model\ResourceItemAddWithPreviewBodyWrapper $body  (required)
     * @param  string $preview_extension The extension of the preview file. If previewFileData contains a path, the extension is optional (optional)
     * @param  bool $is_permanent_preview If true, the preview override remains valid even after the resource item is modified (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceItemAddWithPreviewAsync($resource_name, $new_name, $folder_path, $body, $preview_extension = null, $is_permanent_preview = null)
    {
        return $this->restApiResourceItemAddWithPreviewAsyncWithHttpInfo($resource_name, $new_name, $folder_path, $body, $preview_extension, $is_permanent_preview)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiResourceItemAddWithPreviewAsyncWithHttpInfo
     *
     * ResourceItemAddWithPreview
     *
     * @param  string $resource_name The resource name (required)
     * @param  string $new_name The name of the new resource item (required)
     * @param  string $folder_path The relative path of the resource item in the resource&#39;s tree (for resources of type directory_object or directory_file) (required)
     * @param  \Swagger\Client\Model\ResourceItemAddWithPreviewBodyWrapper $body  (required)
     * @param  string $preview_extension The extension of the preview file. If previewFileData contains a path, the extension is optional (optional)
     * @param  bool $is_permanent_preview If true, the preview override remains valid even after the resource item is modified (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceItemAddWithPreviewAsyncWithHttpInfo($resource_name, $new_name, $folder_path, $body, $preview_extension = null, $is_permanent_preview = null)
    {
        $returnType = 'object';
        $request = $this->restApiResourceItemAddWithPreviewRequest($resource_name, $new_name, $folder_path, $body, $preview_extension, $is_permanent_preview);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiResourceItemAddWithPreview'
     *
     * @param  string $resource_name The resource name (required)
     * @param  string $new_name The name of the new resource item (required)
     * @param  string $folder_path The relative path of the resource item in the resource&#39;s tree (for resources of type directory_object or directory_file) (required)
     * @param  \Swagger\Client\Model\ResourceItemAddWithPreviewBodyWrapper $body  (required)
     * @param  string $preview_extension The extension of the preview file. If previewFileData contains a path, the extension is optional (optional)
     * @param  bool $is_permanent_preview If true, the preview override remains valid even after the resource item is modified (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiResourceItemAddWithPreviewRequest($resource_name, $new_name, $folder_path, $body, $preview_extension = null, $is_permanent_preview = null)
    {
        // verify the required parameter 'resource_name' is set
        if ($resource_name === null || (is_array($resource_name) && count($resource_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource_name when calling restApiResourceItemAddWithPreview'
            );
        }
        // verify the required parameter 'new_name' is set
        if ($new_name === null || (is_array($new_name) && count($new_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $new_name when calling restApiResourceItemAddWithPreview'
            );
        }
        // verify the required parameter 'folder_path' is set
        if ($folder_path === null || (is_array($folder_path) && count($folder_path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $folder_path when calling restApiResourceItemAddWithPreview'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling restApiResourceItemAddWithPreview'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/{resourceName}/items/preview';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($new_name !== null) {
            $queryParams['newName'] = ObjectSerializer::toQueryValue($new_name);
        }
        // query params
        if ($folder_path !== null) {
            $queryParams['folderPath'] = ObjectSerializer::toQueryValue($folder_path);
        }
        // query params
        if ($preview_extension !== null) {
            $queryParams['previewExtension'] = ObjectSerializer::toQueryValue($preview_extension);
        }
        // query params
        if ($is_permanent_preview !== null) {
            $queryParams['isPermanentPreview'] = ObjectSerializer::toQueryValue($is_permanent_preview);
        }

        // path params
        if ($resource_name !== null) {
            $resourcePath = str_replace(
                '{' . 'resourceName' . '}',
                ObjectSerializer::toPathValue($resource_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiResourceItemCopy
     *
     * ResourceItemCopy
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_id The ID of the item to copy (required)
     * @param  string $new_name The name for the new ResourceItem (required)
     * @param  string $folder_path The location (relative path within the Resource&#39;s tree) for the new ResourceItem (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiResourceItemCopy($resource_name, $item_id, $new_name, $folder_path = null)
    {
        list($response) = $this->restApiResourceItemCopyWithHttpInfo($resource_name, $item_id, $new_name, $folder_path);
        return $response;
    }

    /**
     * Operation restApiResourceItemCopyWithHttpInfo
     *
     * ResourceItemCopy
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_id The ID of the item to copy (required)
     * @param  string $new_name The name for the new ResourceItem (required)
     * @param  string $folder_path The location (relative path within the Resource&#39;s tree) for the new ResourceItem (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiResourceItemCopyWithHttpInfo($resource_name, $item_id, $new_name, $folder_path = null)
    {
        $returnType = 'object';
        $request = $this->restApiResourceItemCopyRequest($resource_name, $item_id, $new_name, $folder_path);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiResourceItemCopyAsync
     *
     * ResourceItemCopy
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_id The ID of the item to copy (required)
     * @param  string $new_name The name for the new ResourceItem (required)
     * @param  string $folder_path The location (relative path within the Resource&#39;s tree) for the new ResourceItem (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceItemCopyAsync($resource_name, $item_id, $new_name, $folder_path = null)
    {
        return $this->restApiResourceItemCopyAsyncWithHttpInfo($resource_name, $item_id, $new_name, $folder_path)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiResourceItemCopyAsyncWithHttpInfo
     *
     * ResourceItemCopy
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_id The ID of the item to copy (required)
     * @param  string $new_name The name for the new ResourceItem (required)
     * @param  string $folder_path The location (relative path within the Resource&#39;s tree) for the new ResourceItem (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceItemCopyAsyncWithHttpInfo($resource_name, $item_id, $new_name, $folder_path = null)
    {
        $returnType = 'object';
        $request = $this->restApiResourceItemCopyRequest($resource_name, $item_id, $new_name, $folder_path);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiResourceItemCopy'
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_id The ID of the item to copy (required)
     * @param  string $new_name The name for the new ResourceItem (required)
     * @param  string $folder_path The location (relative path within the Resource&#39;s tree) for the new ResourceItem (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiResourceItemCopyRequest($resource_name, $item_id, $new_name, $folder_path = null)
    {
        // verify the required parameter 'resource_name' is set
        if ($resource_name === null || (is_array($resource_name) && count($resource_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource_name when calling restApiResourceItemCopy'
            );
        }
        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling restApiResourceItemCopy'
            );
        }
        // verify the required parameter 'new_name' is set
        if ($new_name === null || (is_array($new_name) && count($new_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $new_name when calling restApiResourceItemCopy'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/{resourceName}/items/{itemID}/copy';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($new_name !== null) {
            $queryParams['newName'] = ObjectSerializer::toQueryValue($new_name);
        }
        // query params
        if ($folder_path !== null) {
            $queryParams['folderPath'] = ObjectSerializer::toQueryValue($folder_path);
        }

        // path params
        if ($resource_name !== null) {
            $resourcePath = str_replace(
                '{' . 'resourceName' . '}',
                ObjectSerializer::toPathValue($resource_name),
                $resourcePath
            );
        }
        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemID' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiResourceItemDelete
     *
     * ResourceItemDelete
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_id The ID of the ResourceItem to delete (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiResourceItemDelete($resource_name, $item_id)
    {
        list($response) = $this->restApiResourceItemDeleteWithHttpInfo($resource_name, $item_id);
        return $response;
    }

    /**
     * Operation restApiResourceItemDeleteWithHttpInfo
     *
     * ResourceItemDelete
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_id The ID of the ResourceItem to delete (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiResourceItemDeleteWithHttpInfo($resource_name, $item_id)
    {
        $returnType = 'object';
        $request = $this->restApiResourceItemDeleteRequest($resource_name, $item_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiResourceItemDeleteAsync
     *
     * ResourceItemDelete
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_id The ID of the ResourceItem to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceItemDeleteAsync($resource_name, $item_id)
    {
        return $this->restApiResourceItemDeleteAsyncWithHttpInfo($resource_name, $item_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiResourceItemDeleteAsyncWithHttpInfo
     *
     * ResourceItemDelete
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_id The ID of the ResourceItem to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceItemDeleteAsyncWithHttpInfo($resource_name, $item_id)
    {
        $returnType = 'object';
        $request = $this->restApiResourceItemDeleteRequest($resource_name, $item_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiResourceItemDelete'
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_id The ID of the ResourceItem to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiResourceItemDeleteRequest($resource_name, $item_id)
    {
        // verify the required parameter 'resource_name' is set
        if ($resource_name === null || (is_array($resource_name) && count($resource_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource_name when calling restApiResourceItemDelete'
            );
        }
        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling restApiResourceItemDelete'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/{resourceName}/items/{itemID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($resource_name !== null) {
            $resourcePath = str_replace(
                '{' . 'resourceName' . '}',
                ObjectSerializer::toPathValue($resource_name),
                $resourcePath
            );
        }
        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemID' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiResourceItemGetByIdOrPath
     *
     * ResourceItemGetByIdOrPath
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_id_or_path The id or relative path to the Resource Item to find (required)
     * @param  bool $include_sub_folders If true, search will include subfolders (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiResourceItemGetByIdOrPath($resource_name, $item_id_or_path, $include_sub_folders = null)
    {
        list($response) = $this->restApiResourceItemGetByIdOrPathWithHttpInfo($resource_name, $item_id_or_path, $include_sub_folders);
        return $response;
    }

    /**
     * Operation restApiResourceItemGetByIdOrPathWithHttpInfo
     *
     * ResourceItemGetByIdOrPath
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_id_or_path The id or relative path to the Resource Item to find (required)
     * @param  bool $include_sub_folders If true, search will include subfolders (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiResourceItemGetByIdOrPathWithHttpInfo($resource_name, $item_id_or_path, $include_sub_folders = null)
    {
        $returnType = 'object';
        $request = $this->restApiResourceItemGetByIdOrPathRequest($resource_name, $item_id_or_path, $include_sub_folders);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiResourceItemGetByIdOrPathAsync
     *
     * ResourceItemGetByIdOrPath
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_id_or_path The id or relative path to the Resource Item to find (required)
     * @param  bool $include_sub_folders If true, search will include subfolders (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceItemGetByIdOrPathAsync($resource_name, $item_id_or_path, $include_sub_folders = null)
    {
        return $this->restApiResourceItemGetByIdOrPathAsyncWithHttpInfo($resource_name, $item_id_or_path, $include_sub_folders)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiResourceItemGetByIdOrPathAsyncWithHttpInfo
     *
     * ResourceItemGetByIdOrPath
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_id_or_path The id or relative path to the Resource Item to find (required)
     * @param  bool $include_sub_folders If true, search will include subfolders (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceItemGetByIdOrPathAsyncWithHttpInfo($resource_name, $item_id_or_path, $include_sub_folders = null)
    {
        $returnType = 'object';
        $request = $this->restApiResourceItemGetByIdOrPathRequest($resource_name, $item_id_or_path, $include_sub_folders);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiResourceItemGetByIdOrPath'
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_id_or_path The id or relative path to the Resource Item to find (required)
     * @param  bool $include_sub_folders If true, search will include subfolders (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiResourceItemGetByIdOrPathRequest($resource_name, $item_id_or_path, $include_sub_folders = null)
    {
        // verify the required parameter 'resource_name' is set
        if ($resource_name === null || (is_array($resource_name) && count($resource_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource_name when calling restApiResourceItemGetByIdOrPath'
            );
        }
        // verify the required parameter 'item_id_or_path' is set
        if ($item_id_or_path === null || (is_array($item_id_or_path) && count($item_id_or_path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id_or_path when calling restApiResourceItemGetByIdOrPath'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/{resourceName}/items';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($item_id_or_path !== null) {
            $queryParams['itemIdOrPath'] = ObjectSerializer::toQueryValue($item_id_or_path);
        }
        // query params
        if ($include_sub_folders !== null) {
            $queryParams['includeSubFolders'] = ObjectSerializer::toQueryValue($include_sub_folders);
        }

        // path params
        if ($resource_name !== null) {
            $resourcePath = str_replace(
                '{' . 'resourceName' . '}',
                ObjectSerializer::toPathValue($resource_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiResourceItemGetByName
     *
     * ResourceItemGetByName
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_name The name of the Resource Item to find (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiResourceItemGetByName($resource_name, $item_name)
    {
        list($response) = $this->restApiResourceItemGetByNameWithHttpInfo($resource_name, $item_name);
        return $response;
    }

    /**
     * Operation restApiResourceItemGetByNameWithHttpInfo
     *
     * ResourceItemGetByName
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_name The name of the Resource Item to find (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiResourceItemGetByNameWithHttpInfo($resource_name, $item_name)
    {
        $returnType = 'object';
        $request = $this->restApiResourceItemGetByNameRequest($resource_name, $item_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiResourceItemGetByNameAsync
     *
     * ResourceItemGetByName
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_name The name of the Resource Item to find (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceItemGetByNameAsync($resource_name, $item_name)
    {
        return $this->restApiResourceItemGetByNameAsyncWithHttpInfo($resource_name, $item_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiResourceItemGetByNameAsyncWithHttpInfo
     *
     * ResourceItemGetByName
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_name The name of the Resource Item to find (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceItemGetByNameAsyncWithHttpInfo($resource_name, $item_name)
    {
        $returnType = 'object';
        $request = $this->restApiResourceItemGetByNameRequest($resource_name, $item_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiResourceItemGetByName'
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_name The name of the Resource Item to find (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiResourceItemGetByNameRequest($resource_name, $item_name)
    {
        // verify the required parameter 'resource_name' is set
        if ($resource_name === null || (is_array($resource_name) && count($resource_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource_name when calling restApiResourceItemGetByName'
            );
        }
        // verify the required parameter 'item_name' is set
        if ($item_name === null || (is_array($item_name) && count($item_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_name when calling restApiResourceItemGetByName'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/{resourceName}/items/byname';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($item_name !== null) {
            $queryParams['itemName'] = ObjectSerializer::toQueryValue($item_name);
        }

        // path params
        if ($resource_name !== null) {
            $resourcePath = str_replace(
                '{' . 'resourceName' . '}',
                ObjectSerializer::toPathValue($resource_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiResourceItemGetByPath
     *
     * ResourceItemGetByPath
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_path The relative path to the Resource Item to find (required)
     * @param  bool $include_sub_folders If true, search will include subfolders (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiResourceItemGetByPath($resource_name, $item_path, $include_sub_folders = null)
    {
        list($response) = $this->restApiResourceItemGetByPathWithHttpInfo($resource_name, $item_path, $include_sub_folders);
        return $response;
    }

    /**
     * Operation restApiResourceItemGetByPathWithHttpInfo
     *
     * ResourceItemGetByPath
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_path The relative path to the Resource Item to find (required)
     * @param  bool $include_sub_folders If true, search will include subfolders (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiResourceItemGetByPathWithHttpInfo($resource_name, $item_path, $include_sub_folders = null)
    {
        $returnType = 'object';
        $request = $this->restApiResourceItemGetByPathRequest($resource_name, $item_path, $include_sub_folders);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiResourceItemGetByPathAsync
     *
     * ResourceItemGetByPath
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_path The relative path to the Resource Item to find (required)
     * @param  bool $include_sub_folders If true, search will include subfolders (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceItemGetByPathAsync($resource_name, $item_path, $include_sub_folders = null)
    {
        return $this->restApiResourceItemGetByPathAsyncWithHttpInfo($resource_name, $item_path, $include_sub_folders)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiResourceItemGetByPathAsyncWithHttpInfo
     *
     * ResourceItemGetByPath
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_path The relative path to the Resource Item to find (required)
     * @param  bool $include_sub_folders If true, search will include subfolders (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceItemGetByPathAsyncWithHttpInfo($resource_name, $item_path, $include_sub_folders = null)
    {
        $returnType = 'object';
        $request = $this->restApiResourceItemGetByPathRequest($resource_name, $item_path, $include_sub_folders);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiResourceItemGetByPath'
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_path The relative path to the Resource Item to find (required)
     * @param  bool $include_sub_folders If true, search will include subfolders (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiResourceItemGetByPathRequest($resource_name, $item_path, $include_sub_folders = null)
    {
        // verify the required parameter 'resource_name' is set
        if ($resource_name === null || (is_array($resource_name) && count($resource_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource_name when calling restApiResourceItemGetByPath'
            );
        }
        // verify the required parameter 'item_path' is set
        if ($item_path === null || (is_array($item_path) && count($item_path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_path when calling restApiResourceItemGetByPath'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/{resourceName}/items/bypath';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($item_path !== null) {
            $queryParams['itemPath'] = ObjectSerializer::toQueryValue($item_path);
        }
        // query params
        if ($include_sub_folders !== null) {
            $queryParams['includeSubFolders'] = ObjectSerializer::toQueryValue($include_sub_folders);
        }

        // path params
        if ($resource_name !== null) {
            $resourcePath = str_replace(
                '{' . 'resourceName' . '}',
                ObjectSerializer::toPathValue($resource_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiResourceItemGetCacheInfo
     *
     * ResourceItemGetCacheInfo
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_id The ID of the resource item (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiResourceItemGetCacheInfo($resource_name, $item_id)
    {
        list($response) = $this->restApiResourceItemGetCacheInfoWithHttpInfo($resource_name, $item_id);
        return $response;
    }

    /**
     * Operation restApiResourceItemGetCacheInfoWithHttpInfo
     *
     * ResourceItemGetCacheInfo
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_id The ID of the resource item (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiResourceItemGetCacheInfoWithHttpInfo($resource_name, $item_id)
    {
        $returnType = 'object';
        $request = $this->restApiResourceItemGetCacheInfoRequest($resource_name, $item_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiResourceItemGetCacheInfoAsync
     *
     * ResourceItemGetCacheInfo
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_id The ID of the resource item (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceItemGetCacheInfoAsync($resource_name, $item_id)
    {
        return $this->restApiResourceItemGetCacheInfoAsyncWithHttpInfo($resource_name, $item_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiResourceItemGetCacheInfoAsyncWithHttpInfo
     *
     * ResourceItemGetCacheInfo
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_id The ID of the resource item (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceItemGetCacheInfoAsyncWithHttpInfo($resource_name, $item_id)
    {
        $returnType = 'object';
        $request = $this->restApiResourceItemGetCacheInfoRequest($resource_name, $item_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiResourceItemGetCacheInfo'
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_id The ID of the resource item (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiResourceItemGetCacheInfoRequest($resource_name, $item_id)
    {
        // verify the required parameter 'resource_name' is set
        if ($resource_name === null || (is_array($resource_name) && count($resource_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource_name when calling restApiResourceItemGetCacheInfo'
            );
        }
        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling restApiResourceItemGetCacheInfo'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/{resourceName}/items/{itemID}/cacheinfo';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($resource_name !== null) {
            $resourcePath = str_replace(
                '{' . 'resourceName' . '}',
                ObjectSerializer::toPathValue($resource_name),
                $resourcePath
            );
        }
        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemID' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiResourceItemGetCustomMetaData
     *
     * ResourceItemGetCustomMetaData
     *
     * @param  string $resource_name  (required)
     * @param  string $id  (required)
     * @param  string $set_name  (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiResourceItemGetCustomMetaData($resource_name, $id, $set_name)
    {
        list($response) = $this->restApiResourceItemGetCustomMetaDataWithHttpInfo($resource_name, $id, $set_name);
        return $response;
    }

    /**
     * Operation restApiResourceItemGetCustomMetaDataWithHttpInfo
     *
     * ResourceItemGetCustomMetaData
     *
     * @param  string $resource_name  (required)
     * @param  string $id  (required)
     * @param  string $set_name  (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiResourceItemGetCustomMetaDataWithHttpInfo($resource_name, $id, $set_name)
    {
        $returnType = 'object';
        $request = $this->restApiResourceItemGetCustomMetaDataRequest($resource_name, $id, $set_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiResourceItemGetCustomMetaDataAsync
     *
     * ResourceItemGetCustomMetaData
     *
     * @param  string $resource_name  (required)
     * @param  string $id  (required)
     * @param  string $set_name  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceItemGetCustomMetaDataAsync($resource_name, $id, $set_name)
    {
        return $this->restApiResourceItemGetCustomMetaDataAsyncWithHttpInfo($resource_name, $id, $set_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiResourceItemGetCustomMetaDataAsyncWithHttpInfo
     *
     * ResourceItemGetCustomMetaData
     *
     * @param  string $resource_name  (required)
     * @param  string $id  (required)
     * @param  string $set_name  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceItemGetCustomMetaDataAsyncWithHttpInfo($resource_name, $id, $set_name)
    {
        $returnType = 'object';
        $request = $this->restApiResourceItemGetCustomMetaDataRequest($resource_name, $id, $set_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiResourceItemGetCustomMetaData'
     *
     * @param  string $resource_name  (required)
     * @param  string $id  (required)
     * @param  string $set_name  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiResourceItemGetCustomMetaDataRequest($resource_name, $id, $set_name)
    {
        // verify the required parameter 'resource_name' is set
        if ($resource_name === null || (is_array($resource_name) && count($resource_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource_name when calling restApiResourceItemGetCustomMetaData'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restApiResourceItemGetCustomMetaData'
            );
        }
        // verify the required parameter 'set_name' is set
        if ($set_name === null || (is_array($set_name) && count($set_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $set_name when calling restApiResourceItemGetCustomMetaData'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/{resourceName}/items/{id}/metadata';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($set_name !== null) {
            $queryParams['setName'] = ObjectSerializer::toQueryValue($set_name);
        }

        // path params
        if ($resource_name !== null) {
            $resourcePath = str_replace(
                '{' . 'resourceName' . '}',
                ObjectSerializer::toPathValue($resource_name),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiResourceItemGetDefinitionXML
     *
     * ResourceItemGetDefinitionXML
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiResourceItemGetDefinitionXML($resource_name, $item_id)
    {
        list($response) = $this->restApiResourceItemGetDefinitionXMLWithHttpInfo($resource_name, $item_id);
        return $response;
    }

    /**
     * Operation restApiResourceItemGetDefinitionXMLWithHttpInfo
     *
     * ResourceItemGetDefinitionXML
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiResourceItemGetDefinitionXMLWithHttpInfo($resource_name, $item_id)
    {
        $returnType = 'object';
        $request = $this->restApiResourceItemGetDefinitionXMLRequest($resource_name, $item_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiResourceItemGetDefinitionXMLAsync
     *
     * ResourceItemGetDefinitionXML
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceItemGetDefinitionXMLAsync($resource_name, $item_id)
    {
        return $this->restApiResourceItemGetDefinitionXMLAsyncWithHttpInfo($resource_name, $item_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiResourceItemGetDefinitionXMLAsyncWithHttpInfo
     *
     * ResourceItemGetDefinitionXML
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceItemGetDefinitionXMLAsyncWithHttpInfo($resource_name, $item_id)
    {
        $returnType = 'object';
        $request = $this->restApiResourceItemGetDefinitionXMLRequest($resource_name, $item_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiResourceItemGetDefinitionXML'
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiResourceItemGetDefinitionXMLRequest($resource_name, $item_id)
    {
        // verify the required parameter 'resource_name' is set
        if ($resource_name === null || (is_array($resource_name) && count($resource_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource_name when calling restApiResourceItemGetDefinitionXML'
            );
        }
        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling restApiResourceItemGetDefinitionXML'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/{resourceName}/items/{itemID}/definitionxml';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($resource_name !== null) {
            $resourcePath = str_replace(
                '{' . 'resourceName' . '}',
                ObjectSerializer::toPathValue($resource_name),
                $resourcePath
            );
        }
        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemID' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiResourceItemGetHistory
     *
     * ResourceItemGetHistory
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiResourceItemGetHistory($resource_name, $item_id)
    {
        list($response) = $this->restApiResourceItemGetHistoryWithHttpInfo($resource_name, $item_id);
        return $response;
    }

    /**
     * Operation restApiResourceItemGetHistoryWithHttpInfo
     *
     * ResourceItemGetHistory
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiResourceItemGetHistoryWithHttpInfo($resource_name, $item_id)
    {
        $returnType = 'object';
        $request = $this->restApiResourceItemGetHistoryRequest($resource_name, $item_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiResourceItemGetHistoryAsync
     *
     * ResourceItemGetHistory
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceItemGetHistoryAsync($resource_name, $item_id)
    {
        return $this->restApiResourceItemGetHistoryAsyncWithHttpInfo($resource_name, $item_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiResourceItemGetHistoryAsyncWithHttpInfo
     *
     * ResourceItemGetHistory
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceItemGetHistoryAsyncWithHttpInfo($resource_name, $item_id)
    {
        $returnType = 'object';
        $request = $this->restApiResourceItemGetHistoryRequest($resource_name, $item_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiResourceItemGetHistory'
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiResourceItemGetHistoryRequest($resource_name, $item_id)
    {
        // verify the required parameter 'resource_name' is set
        if ($resource_name === null || (is_array($resource_name) && count($resource_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource_name when calling restApiResourceItemGetHistory'
            );
        }
        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling restApiResourceItemGetHistory'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/{resourceName}/items/{itemID}/history';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($resource_name !== null) {
            $resourcePath = str_replace(
                '{' . 'resourceName' . '}',
                ObjectSerializer::toPathValue($resource_name),
                $resourcePath
            );
        }
        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemID' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiResourceItemGetPrivateInfo
     *
     * ResourceItemGetPrivateInfo
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_id The ID of the resource item (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiResourceItemGetPrivateInfo($resource_name, $item_id)
    {
        list($response) = $this->restApiResourceItemGetPrivateInfoWithHttpInfo($resource_name, $item_id);
        return $response;
    }

    /**
     * Operation restApiResourceItemGetPrivateInfoWithHttpInfo
     *
     * ResourceItemGetPrivateInfo
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_id The ID of the resource item (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiResourceItemGetPrivateInfoWithHttpInfo($resource_name, $item_id)
    {
        $returnType = 'object';
        $request = $this->restApiResourceItemGetPrivateInfoRequest($resource_name, $item_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiResourceItemGetPrivateInfoAsync
     *
     * ResourceItemGetPrivateInfo
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_id The ID of the resource item (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceItemGetPrivateInfoAsync($resource_name, $item_id)
    {
        return $this->restApiResourceItemGetPrivateInfoAsyncWithHttpInfo($resource_name, $item_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiResourceItemGetPrivateInfoAsyncWithHttpInfo
     *
     * ResourceItemGetPrivateInfo
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_id The ID of the resource item (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceItemGetPrivateInfoAsyncWithHttpInfo($resource_name, $item_id)
    {
        $returnType = 'object';
        $request = $this->restApiResourceItemGetPrivateInfoRequest($resource_name, $item_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiResourceItemGetPrivateInfo'
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_id The ID of the resource item (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiResourceItemGetPrivateInfoRequest($resource_name, $item_id)
    {
        // verify the required parameter 'resource_name' is set
        if ($resource_name === null || (is_array($resource_name) && count($resource_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource_name when calling restApiResourceItemGetPrivateInfo'
            );
        }
        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling restApiResourceItemGetPrivateInfo'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/{resourceName}/items/{itemID}/privateinfo';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($resource_name !== null) {
            $resourcePath = str_replace(
                '{' . 'resourceName' . '}',
                ObjectSerializer::toPathValue($resource_name),
                $resourcePath
            );
        }
        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemID' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiResourceItemGetTransformedURL
     *
     * ResourceItemGetTransformedURL
     *
     * @param  string $resource_name The name of the Resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     * @param  string $type The type of URL (required)
     * @param  string $transformation_id  (optional)
     * @param  int $page_num The page number (1-based) (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiResourceItemGetTransformedURL($resource_name, $item_id, $type, $transformation_id = null, $page_num = null)
    {
        list($response) = $this->restApiResourceItemGetTransformedURLWithHttpInfo($resource_name, $item_id, $type, $transformation_id, $page_num);
        return $response;
    }

    /**
     * Operation restApiResourceItemGetTransformedURLWithHttpInfo
     *
     * ResourceItemGetTransformedURL
     *
     * @param  string $resource_name The name of the Resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     * @param  string $type The type of URL (required)
     * @param  string $transformation_id  (optional)
     * @param  int $page_num The page number (1-based) (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiResourceItemGetTransformedURLWithHttpInfo($resource_name, $item_id, $type, $transformation_id = null, $page_num = null)
    {
        $returnType = 'object';
        $request = $this->restApiResourceItemGetTransformedURLRequest($resource_name, $item_id, $type, $transformation_id, $page_num);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiResourceItemGetTransformedURLAsync
     *
     * ResourceItemGetTransformedURL
     *
     * @param  string $resource_name The name of the Resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     * @param  string $type The type of URL (required)
     * @param  string $transformation_id  (optional)
     * @param  int $page_num The page number (1-based) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceItemGetTransformedURLAsync($resource_name, $item_id, $type, $transformation_id = null, $page_num = null)
    {
        return $this->restApiResourceItemGetTransformedURLAsyncWithHttpInfo($resource_name, $item_id, $type, $transformation_id, $page_num)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiResourceItemGetTransformedURLAsyncWithHttpInfo
     *
     * ResourceItemGetTransformedURL
     *
     * @param  string $resource_name The name of the Resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     * @param  string $type The type of URL (required)
     * @param  string $transformation_id  (optional)
     * @param  int $page_num The page number (1-based) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceItemGetTransformedURLAsyncWithHttpInfo($resource_name, $item_id, $type, $transformation_id = null, $page_num = null)
    {
        $returnType = 'object';
        $request = $this->restApiResourceItemGetTransformedURLRequest($resource_name, $item_id, $type, $transformation_id, $page_num);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiResourceItemGetTransformedURL'
     *
     * @param  string $resource_name The name of the Resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     * @param  string $type The type of URL (required)
     * @param  string $transformation_id  (optional)
     * @param  int $page_num The page number (1-based) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiResourceItemGetTransformedURLRequest($resource_name, $item_id, $type, $transformation_id = null, $page_num = null)
    {
        // verify the required parameter 'resource_name' is set
        if ($resource_name === null || (is_array($resource_name) && count($resource_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource_name when calling restApiResourceItemGetTransformedURL'
            );
        }
        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling restApiResourceItemGetTransformedURL'
            );
        }
        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling restApiResourceItemGetTransformedURL'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/{resourceName}/items/{itemID}/transformedurl';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }
        // query params
        if ($transformation_id !== null) {
            $queryParams['transformationID'] = ObjectSerializer::toQueryValue($transformation_id);
        }
        // query params
        if ($page_num !== null) {
            $queryParams['pageNum'] = ObjectSerializer::toQueryValue($page_num);
        }

        // path params
        if ($resource_name !== null) {
            $resourcePath = str_replace(
                '{' . 'resourceName' . '}',
                ObjectSerializer::toPathValue($resource_name),
                $resourcePath
            );
        }
        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemID' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiResourceItemGetTransformedURLWithDebugInfo
     *
     * ResourceItemGetTransformedURLWithDebugInfo
     *
     * @param  string $resource_name The name of the Resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     * @param  string $type The type of URL (required)
     * @param  string $transformation_id  (optional)
     * @param  int $page_num The page number (1-based) (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiResourceItemGetTransformedURLWithDebugInfo($resource_name, $item_id, $type, $transformation_id = null, $page_num = null)
    {
        list($response) = $this->restApiResourceItemGetTransformedURLWithDebugInfoWithHttpInfo($resource_name, $item_id, $type, $transformation_id, $page_num);
        return $response;
    }

    /**
     * Operation restApiResourceItemGetTransformedURLWithDebugInfoWithHttpInfo
     *
     * ResourceItemGetTransformedURLWithDebugInfo
     *
     * @param  string $resource_name The name of the Resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     * @param  string $type The type of URL (required)
     * @param  string $transformation_id  (optional)
     * @param  int $page_num The page number (1-based) (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiResourceItemGetTransformedURLWithDebugInfoWithHttpInfo($resource_name, $item_id, $type, $transformation_id = null, $page_num = null)
    {
        $returnType = 'object';
        $request = $this->restApiResourceItemGetTransformedURLWithDebugInfoRequest($resource_name, $item_id, $type, $transformation_id, $page_num);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiResourceItemGetTransformedURLWithDebugInfoAsync
     *
     * ResourceItemGetTransformedURLWithDebugInfo
     *
     * @param  string $resource_name The name of the Resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     * @param  string $type The type of URL (required)
     * @param  string $transformation_id  (optional)
     * @param  int $page_num The page number (1-based) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceItemGetTransformedURLWithDebugInfoAsync($resource_name, $item_id, $type, $transformation_id = null, $page_num = null)
    {
        return $this->restApiResourceItemGetTransformedURLWithDebugInfoAsyncWithHttpInfo($resource_name, $item_id, $type, $transformation_id, $page_num)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiResourceItemGetTransformedURLWithDebugInfoAsyncWithHttpInfo
     *
     * ResourceItemGetTransformedURLWithDebugInfo
     *
     * @param  string $resource_name The name of the Resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     * @param  string $type The type of URL (required)
     * @param  string $transformation_id  (optional)
     * @param  int $page_num The page number (1-based) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceItemGetTransformedURLWithDebugInfoAsyncWithHttpInfo($resource_name, $item_id, $type, $transformation_id = null, $page_num = null)
    {
        $returnType = 'object';
        $request = $this->restApiResourceItemGetTransformedURLWithDebugInfoRequest($resource_name, $item_id, $type, $transformation_id, $page_num);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiResourceItemGetTransformedURLWithDebugInfo'
     *
     * @param  string $resource_name The name of the Resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     * @param  string $type The type of URL (required)
     * @param  string $transformation_id  (optional)
     * @param  int $page_num The page number (1-based) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiResourceItemGetTransformedURLWithDebugInfoRequest($resource_name, $item_id, $type, $transformation_id = null, $page_num = null)
    {
        // verify the required parameter 'resource_name' is set
        if ($resource_name === null || (is_array($resource_name) && count($resource_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource_name when calling restApiResourceItemGetTransformedURLWithDebugInfo'
            );
        }
        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling restApiResourceItemGetTransformedURLWithDebugInfo'
            );
        }
        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling restApiResourceItemGetTransformedURLWithDebugInfo'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/{resourceName}/items/{itemID}/transformedurldebug';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }
        // query params
        if ($transformation_id !== null) {
            $queryParams['transformationID'] = ObjectSerializer::toQueryValue($transformation_id);
        }
        // query params
        if ($page_num !== null) {
            $queryParams['pageNum'] = ObjectSerializer::toQueryValue($page_num);
        }

        // path params
        if ($resource_name !== null) {
            $resourcePath = str_replace(
                '{' . 'resourceName' . '}',
                ObjectSerializer::toPathValue($resource_name),
                $resourcePath
            );
        }
        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemID' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiResourceItemGetURL
     *
     * ResourceItemGetURL
     *
     * @param  string $resource_name The name of the Resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     * @param  string $type The type of URL (required)
     * @param  int $page_num The page number (1-based) (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiResourceItemGetURL($resource_name, $item_id, $type, $page_num = null)
    {
        list($response) = $this->restApiResourceItemGetURLWithHttpInfo($resource_name, $item_id, $type, $page_num);
        return $response;
    }

    /**
     * Operation restApiResourceItemGetURLWithHttpInfo
     *
     * ResourceItemGetURL
     *
     * @param  string $resource_name The name of the Resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     * @param  string $type The type of URL (required)
     * @param  int $page_num The page number (1-based) (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiResourceItemGetURLWithHttpInfo($resource_name, $item_id, $type, $page_num = null)
    {
        $returnType = 'object';
        $request = $this->restApiResourceItemGetURLRequest($resource_name, $item_id, $type, $page_num);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiResourceItemGetURLAsync
     *
     * ResourceItemGetURL
     *
     * @param  string $resource_name The name of the Resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     * @param  string $type The type of URL (required)
     * @param  int $page_num The page number (1-based) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceItemGetURLAsync($resource_name, $item_id, $type, $page_num = null)
    {
        return $this->restApiResourceItemGetURLAsyncWithHttpInfo($resource_name, $item_id, $type, $page_num)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiResourceItemGetURLAsyncWithHttpInfo
     *
     * ResourceItemGetURL
     *
     * @param  string $resource_name The name of the Resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     * @param  string $type The type of URL (required)
     * @param  int $page_num The page number (1-based) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceItemGetURLAsyncWithHttpInfo($resource_name, $item_id, $type, $page_num = null)
    {
        $returnType = 'object';
        $request = $this->restApiResourceItemGetURLRequest($resource_name, $item_id, $type, $page_num);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiResourceItemGetURL'
     *
     * @param  string $resource_name The name of the Resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     * @param  string $type The type of URL (required)
     * @param  int $page_num The page number (1-based) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiResourceItemGetURLRequest($resource_name, $item_id, $type, $page_num = null)
    {
        // verify the required parameter 'resource_name' is set
        if ($resource_name === null || (is_array($resource_name) && count($resource_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource_name when calling restApiResourceItemGetURL'
            );
        }
        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling restApiResourceItemGetURL'
            );
        }
        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling restApiResourceItemGetURL'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/{resourceName}/items/{itemID}/url';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }
        // query params
        if ($page_num !== null) {
            $queryParams['pageNum'] = ObjectSerializer::toQueryValue($page_num);
        }

        // path params
        if ($resource_name !== null) {
            $resourcePath = str_replace(
                '{' . 'resourceName' . '}',
                ObjectSerializer::toPathValue($resource_name),
                $resourcePath
            );
        }
        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemID' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiResourceItemGetURLForAnonymousUser
     *
     * ResourceItemGetURLForAnonymousUser
     *
     * @param  string $resource_name The name of the Resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     * @param  string $type The type of preview (required)
     * @param  int $page_num The page number (1-based) (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiResourceItemGetURLForAnonymousUser($resource_name, $item_id, $type, $page_num = null)
    {
        list($response) = $this->restApiResourceItemGetURLForAnonymousUserWithHttpInfo($resource_name, $item_id, $type, $page_num);
        return $response;
    }

    /**
     * Operation restApiResourceItemGetURLForAnonymousUserWithHttpInfo
     *
     * ResourceItemGetURLForAnonymousUser
     *
     * @param  string $resource_name The name of the Resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     * @param  string $type The type of preview (required)
     * @param  int $page_num The page number (1-based) (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiResourceItemGetURLForAnonymousUserWithHttpInfo($resource_name, $item_id, $type, $page_num = null)
    {
        $returnType = 'object';
        $request = $this->restApiResourceItemGetURLForAnonymousUserRequest($resource_name, $item_id, $type, $page_num);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiResourceItemGetURLForAnonymousUserAsync
     *
     * ResourceItemGetURLForAnonymousUser
     *
     * @param  string $resource_name The name of the Resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     * @param  string $type The type of preview (required)
     * @param  int $page_num The page number (1-based) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceItemGetURLForAnonymousUserAsync($resource_name, $item_id, $type, $page_num = null)
    {
        return $this->restApiResourceItemGetURLForAnonymousUserAsyncWithHttpInfo($resource_name, $item_id, $type, $page_num)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiResourceItemGetURLForAnonymousUserAsyncWithHttpInfo
     *
     * ResourceItemGetURLForAnonymousUser
     *
     * @param  string $resource_name The name of the Resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     * @param  string $type The type of preview (required)
     * @param  int $page_num The page number (1-based) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceItemGetURLForAnonymousUserAsyncWithHttpInfo($resource_name, $item_id, $type, $page_num = null)
    {
        $returnType = 'object';
        $request = $this->restApiResourceItemGetURLForAnonymousUserRequest($resource_name, $item_id, $type, $page_num);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiResourceItemGetURLForAnonymousUser'
     *
     * @param  string $resource_name The name of the Resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     * @param  string $type The type of preview (required)
     * @param  int $page_num The page number (1-based) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiResourceItemGetURLForAnonymousUserRequest($resource_name, $item_id, $type, $page_num = null)
    {
        // verify the required parameter 'resource_name' is set
        if ($resource_name === null || (is_array($resource_name) && count($resource_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource_name when calling restApiResourceItemGetURLForAnonymousUser'
            );
        }
        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling restApiResourceItemGetURLForAnonymousUser'
            );
        }
        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling restApiResourceItemGetURLForAnonymousUser'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/{resourceName}/items/{itemID}/anonymousurl';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }
        // query params
        if ($page_num !== null) {
            $queryParams['pageNum'] = ObjectSerializer::toQueryValue($page_num);
        }

        // path params
        if ($resource_name !== null) {
            $resourcePath = str_replace(
                '{' . 'resourceName' . '}',
                ObjectSerializer::toPathValue($resource_name),
                $resourcePath
            );
        }
        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemID' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiResourceItemGetURLWithDebugInfo
     *
     * ResourceItemGetURLWithDebugInfo
     *
     * @param  string $resource_name The name of the Resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     * @param  string $type The type of URL (required)
     * @param  int $page_num The page number (1-based) (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiResourceItemGetURLWithDebugInfo($resource_name, $item_id, $type, $page_num = null)
    {
        list($response) = $this->restApiResourceItemGetURLWithDebugInfoWithHttpInfo($resource_name, $item_id, $type, $page_num);
        return $response;
    }

    /**
     * Operation restApiResourceItemGetURLWithDebugInfoWithHttpInfo
     *
     * ResourceItemGetURLWithDebugInfo
     *
     * @param  string $resource_name The name of the Resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     * @param  string $type The type of URL (required)
     * @param  int $page_num The page number (1-based) (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiResourceItemGetURLWithDebugInfoWithHttpInfo($resource_name, $item_id, $type, $page_num = null)
    {
        $returnType = 'object';
        $request = $this->restApiResourceItemGetURLWithDebugInfoRequest($resource_name, $item_id, $type, $page_num);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiResourceItemGetURLWithDebugInfoAsync
     *
     * ResourceItemGetURLWithDebugInfo
     *
     * @param  string $resource_name The name of the Resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     * @param  string $type The type of URL (required)
     * @param  int $page_num The page number (1-based) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceItemGetURLWithDebugInfoAsync($resource_name, $item_id, $type, $page_num = null)
    {
        return $this->restApiResourceItemGetURLWithDebugInfoAsyncWithHttpInfo($resource_name, $item_id, $type, $page_num)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiResourceItemGetURLWithDebugInfoAsyncWithHttpInfo
     *
     * ResourceItemGetURLWithDebugInfo
     *
     * @param  string $resource_name The name of the Resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     * @param  string $type The type of URL (required)
     * @param  int $page_num The page number (1-based) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceItemGetURLWithDebugInfoAsyncWithHttpInfo($resource_name, $item_id, $type, $page_num = null)
    {
        $returnType = 'object';
        $request = $this->restApiResourceItemGetURLWithDebugInfoRequest($resource_name, $item_id, $type, $page_num);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiResourceItemGetURLWithDebugInfo'
     *
     * @param  string $resource_name The name of the Resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     * @param  string $type The type of URL (required)
     * @param  int $page_num The page number (1-based) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiResourceItemGetURLWithDebugInfoRequest($resource_name, $item_id, $type, $page_num = null)
    {
        // verify the required parameter 'resource_name' is set
        if ($resource_name === null || (is_array($resource_name) && count($resource_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource_name when calling restApiResourceItemGetURLWithDebugInfo'
            );
        }
        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling restApiResourceItemGetURLWithDebugInfo'
            );
        }
        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling restApiResourceItemGetURLWithDebugInfo'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/{resourceName}/items/{itemID}/debugurl';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }
        // query params
        if ($page_num !== null) {
            $queryParams['pageNum'] = ObjectSerializer::toQueryValue($page_num);
        }

        // path params
        if ($resource_name !== null) {
            $resourcePath = str_replace(
                '{' . 'resourceName' . '}',
                ObjectSerializer::toPathValue($resource_name),
                $resourcePath
            );
        }
        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemID' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiResourceItemGetXML
     *
     * ResourceItemGetXML
     *
     * @param  string $resource_name The name of the Resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiResourceItemGetXML($resource_name, $item_id)
    {
        list($response) = $this->restApiResourceItemGetXMLWithHttpInfo($resource_name, $item_id);
        return $response;
    }

    /**
     * Operation restApiResourceItemGetXMLWithHttpInfo
     *
     * ResourceItemGetXML
     *
     * @param  string $resource_name The name of the Resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiResourceItemGetXMLWithHttpInfo($resource_name, $item_id)
    {
        $returnType = 'object';
        $request = $this->restApiResourceItemGetXMLRequest($resource_name, $item_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiResourceItemGetXMLAsync
     *
     * ResourceItemGetXML
     *
     * @param  string $resource_name The name of the Resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceItemGetXMLAsync($resource_name, $item_id)
    {
        return $this->restApiResourceItemGetXMLAsyncWithHttpInfo($resource_name, $item_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiResourceItemGetXMLAsyncWithHttpInfo
     *
     * ResourceItemGetXML
     *
     * @param  string $resource_name The name of the Resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceItemGetXMLAsyncWithHttpInfo($resource_name, $item_id)
    {
        $returnType = 'object';
        $request = $this->restApiResourceItemGetXMLRequest($resource_name, $item_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiResourceItemGetXML'
     *
     * @param  string $resource_name The name of the Resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiResourceItemGetXMLRequest($resource_name, $item_id)
    {
        // verify the required parameter 'resource_name' is set
        if ($resource_name === null || (is_array($resource_name) && count($resource_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource_name when calling restApiResourceItemGetXML'
            );
        }
        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling restApiResourceItemGetXML'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/{resourceName}/items/{itemID}/xml';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($resource_name !== null) {
            $resourcePath = str_replace(
                '{' . 'resourceName' . '}',
                ObjectSerializer::toPathValue($resource_name),
                $resourcePath
            );
        }
        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemID' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiResourceItemMove
     *
     * ResourceItemMove
     *
     * @param  string $resource_name Name of the Resource in which to find the item (required)
     * @param  string $item_id The ID of the item to move (required)
     * @param  string $new_name The new name for the Resource Item (required)
     * @param  string $new_folder_path The new folder for the resource item (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiResourceItemMove($resource_name, $item_id, $new_name, $new_folder_path)
    {
        list($response) = $this->restApiResourceItemMoveWithHttpInfo($resource_name, $item_id, $new_name, $new_folder_path);
        return $response;
    }

    /**
     * Operation restApiResourceItemMoveWithHttpInfo
     *
     * ResourceItemMove
     *
     * @param  string $resource_name Name of the Resource in which to find the item (required)
     * @param  string $item_id The ID of the item to move (required)
     * @param  string $new_name The new name for the Resource Item (required)
     * @param  string $new_folder_path The new folder for the resource item (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiResourceItemMoveWithHttpInfo($resource_name, $item_id, $new_name, $new_folder_path)
    {
        $returnType = 'object';
        $request = $this->restApiResourceItemMoveRequest($resource_name, $item_id, $new_name, $new_folder_path);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiResourceItemMoveAsync
     *
     * ResourceItemMove
     *
     * @param  string $resource_name Name of the Resource in which to find the item (required)
     * @param  string $item_id The ID of the item to move (required)
     * @param  string $new_name The new name for the Resource Item (required)
     * @param  string $new_folder_path The new folder for the resource item (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceItemMoveAsync($resource_name, $item_id, $new_name, $new_folder_path)
    {
        return $this->restApiResourceItemMoveAsyncWithHttpInfo($resource_name, $item_id, $new_name, $new_folder_path)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiResourceItemMoveAsyncWithHttpInfo
     *
     * ResourceItemMove
     *
     * @param  string $resource_name Name of the Resource in which to find the item (required)
     * @param  string $item_id The ID of the item to move (required)
     * @param  string $new_name The new name for the Resource Item (required)
     * @param  string $new_folder_path The new folder for the resource item (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceItemMoveAsyncWithHttpInfo($resource_name, $item_id, $new_name, $new_folder_path)
    {
        $returnType = 'object';
        $request = $this->restApiResourceItemMoveRequest($resource_name, $item_id, $new_name, $new_folder_path);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiResourceItemMove'
     *
     * @param  string $resource_name Name of the Resource in which to find the item (required)
     * @param  string $item_id The ID of the item to move (required)
     * @param  string $new_name The new name for the Resource Item (required)
     * @param  string $new_folder_path The new folder for the resource item (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiResourceItemMoveRequest($resource_name, $item_id, $new_name, $new_folder_path)
    {
        // verify the required parameter 'resource_name' is set
        if ($resource_name === null || (is_array($resource_name) && count($resource_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource_name when calling restApiResourceItemMove'
            );
        }
        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling restApiResourceItemMove'
            );
        }
        // verify the required parameter 'new_name' is set
        if ($new_name === null || (is_array($new_name) && count($new_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $new_name when calling restApiResourceItemMove'
            );
        }
        // verify the required parameter 'new_folder_path' is set
        if ($new_folder_path === null || (is_array($new_folder_path) && count($new_folder_path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $new_folder_path when calling restApiResourceItemMove'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/{resourceName}/items/{itemID}/move';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($new_name !== null) {
            $queryParams['newName'] = ObjectSerializer::toQueryValue($new_name);
        }
        // query params
        if ($new_folder_path !== null) {
            $queryParams['newFolderPath'] = ObjectSerializer::toQueryValue($new_folder_path);
        }

        // path params
        if ($resource_name !== null) {
            $resourcePath = str_replace(
                '{' . 'resourceName' . '}',
                ObjectSerializer::toPathValue($resource_name),
                $resourcePath
            );
        }
        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemID' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiResourceItemRemovePreviewOverride
     *
     * ResourceItemRemovePreviewOverride
     *
     * @param  string $resource_name The name of the Resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiResourceItemRemovePreviewOverride($resource_name, $item_id)
    {
        list($response) = $this->restApiResourceItemRemovePreviewOverrideWithHttpInfo($resource_name, $item_id);
        return $response;
    }

    /**
     * Operation restApiResourceItemRemovePreviewOverrideWithHttpInfo
     *
     * ResourceItemRemovePreviewOverride
     *
     * @param  string $resource_name The name of the Resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiResourceItemRemovePreviewOverrideWithHttpInfo($resource_name, $item_id)
    {
        $returnType = 'object';
        $request = $this->restApiResourceItemRemovePreviewOverrideRequest($resource_name, $item_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiResourceItemRemovePreviewOverrideAsync
     *
     * ResourceItemRemovePreviewOverride
     *
     * @param  string $resource_name The name of the Resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceItemRemovePreviewOverrideAsync($resource_name, $item_id)
    {
        return $this->restApiResourceItemRemovePreviewOverrideAsyncWithHttpInfo($resource_name, $item_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiResourceItemRemovePreviewOverrideAsyncWithHttpInfo
     *
     * ResourceItemRemovePreviewOverride
     *
     * @param  string $resource_name The name of the Resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceItemRemovePreviewOverrideAsyncWithHttpInfo($resource_name, $item_id)
    {
        $returnType = 'object';
        $request = $this->restApiResourceItemRemovePreviewOverrideRequest($resource_name, $item_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiResourceItemRemovePreviewOverride'
     *
     * @param  string $resource_name The name of the Resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiResourceItemRemovePreviewOverrideRequest($resource_name, $item_id)
    {
        // verify the required parameter 'resource_name' is set
        if ($resource_name === null || (is_array($resource_name) && count($resource_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource_name when calling restApiResourceItemRemovePreviewOverride'
            );
        }
        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling restApiResourceItemRemovePreviewOverride'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/{resourceName}/items/{itemID}/previewoverride';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($resource_name !== null) {
            $resourcePath = str_replace(
                '{' . 'resourceName' . '}',
                ObjectSerializer::toPathValue($resource_name),
                $resourcePath
            );
        }
        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemID' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiResourceItemReplaceFile
     *
     * ResourceItemReplaceFile
     *
     * @param  string $resource_name The name of the Resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     * @param  \Swagger\Client\Model\ResourceItemReplaceFileBodyWrapper $body  (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiResourceItemReplaceFile($resource_name, $item_id, $body)
    {
        list($response) = $this->restApiResourceItemReplaceFileWithHttpInfo($resource_name, $item_id, $body);
        return $response;
    }

    /**
     * Operation restApiResourceItemReplaceFileWithHttpInfo
     *
     * ResourceItemReplaceFile
     *
     * @param  string $resource_name The name of the Resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     * @param  \Swagger\Client\Model\ResourceItemReplaceFileBodyWrapper $body  (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiResourceItemReplaceFileWithHttpInfo($resource_name, $item_id, $body)
    {
        $returnType = 'object';
        $request = $this->restApiResourceItemReplaceFileRequest($resource_name, $item_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiResourceItemReplaceFileAsync
     *
     * ResourceItemReplaceFile
     *
     * @param  string $resource_name The name of the Resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     * @param  \Swagger\Client\Model\ResourceItemReplaceFileBodyWrapper $body  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceItemReplaceFileAsync($resource_name, $item_id, $body)
    {
        return $this->restApiResourceItemReplaceFileAsyncWithHttpInfo($resource_name, $item_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiResourceItemReplaceFileAsyncWithHttpInfo
     *
     * ResourceItemReplaceFile
     *
     * @param  string $resource_name The name of the Resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     * @param  \Swagger\Client\Model\ResourceItemReplaceFileBodyWrapper $body  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceItemReplaceFileAsyncWithHttpInfo($resource_name, $item_id, $body)
    {
        $returnType = 'object';
        $request = $this->restApiResourceItemReplaceFileRequest($resource_name, $item_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiResourceItemReplaceFile'
     *
     * @param  string $resource_name The name of the Resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     * @param  \Swagger\Client\Model\ResourceItemReplaceFileBodyWrapper $body  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiResourceItemReplaceFileRequest($resource_name, $item_id, $body)
    {
        // verify the required parameter 'resource_name' is set
        if ($resource_name === null || (is_array($resource_name) && count($resource_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource_name when calling restApiResourceItemReplaceFile'
            );
        }
        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling restApiResourceItemReplaceFile'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling restApiResourceItemReplaceFile'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/{resourceName}/items/{itemID}/file';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($resource_name !== null) {
            $resourcePath = str_replace(
                '{' . 'resourceName' . '}',
                ObjectSerializer::toPathValue($resource_name),
                $resourcePath
            );
        }
        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemID' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiResourceItemReplaceFileWithPreviewOverride
     *
     * ResourceItemReplaceFileWithPreviewOverride
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     * @param  \Swagger\Client\Model\ResourceItemReplaceFileWithPreviewOverrideBodyWrapper $body  (required)
     * @param  string $preview_extension The extension of the preview file (optional)
     * @param  bool $is_permanent_preview If true, the preview override remains valid after the ResourceItem is modified (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiResourceItemReplaceFileWithPreviewOverride($resource_name, $item_id, $body, $preview_extension = null, $is_permanent_preview = null)
    {
        list($response) = $this->restApiResourceItemReplaceFileWithPreviewOverrideWithHttpInfo($resource_name, $item_id, $body, $preview_extension, $is_permanent_preview);
        return $response;
    }

    /**
     * Operation restApiResourceItemReplaceFileWithPreviewOverrideWithHttpInfo
     *
     * ResourceItemReplaceFileWithPreviewOverride
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     * @param  \Swagger\Client\Model\ResourceItemReplaceFileWithPreviewOverrideBodyWrapper $body  (required)
     * @param  string $preview_extension The extension of the preview file (optional)
     * @param  bool $is_permanent_preview If true, the preview override remains valid after the ResourceItem is modified (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiResourceItemReplaceFileWithPreviewOverrideWithHttpInfo($resource_name, $item_id, $body, $preview_extension = null, $is_permanent_preview = null)
    {
        $returnType = 'object';
        $request = $this->restApiResourceItemReplaceFileWithPreviewOverrideRequest($resource_name, $item_id, $body, $preview_extension, $is_permanent_preview);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiResourceItemReplaceFileWithPreviewOverrideAsync
     *
     * ResourceItemReplaceFileWithPreviewOverride
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     * @param  \Swagger\Client\Model\ResourceItemReplaceFileWithPreviewOverrideBodyWrapper $body  (required)
     * @param  string $preview_extension The extension of the preview file (optional)
     * @param  bool $is_permanent_preview If true, the preview override remains valid after the ResourceItem is modified (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceItemReplaceFileWithPreviewOverrideAsync($resource_name, $item_id, $body, $preview_extension = null, $is_permanent_preview = null)
    {
        return $this->restApiResourceItemReplaceFileWithPreviewOverrideAsyncWithHttpInfo($resource_name, $item_id, $body, $preview_extension, $is_permanent_preview)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiResourceItemReplaceFileWithPreviewOverrideAsyncWithHttpInfo
     *
     * ResourceItemReplaceFileWithPreviewOverride
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     * @param  \Swagger\Client\Model\ResourceItemReplaceFileWithPreviewOverrideBodyWrapper $body  (required)
     * @param  string $preview_extension The extension of the preview file (optional)
     * @param  bool $is_permanent_preview If true, the preview override remains valid after the ResourceItem is modified (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceItemReplaceFileWithPreviewOverrideAsyncWithHttpInfo($resource_name, $item_id, $body, $preview_extension = null, $is_permanent_preview = null)
    {
        $returnType = 'object';
        $request = $this->restApiResourceItemReplaceFileWithPreviewOverrideRequest($resource_name, $item_id, $body, $preview_extension, $is_permanent_preview);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiResourceItemReplaceFileWithPreviewOverride'
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     * @param  \Swagger\Client\Model\ResourceItemReplaceFileWithPreviewOverrideBodyWrapper $body  (required)
     * @param  string $preview_extension The extension of the preview file (optional)
     * @param  bool $is_permanent_preview If true, the preview override remains valid after the ResourceItem is modified (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiResourceItemReplaceFileWithPreviewOverrideRequest($resource_name, $item_id, $body, $preview_extension = null, $is_permanent_preview = null)
    {
        // verify the required parameter 'resource_name' is set
        if ($resource_name === null || (is_array($resource_name) && count($resource_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource_name when calling restApiResourceItemReplaceFileWithPreviewOverride'
            );
        }
        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling restApiResourceItemReplaceFileWithPreviewOverride'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling restApiResourceItemReplaceFileWithPreviewOverride'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/{resourceName}/items/{itemID}/filewithpreview';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($preview_extension !== null) {
            $queryParams['previewExtension'] = ObjectSerializer::toQueryValue($preview_extension);
        }
        // query params
        if ($is_permanent_preview !== null) {
            $queryParams['isPermanentPreview'] = ObjectSerializer::toQueryValue($is_permanent_preview);
        }

        // path params
        if ($resource_name !== null) {
            $resourcePath = str_replace(
                '{' . 'resourceName' . '}',
                ObjectSerializer::toPathValue($resource_name),
                $resourcePath
            );
        }
        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemID' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiResourceItemResetPreviews
     *
     * ResourceItemResetPreviews
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiResourceItemResetPreviews($resource_name, $item_id)
    {
        list($response) = $this->restApiResourceItemResetPreviewsWithHttpInfo($resource_name, $item_id);
        return $response;
    }

    /**
     * Operation restApiResourceItemResetPreviewsWithHttpInfo
     *
     * ResourceItemResetPreviews
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiResourceItemResetPreviewsWithHttpInfo($resource_name, $item_id)
    {
        $returnType = 'object';
        $request = $this->restApiResourceItemResetPreviewsRequest($resource_name, $item_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiResourceItemResetPreviewsAsync
     *
     * ResourceItemResetPreviews
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceItemResetPreviewsAsync($resource_name, $item_id)
    {
        return $this->restApiResourceItemResetPreviewsAsyncWithHttpInfo($resource_name, $item_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiResourceItemResetPreviewsAsyncWithHttpInfo
     *
     * ResourceItemResetPreviews
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceItemResetPreviewsAsyncWithHttpInfo($resource_name, $item_id)
    {
        $returnType = 'object';
        $request = $this->restApiResourceItemResetPreviewsRequest($resource_name, $item_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiResourceItemResetPreviews'
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiResourceItemResetPreviewsRequest($resource_name, $item_id)
    {
        // verify the required parameter 'resource_name' is set
        if ($resource_name === null || (is_array($resource_name) && count($resource_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource_name when calling restApiResourceItemResetPreviews'
            );
        }
        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling restApiResourceItemResetPreviews'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/{resourceName}/items/{itemID}/previews';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($resource_name !== null) {
            $resourcePath = str_replace(
                '{' . 'resourceName' . '}',
                ObjectSerializer::toPathValue($resource_name),
                $resourcePath
            );
        }
        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemID' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiResourceItemSave
     *
     * ResourceItemSave
     *
     * @param  string $resource_name The name of the Resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     * @param  \Swagger\Client\Model\ResourceItemSaveBodyWrapper $body  (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiResourceItemSave($resource_name, $item_id, $body)
    {
        list($response) = $this->restApiResourceItemSaveWithHttpInfo($resource_name, $item_id, $body);
        return $response;
    }

    /**
     * Operation restApiResourceItemSaveWithHttpInfo
     *
     * ResourceItemSave
     *
     * @param  string $resource_name The name of the Resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     * @param  \Swagger\Client\Model\ResourceItemSaveBodyWrapper $body  (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiResourceItemSaveWithHttpInfo($resource_name, $item_id, $body)
    {
        $returnType = 'object';
        $request = $this->restApiResourceItemSaveRequest($resource_name, $item_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiResourceItemSaveAsync
     *
     * ResourceItemSave
     *
     * @param  string $resource_name The name of the Resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     * @param  \Swagger\Client\Model\ResourceItemSaveBodyWrapper $body  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceItemSaveAsync($resource_name, $item_id, $body)
    {
        return $this->restApiResourceItemSaveAsyncWithHttpInfo($resource_name, $item_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiResourceItemSaveAsyncWithHttpInfo
     *
     * ResourceItemSave
     *
     * @param  string $resource_name The name of the Resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     * @param  \Swagger\Client\Model\ResourceItemSaveBodyWrapper $body  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceItemSaveAsyncWithHttpInfo($resource_name, $item_id, $body)
    {
        $returnType = 'object';
        $request = $this->restApiResourceItemSaveRequest($resource_name, $item_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiResourceItemSave'
     *
     * @param  string $resource_name The name of the Resource (required)
     * @param  string $item_id The ID of the ResourceItem (required)
     * @param  \Swagger\Client\Model\ResourceItemSaveBodyWrapper $body  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiResourceItemSaveRequest($resource_name, $item_id, $body)
    {
        // verify the required parameter 'resource_name' is set
        if ($resource_name === null || (is_array($resource_name) && count($resource_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource_name when calling restApiResourceItemSave'
            );
        }
        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling restApiResourceItemSave'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling restApiResourceItemSave'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/{resourceName}/items/{itemID}/save';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($resource_name !== null) {
            $resourcePath = str_replace(
                '{' . 'resourceName' . '}',
                ObjectSerializer::toPathValue($resource_name),
                $resourcePath
            );
        }
        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemID' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiResourceItemSaveCustomMetaData
     *
     * ResourceItemSaveCustomMetaData
     *
     * @param  string $resource_name  (required)
     * @param  string $id  (required)
     * @param  string $set_name  (required)
     * @param  \Swagger\Client\Model\ResourceItemSaveCustomMetaDataBodyWrapper $body  (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiResourceItemSaveCustomMetaData($resource_name, $id, $set_name, $body)
    {
        list($response) = $this->restApiResourceItemSaveCustomMetaDataWithHttpInfo($resource_name, $id, $set_name, $body);
        return $response;
    }

    /**
     * Operation restApiResourceItemSaveCustomMetaDataWithHttpInfo
     *
     * ResourceItemSaveCustomMetaData
     *
     * @param  string $resource_name  (required)
     * @param  string $id  (required)
     * @param  string $set_name  (required)
     * @param  \Swagger\Client\Model\ResourceItemSaveCustomMetaDataBodyWrapper $body  (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiResourceItemSaveCustomMetaDataWithHttpInfo($resource_name, $id, $set_name, $body)
    {
        $returnType = 'object';
        $request = $this->restApiResourceItemSaveCustomMetaDataRequest($resource_name, $id, $set_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiResourceItemSaveCustomMetaDataAsync
     *
     * ResourceItemSaveCustomMetaData
     *
     * @param  string $resource_name  (required)
     * @param  string $id  (required)
     * @param  string $set_name  (required)
     * @param  \Swagger\Client\Model\ResourceItemSaveCustomMetaDataBodyWrapper $body  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceItemSaveCustomMetaDataAsync($resource_name, $id, $set_name, $body)
    {
        return $this->restApiResourceItemSaveCustomMetaDataAsyncWithHttpInfo($resource_name, $id, $set_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiResourceItemSaveCustomMetaDataAsyncWithHttpInfo
     *
     * ResourceItemSaveCustomMetaData
     *
     * @param  string $resource_name  (required)
     * @param  string $id  (required)
     * @param  string $set_name  (required)
     * @param  \Swagger\Client\Model\ResourceItemSaveCustomMetaDataBodyWrapper $body  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceItemSaveCustomMetaDataAsyncWithHttpInfo($resource_name, $id, $set_name, $body)
    {
        $returnType = 'object';
        $request = $this->restApiResourceItemSaveCustomMetaDataRequest($resource_name, $id, $set_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiResourceItemSaveCustomMetaData'
     *
     * @param  string $resource_name  (required)
     * @param  string $id  (required)
     * @param  string $set_name  (required)
     * @param  \Swagger\Client\Model\ResourceItemSaveCustomMetaDataBodyWrapper $body  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiResourceItemSaveCustomMetaDataRequest($resource_name, $id, $set_name, $body)
    {
        // verify the required parameter 'resource_name' is set
        if ($resource_name === null || (is_array($resource_name) && count($resource_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource_name when calling restApiResourceItemSaveCustomMetaData'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restApiResourceItemSaveCustomMetaData'
            );
        }
        // verify the required parameter 'set_name' is set
        if ($set_name === null || (is_array($set_name) && count($set_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $set_name when calling restApiResourceItemSaveCustomMetaData'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling restApiResourceItemSaveCustomMetaData'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/{resourceName}/items/{id}/metadata';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($set_name !== null) {
            $queryParams['setName'] = ObjectSerializer::toQueryValue($set_name);
        }

        // path params
        if ($resource_name !== null) {
            $resourcePath = str_replace(
                '{' . 'resourceName' . '}',
                ObjectSerializer::toPathValue($resource_name),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiResourceItemsAddFromZip
     *
     * ResourceItemsAddFromZip
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $folder_path The relative path of the resource items in the resource&#39;s tree (required)
     * @param  \Swagger\Client\Model\ResourceItemsAddFromZipBodyWrapper $body  (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiResourceItemsAddFromZip($resource_name, $folder_path, $body)
    {
        list($response) = $this->restApiResourceItemsAddFromZipWithHttpInfo($resource_name, $folder_path, $body);
        return $response;
    }

    /**
     * Operation restApiResourceItemsAddFromZipWithHttpInfo
     *
     * ResourceItemsAddFromZip
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $folder_path The relative path of the resource items in the resource&#39;s tree (required)
     * @param  \Swagger\Client\Model\ResourceItemsAddFromZipBodyWrapper $body  (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiResourceItemsAddFromZipWithHttpInfo($resource_name, $folder_path, $body)
    {
        $returnType = 'object';
        $request = $this->restApiResourceItemsAddFromZipRequest($resource_name, $folder_path, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiResourceItemsAddFromZipAsync
     *
     * ResourceItemsAddFromZip
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $folder_path The relative path of the resource items in the resource&#39;s tree (required)
     * @param  \Swagger\Client\Model\ResourceItemsAddFromZipBodyWrapper $body  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceItemsAddFromZipAsync($resource_name, $folder_path, $body)
    {
        return $this->restApiResourceItemsAddFromZipAsyncWithHttpInfo($resource_name, $folder_path, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiResourceItemsAddFromZipAsyncWithHttpInfo
     *
     * ResourceItemsAddFromZip
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $folder_path The relative path of the resource items in the resource&#39;s tree (required)
     * @param  \Swagger\Client\Model\ResourceItemsAddFromZipBodyWrapper $body  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceItemsAddFromZipAsyncWithHttpInfo($resource_name, $folder_path, $body)
    {
        $returnType = 'object';
        $request = $this->restApiResourceItemsAddFromZipRequest($resource_name, $folder_path, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiResourceItemsAddFromZip'
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $folder_path The relative path of the resource items in the resource&#39;s tree (required)
     * @param  \Swagger\Client\Model\ResourceItemsAddFromZipBodyWrapper $body  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiResourceItemsAddFromZipRequest($resource_name, $folder_path, $body)
    {
        // verify the required parameter 'resource_name' is set
        if ($resource_name === null || (is_array($resource_name) && count($resource_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource_name when calling restApiResourceItemsAddFromZip'
            );
        }
        // verify the required parameter 'folder_path' is set
        if ($folder_path === null || (is_array($folder_path) && count($folder_path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $folder_path when calling restApiResourceItemsAddFromZip'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling restApiResourceItemsAddFromZip'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/{resourceName}/items/fromzip';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($folder_path !== null) {
            $queryParams['folderPath'] = ObjectSerializer::toQueryValue($folder_path);
        }

        // path params
        if ($resource_name !== null) {
            $resourcePath = str_replace(
                '{' . 'resourceName' . '}',
                ObjectSerializer::toPathValue($resource_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiResourceLibraryGetSettings
     *
     * ResourceLibraryGetSettings
     *
     * @param  string $resource_name The name of the Resource (required)
     * @param  string $library_name The name of the library for which to return the settings (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiResourceLibraryGetSettings($resource_name, $library_name)
    {
        list($response) = $this->restApiResourceLibraryGetSettingsWithHttpInfo($resource_name, $library_name);
        return $response;
    }

    /**
     * Operation restApiResourceLibraryGetSettingsWithHttpInfo
     *
     * ResourceLibraryGetSettings
     *
     * @param  string $resource_name The name of the Resource (required)
     * @param  string $library_name The name of the library for which to return the settings (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiResourceLibraryGetSettingsWithHttpInfo($resource_name, $library_name)
    {
        $returnType = 'object';
        $request = $this->restApiResourceLibraryGetSettingsRequest($resource_name, $library_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiResourceLibraryGetSettingsAsync
     *
     * ResourceLibraryGetSettings
     *
     * @param  string $resource_name The name of the Resource (required)
     * @param  string $library_name The name of the library for which to return the settings (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceLibraryGetSettingsAsync($resource_name, $library_name)
    {
        return $this->restApiResourceLibraryGetSettingsAsyncWithHttpInfo($resource_name, $library_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiResourceLibraryGetSettingsAsyncWithHttpInfo
     *
     * ResourceLibraryGetSettings
     *
     * @param  string $resource_name The name of the Resource (required)
     * @param  string $library_name The name of the library for which to return the settings (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceLibraryGetSettingsAsyncWithHttpInfo($resource_name, $library_name)
    {
        $returnType = 'object';
        $request = $this->restApiResourceLibraryGetSettingsRequest($resource_name, $library_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiResourceLibraryGetSettings'
     *
     * @param  string $resource_name The name of the Resource (required)
     * @param  string $library_name The name of the library for which to return the settings (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiResourceLibraryGetSettingsRequest($resource_name, $library_name)
    {
        // verify the required parameter 'resource_name' is set
        if ($resource_name === null || (is_array($resource_name) && count($resource_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource_name when calling restApiResourceLibraryGetSettings'
            );
        }
        // verify the required parameter 'library_name' is set
        if ($library_name === null || (is_array($library_name) && count($library_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $library_name when calling restApiResourceLibraryGetSettings'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/{resourceName}/folders/settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($library_name !== null) {
            $queryParams['libraryName'] = ObjectSerializer::toQueryValue($library_name);
        }

        // path params
        if ($resource_name !== null) {
            $resourcePath = str_replace(
                '{' . 'resourceName' . '}',
                ObjectSerializer::toPathValue($resource_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiResourceLibrarySaveSettings
     *
     * ResourceLibrarySaveSettings
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $folder_name The name of the library for which to save the settings (required)
     * @param  \Swagger\Client\Model\ResourceLibrarySaveSettingsBodyWrapper $body  (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiResourceLibrarySaveSettings($resource_name, $folder_name, $body)
    {
        list($response) = $this->restApiResourceLibrarySaveSettingsWithHttpInfo($resource_name, $folder_name, $body);
        return $response;
    }

    /**
     * Operation restApiResourceLibrarySaveSettingsWithHttpInfo
     *
     * ResourceLibrarySaveSettings
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $folder_name The name of the library for which to save the settings (required)
     * @param  \Swagger\Client\Model\ResourceLibrarySaveSettingsBodyWrapper $body  (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiResourceLibrarySaveSettingsWithHttpInfo($resource_name, $folder_name, $body)
    {
        $returnType = 'object';
        $request = $this->restApiResourceLibrarySaveSettingsRequest($resource_name, $folder_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiResourceLibrarySaveSettingsAsync
     *
     * ResourceLibrarySaveSettings
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $folder_name The name of the library for which to save the settings (required)
     * @param  \Swagger\Client\Model\ResourceLibrarySaveSettingsBodyWrapper $body  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceLibrarySaveSettingsAsync($resource_name, $folder_name, $body)
    {
        return $this->restApiResourceLibrarySaveSettingsAsyncWithHttpInfo($resource_name, $folder_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiResourceLibrarySaveSettingsAsyncWithHttpInfo
     *
     * ResourceLibrarySaveSettings
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $folder_name The name of the library for which to save the settings (required)
     * @param  \Swagger\Client\Model\ResourceLibrarySaveSettingsBodyWrapper $body  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceLibrarySaveSettingsAsyncWithHttpInfo($resource_name, $folder_name, $body)
    {
        $returnType = 'object';
        $request = $this->restApiResourceLibrarySaveSettingsRequest($resource_name, $folder_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiResourceLibrarySaveSettings'
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $folder_name The name of the library for which to save the settings (required)
     * @param  \Swagger\Client\Model\ResourceLibrarySaveSettingsBodyWrapper $body  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiResourceLibrarySaveSettingsRequest($resource_name, $folder_name, $body)
    {
        // verify the required parameter 'resource_name' is set
        if ($resource_name === null || (is_array($resource_name) && count($resource_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource_name when calling restApiResourceLibrarySaveSettings'
            );
        }
        // verify the required parameter 'folder_name' is set
        if ($folder_name === null || (is_array($folder_name) && count($folder_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $folder_name when calling restApiResourceLibrarySaveSettings'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling restApiResourceLibrarySaveSettings'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/{resourceName}/folders/settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($folder_name !== null) {
            $queryParams['folderName'] = ObjectSerializer::toQueryValue($folder_name);
        }

        // path params
        if ($resource_name !== null) {
            $resourcePath = str_replace(
                '{' . 'resourceName' . '}',
                ObjectSerializer::toPathValue($resource_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiResourceList
     *
     * ResourceList
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiResourceList()
    {
        list($response) = $this->restApiResourceListWithHttpInfo();
        return $response;
    }

    /**
     * Operation restApiResourceListWithHttpInfo
     *
     * ResourceList
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiResourceListWithHttpInfo()
    {
        $returnType = 'object';
        $request = $this->restApiResourceListRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiResourceListAsync
     *
     * ResourceList
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceListAsync()
    {
        return $this->restApiResourceListAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiResourceListAsyncWithHttpInfo
     *
     * ResourceList
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceListAsyncWithHttpInfo()
    {
        $returnType = 'object';
        $request = $this->restApiResourceListRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiResourceList'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiResourceListRequest()
    {

        $resourcePath = '/rest-api/v1.2/resources';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiResourceSearch
     *
     * ResourceSearch
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $name The name to search on (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiResourceSearch($resource_name, $name = null)
    {
        list($response) = $this->restApiResourceSearchWithHttpInfo($resource_name, $name);
        return $response;
    }

    /**
     * Operation restApiResourceSearchWithHttpInfo
     *
     * ResourceSearch
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $name The name to search on (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiResourceSearchWithHttpInfo($resource_name, $name = null)
    {
        $returnType = 'object';
        $request = $this->restApiResourceSearchRequest($resource_name, $name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiResourceSearchAsync
     *
     * ResourceSearch
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $name The name to search on (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceSearchAsync($resource_name, $name = null)
    {
        return $this->restApiResourceSearchAsyncWithHttpInfo($resource_name, $name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiResourceSearchAsyncWithHttpInfo
     *
     * ResourceSearch
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $name The name to search on (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceSearchAsyncWithHttpInfo($resource_name, $name = null)
    {
        $returnType = 'object';
        $request = $this->restApiResourceSearchRequest($resource_name, $name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiResourceSearch'
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $name The name to search on (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiResourceSearchRequest($resource_name, $name = null)
    {
        // verify the required parameter 'resource_name' is set
        if ($resource_name === null || (is_array($resource_name) && count($resource_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource_name when calling restApiResourceSearch'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/{resourceName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }

        // path params
        if ($resource_name !== null) {
            $resourcePath = str_replace(
                '{' . 'resourceName' . '}',
                ObjectSerializer::toPathValue($resource_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiResourceSearchByIDs
     *
     * ResourceSearchByIDs
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $i_ds A &#39;;&#39; separated list of IDs to search for (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiResourceSearchByIDs($resource_name, $i_ds = null)
    {
        list($response) = $this->restApiResourceSearchByIDsWithHttpInfo($resource_name, $i_ds);
        return $response;
    }

    /**
     * Operation restApiResourceSearchByIDsWithHttpInfo
     *
     * ResourceSearchByIDs
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $i_ds A &#39;;&#39; separated list of IDs to search for (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiResourceSearchByIDsWithHttpInfo($resource_name, $i_ds = null)
    {
        $returnType = 'object';
        $request = $this->restApiResourceSearchByIDsRequest($resource_name, $i_ds);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiResourceSearchByIDsAsync
     *
     * ResourceSearchByIDs
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $i_ds A &#39;;&#39; separated list of IDs to search for (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceSearchByIDsAsync($resource_name, $i_ds = null)
    {
        return $this->restApiResourceSearchByIDsAsyncWithHttpInfo($resource_name, $i_ds)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiResourceSearchByIDsAsyncWithHttpInfo
     *
     * ResourceSearchByIDs
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $i_ds A &#39;;&#39; separated list of IDs to search for (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceSearchByIDsAsyncWithHttpInfo($resource_name, $i_ds = null)
    {
        $returnType = 'object';
        $request = $this->restApiResourceSearchByIDsRequest($resource_name, $i_ds);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiResourceSearchByIDs'
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $i_ds A &#39;;&#39; separated list of IDs to search for (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiResourceSearchByIDsRequest($resource_name, $i_ds = null)
    {
        // verify the required parameter 'resource_name' is set
        if ($resource_name === null || (is_array($resource_name) && count($resource_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource_name when calling restApiResourceSearchByIDs'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/{resourceName}/byid';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($i_ds !== null) {
            $queryParams['IDs'] = ObjectSerializer::toQueryValue($i_ds);
        }

        // path params
        if ($resource_name !== null) {
            $resourcePath = str_replace(
                '{' . 'resourceName' . '}',
                ObjectSerializer::toPathValue($resource_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiResourceSearchInFolder
     *
     * ResourceSearchInFolder
     *
     * @param  string $resource_name The name of the Resource in which to search (required)
     * @param  string $parent_folder_path The folder path where the search will originate (required)
     * @param  bool $include_sub_directories If true, the search will include files of sub-directories (optional)
     * @param  string $name The name to search on (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiResourceSearchInFolder($resource_name, $parent_folder_path, $include_sub_directories = null, $name = null)
    {
        list($response) = $this->restApiResourceSearchInFolderWithHttpInfo($resource_name, $parent_folder_path, $include_sub_directories, $name);
        return $response;
    }

    /**
     * Operation restApiResourceSearchInFolderWithHttpInfo
     *
     * ResourceSearchInFolder
     *
     * @param  string $resource_name The name of the Resource in which to search (required)
     * @param  string $parent_folder_path The folder path where the search will originate (required)
     * @param  bool $include_sub_directories If true, the search will include files of sub-directories (optional)
     * @param  string $name The name to search on (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiResourceSearchInFolderWithHttpInfo($resource_name, $parent_folder_path, $include_sub_directories = null, $name = null)
    {
        $returnType = 'object';
        $request = $this->restApiResourceSearchInFolderRequest($resource_name, $parent_folder_path, $include_sub_directories, $name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiResourceSearchInFolderAsync
     *
     * ResourceSearchInFolder
     *
     * @param  string $resource_name The name of the Resource in which to search (required)
     * @param  string $parent_folder_path The folder path where the search will originate (required)
     * @param  bool $include_sub_directories If true, the search will include files of sub-directories (optional)
     * @param  string $name The name to search on (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceSearchInFolderAsync($resource_name, $parent_folder_path, $include_sub_directories = null, $name = null)
    {
        return $this->restApiResourceSearchInFolderAsyncWithHttpInfo($resource_name, $parent_folder_path, $include_sub_directories, $name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiResourceSearchInFolderAsyncWithHttpInfo
     *
     * ResourceSearchInFolder
     *
     * @param  string $resource_name The name of the Resource in which to search (required)
     * @param  string $parent_folder_path The folder path where the search will originate (required)
     * @param  bool $include_sub_directories If true, the search will include files of sub-directories (optional)
     * @param  string $name The name to search on (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceSearchInFolderAsyncWithHttpInfo($resource_name, $parent_folder_path, $include_sub_directories = null, $name = null)
    {
        $returnType = 'object';
        $request = $this->restApiResourceSearchInFolderRequest($resource_name, $parent_folder_path, $include_sub_directories, $name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiResourceSearchInFolder'
     *
     * @param  string $resource_name The name of the Resource in which to search (required)
     * @param  string $parent_folder_path The folder path where the search will originate (required)
     * @param  bool $include_sub_directories If true, the search will include files of sub-directories (optional)
     * @param  string $name The name to search on (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiResourceSearchInFolderRequest($resource_name, $parent_folder_path, $include_sub_directories = null, $name = null)
    {
        // verify the required parameter 'resource_name' is set
        if ($resource_name === null || (is_array($resource_name) && count($resource_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource_name when calling restApiResourceSearchInFolder'
            );
        }
        // verify the required parameter 'parent_folder_path' is set
        if ($parent_folder_path === null || (is_array($parent_folder_path) && count($parent_folder_path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $parent_folder_path when calling restApiResourceSearchInFolder'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/{resourceName}/infolder';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($parent_folder_path !== null) {
            $queryParams['parentFolderPath'] = ObjectSerializer::toQueryValue($parent_folder_path);
        }
        // query params
        if ($include_sub_directories !== null) {
            $queryParams['includeSubDirectories'] = ObjectSerializer::toQueryValue($include_sub_directories);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }

        // path params
        if ($resource_name !== null) {
            $resourcePath = str_replace(
                '{' . 'resourceName' . '}',
                ObjectSerializer::toPathValue($resource_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiResourceSearchPaged
     *
     * ResourceSearchPaged
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $name The name to search on (optional)
     * @param  int $page_size Number of items per page (optional)
     * @param  int $page_num 1-based index of the page to return (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiResourceSearchPaged($resource_name, $name = null, $page_size = null, $page_num = null)
    {
        list($response) = $this->restApiResourceSearchPagedWithHttpInfo($resource_name, $name, $page_size, $page_num);
        return $response;
    }

    /**
     * Operation restApiResourceSearchPagedWithHttpInfo
     *
     * ResourceSearchPaged
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $name The name to search on (optional)
     * @param  int $page_size Number of items per page (optional)
     * @param  int $page_num 1-based index of the page to return (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiResourceSearchPagedWithHttpInfo($resource_name, $name = null, $page_size = null, $page_num = null)
    {
        $returnType = 'object';
        $request = $this->restApiResourceSearchPagedRequest($resource_name, $name, $page_size, $page_num);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiResourceSearchPagedAsync
     *
     * ResourceSearchPaged
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $name The name to search on (optional)
     * @param  int $page_size Number of items per page (optional)
     * @param  int $page_num 1-based index of the page to return (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceSearchPagedAsync($resource_name, $name = null, $page_size = null, $page_num = null)
    {
        return $this->restApiResourceSearchPagedAsyncWithHttpInfo($resource_name, $name, $page_size, $page_num)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiResourceSearchPagedAsyncWithHttpInfo
     *
     * ResourceSearchPaged
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $name The name to search on (optional)
     * @param  int $page_size Number of items per page (optional)
     * @param  int $page_num 1-based index of the page to return (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceSearchPagedAsyncWithHttpInfo($resource_name, $name = null, $page_size = null, $page_num = null)
    {
        $returnType = 'object';
        $request = $this->restApiResourceSearchPagedRequest($resource_name, $name, $page_size, $page_num);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiResourceSearchPaged'
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $name The name to search on (optional)
     * @param  int $page_size Number of items per page (optional)
     * @param  int $page_num 1-based index of the page to return (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiResourceSearchPagedRequest($resource_name, $name = null, $page_size = null, $page_num = null)
    {
        // verify the required parameter 'resource_name' is set
        if ($resource_name === null || (is_array($resource_name) && count($resource_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource_name when calling restApiResourceSearchPaged'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/{resourceName}/paged';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size);
        }
        // query params
        if ($page_num !== null) {
            $queryParams['pageNum'] = ObjectSerializer::toQueryValue($page_num);
        }

        // path params
        if ($resource_name !== null) {
            $resourcePath = str_replace(
                '{' . 'resourceName' . '}',
                ObjectSerializer::toPathValue($resource_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiResourceSearchPagedWithSorting
     *
     * ResourceSearchPagedWithSorting
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $parent_folder_path  (optional)
     * @param  bool $include_sub_directories  (optional)
     * @param  string $name The name to search on (optional)
     * @param  int $page_size Number of items per page (optional)
     * @param  int $page_num 1-based index of the page to return (optional)
     * @param  string $sort_on  (optional)
     * @param  string $sort_order  (optional)
     * @param  string $item_id  (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiResourceSearchPagedWithSorting($resource_name, $parent_folder_path = null, $include_sub_directories = null, $name = null, $page_size = null, $page_num = null, $sort_on = null, $sort_order = null, $item_id = null)
    {
        list($response) = $this->restApiResourceSearchPagedWithSortingWithHttpInfo($resource_name, $parent_folder_path, $include_sub_directories, $name, $page_size, $page_num, $sort_on, $sort_order, $item_id);
        return $response;
    }

    /**
     * Operation restApiResourceSearchPagedWithSortingWithHttpInfo
     *
     * ResourceSearchPagedWithSorting
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $parent_folder_path  (optional)
     * @param  bool $include_sub_directories  (optional)
     * @param  string $name The name to search on (optional)
     * @param  int $page_size Number of items per page (optional)
     * @param  int $page_num 1-based index of the page to return (optional)
     * @param  string $sort_on  (optional)
     * @param  string $sort_order  (optional)
     * @param  string $item_id  (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiResourceSearchPagedWithSortingWithHttpInfo($resource_name, $parent_folder_path = null, $include_sub_directories = null, $name = null, $page_size = null, $page_num = null, $sort_on = null, $sort_order = null, $item_id = null)
    {
        $returnType = 'object';
        $request = $this->restApiResourceSearchPagedWithSortingRequest($resource_name, $parent_folder_path, $include_sub_directories, $name, $page_size, $page_num, $sort_on, $sort_order, $item_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiResourceSearchPagedWithSortingAsync
     *
     * ResourceSearchPagedWithSorting
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $parent_folder_path  (optional)
     * @param  bool $include_sub_directories  (optional)
     * @param  string $name The name to search on (optional)
     * @param  int $page_size Number of items per page (optional)
     * @param  int $page_num 1-based index of the page to return (optional)
     * @param  string $sort_on  (optional)
     * @param  string $sort_order  (optional)
     * @param  string $item_id  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceSearchPagedWithSortingAsync($resource_name, $parent_folder_path = null, $include_sub_directories = null, $name = null, $page_size = null, $page_num = null, $sort_on = null, $sort_order = null, $item_id = null)
    {
        return $this->restApiResourceSearchPagedWithSortingAsyncWithHttpInfo($resource_name, $parent_folder_path, $include_sub_directories, $name, $page_size, $page_num, $sort_on, $sort_order, $item_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiResourceSearchPagedWithSortingAsyncWithHttpInfo
     *
     * ResourceSearchPagedWithSorting
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $parent_folder_path  (optional)
     * @param  bool $include_sub_directories  (optional)
     * @param  string $name The name to search on (optional)
     * @param  int $page_size Number of items per page (optional)
     * @param  int $page_num 1-based index of the page to return (optional)
     * @param  string $sort_on  (optional)
     * @param  string $sort_order  (optional)
     * @param  string $item_id  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiResourceSearchPagedWithSortingAsyncWithHttpInfo($resource_name, $parent_folder_path = null, $include_sub_directories = null, $name = null, $page_size = null, $page_num = null, $sort_on = null, $sort_order = null, $item_id = null)
    {
        $returnType = 'object';
        $request = $this->restApiResourceSearchPagedWithSortingRequest($resource_name, $parent_folder_path, $include_sub_directories, $name, $page_size, $page_num, $sort_on, $sort_order, $item_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiResourceSearchPagedWithSorting'
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $parent_folder_path  (optional)
     * @param  bool $include_sub_directories  (optional)
     * @param  string $name The name to search on (optional)
     * @param  int $page_size Number of items per page (optional)
     * @param  int $page_num 1-based index of the page to return (optional)
     * @param  string $sort_on  (optional)
     * @param  string $sort_order  (optional)
     * @param  string $item_id  (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiResourceSearchPagedWithSortingRequest($resource_name, $parent_folder_path = null, $include_sub_directories = null, $name = null, $page_size = null, $page_num = null, $sort_on = null, $sort_order = null, $item_id = null)
    {
        // verify the required parameter 'resource_name' is set
        if ($resource_name === null || (is_array($resource_name) && count($resource_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource_name when calling restApiResourceSearchPagedWithSorting'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/{resourceName}/sorted';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($parent_folder_path !== null) {
            $queryParams['parentFolderPath'] = ObjectSerializer::toQueryValue($parent_folder_path);
        }
        // query params
        if ($include_sub_directories !== null) {
            $queryParams['includeSubDirectories'] = ObjectSerializer::toQueryValue($include_sub_directories);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size);
        }
        // query params
        if ($page_num !== null) {
            $queryParams['pageNum'] = ObjectSerializer::toQueryValue($page_num);
        }
        // query params
        if ($sort_on !== null) {
            $queryParams['sortOn'] = ObjectSerializer::toQueryValue($sort_on);
        }
        // query params
        if ($sort_order !== null) {
            $queryParams['sortOrder'] = ObjectSerializer::toQueryValue($sort_order);
        }
        // query params
        if ($item_id !== null) {
            $queryParams['itemID'] = ObjectSerializer::toQueryValue($item_id);
        }

        // path params
        if ($resource_name !== null) {
            $resourcePath = str_replace(
                '{' . 'resourceName' . '}',
                ObjectSerializer::toPathValue($resource_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiSetNextResourceItemID
     *
     * SetNextResourceItemID
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_id The name to search on (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiSetNextResourceItemID($resource_name, $item_id)
    {
        list($response) = $this->restApiSetNextResourceItemIDWithHttpInfo($resource_name, $item_id);
        return $response;
    }

    /**
     * Operation restApiSetNextResourceItemIDWithHttpInfo
     *
     * SetNextResourceItemID
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_id The name to search on (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiSetNextResourceItemIDWithHttpInfo($resource_name, $item_id)
    {
        $returnType = 'object';
        $request = $this->restApiSetNextResourceItemIDRequest($resource_name, $item_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiSetNextResourceItemIDAsync
     *
     * SetNextResourceItemID
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_id The name to search on (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiSetNextResourceItemIDAsync($resource_name, $item_id)
    {
        return $this->restApiSetNextResourceItemIDAsyncWithHttpInfo($resource_name, $item_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiSetNextResourceItemIDAsyncWithHttpInfo
     *
     * SetNextResourceItemID
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_id The name to search on (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiSetNextResourceItemIDAsyncWithHttpInfo($resource_name, $item_id)
    {
        $returnType = 'object';
        $request = $this->restApiSetNextResourceItemIDRequest($resource_name, $item_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiSetNextResourceItemID'
     *
     * @param  string $resource_name The name of the resource (required)
     * @param  string $item_id The name to search on (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiSetNextResourceItemIDRequest($resource_name, $item_id)
    {
        // verify the required parameter 'resource_name' is set
        if ($resource_name === null || (is_array($resource_name) && count($resource_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource_name when calling restApiSetNextResourceItemID'
            );
        }
        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling restApiSetNextResourceItemID'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/{resourceName}/nextitemid';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($item_id !== null) {
            $queryParams['itemID'] = ObjectSerializer::toQueryValue($item_id);
        }

        // path params
        if ($resource_name !== null) {
            $resourcePath = str_replace(
                '{' . 'resourceName' . '}',
                ObjectSerializer::toPathValue($resource_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiThreeDModelCreatePackage
     *
     * ThreeDModelCreatePackage
     *
     * @param  string $three_d_model_id  (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiThreeDModelCreatePackage($three_d_model_id)
    {
        list($response) = $this->restApiThreeDModelCreatePackageWithHttpInfo($three_d_model_id);
        return $response;
    }

    /**
     * Operation restApiThreeDModelCreatePackageWithHttpInfo
     *
     * ThreeDModelCreatePackage
     *
     * @param  string $three_d_model_id  (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiThreeDModelCreatePackageWithHttpInfo($three_d_model_id)
    {
        $returnType = 'object';
        $request = $this->restApiThreeDModelCreatePackageRequest($three_d_model_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiThreeDModelCreatePackageAsync
     *
     * ThreeDModelCreatePackage
     *
     * @param  string $three_d_model_id  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiThreeDModelCreatePackageAsync($three_d_model_id)
    {
        return $this->restApiThreeDModelCreatePackageAsyncWithHttpInfo($three_d_model_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiThreeDModelCreatePackageAsyncWithHttpInfo
     *
     * ThreeDModelCreatePackage
     *
     * @param  string $three_d_model_id  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiThreeDModelCreatePackageAsyncWithHttpInfo($three_d_model_id)
    {
        $returnType = 'object';
        $request = $this->restApiThreeDModelCreatePackageRequest($three_d_model_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiThreeDModelCreatePackage'
     *
     * @param  string $three_d_model_id  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiThreeDModelCreatePackageRequest($three_d_model_id)
    {
        // verify the required parameter 'three_d_model_id' is set
        if ($three_d_model_id === null || (is_array($three_d_model_id) && count($three_d_model_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $three_d_model_id when calling restApiThreeDModelCreatePackage'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/3dmodels/{threeDModelId}/package';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($three_d_model_id !== null) {
            $resourcePath = str_replace(
                '{' . 'threeDModelId' . '}',
                ObjectSerializer::toPathValue($three_d_model_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restApiUploadExternalAsset
     *
     * UploadExternalAsset
     *
     * @param  string $url The URL to post the asset to (required)
     * @param  string $file_name The name of the uploaded file (required)
     * @param  \Swagger\Client\Model\UploadExternalAssetBodyWrapper $body  (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restApiUploadExternalAsset($url, $file_name, $body)
    {
        list($response) = $this->restApiUploadExternalAssetWithHttpInfo($url, $file_name, $body);
        return $response;
    }

    /**
     * Operation restApiUploadExternalAssetWithHttpInfo
     *
     * UploadExternalAsset
     *
     * @param  string $url The URL to post the asset to (required)
     * @param  string $file_name The name of the uploaded file (required)
     * @param  \Swagger\Client\Model\UploadExternalAssetBodyWrapper $body  (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restApiUploadExternalAssetWithHttpInfo($url, $file_name, $body)
    {
        $returnType = 'object';
        $request = $this->restApiUploadExternalAssetRequest($url, $file_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restApiUploadExternalAssetAsync
     *
     * UploadExternalAsset
     *
     * @param  string $url The URL to post the asset to (required)
     * @param  string $file_name The name of the uploaded file (required)
     * @param  \Swagger\Client\Model\UploadExternalAssetBodyWrapper $body  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiUploadExternalAssetAsync($url, $file_name, $body)
    {
        return $this->restApiUploadExternalAssetAsyncWithHttpInfo($url, $file_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restApiUploadExternalAssetAsyncWithHttpInfo
     *
     * UploadExternalAsset
     *
     * @param  string $url The URL to post the asset to (required)
     * @param  string $file_name The name of the uploaded file (required)
     * @param  \Swagger\Client\Model\UploadExternalAssetBodyWrapper $body  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restApiUploadExternalAssetAsyncWithHttpInfo($url, $file_name, $body)
    {
        $returnType = 'object';
        $request = $this->restApiUploadExternalAssetRequest($url, $file_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restApiUploadExternalAsset'
     *
     * @param  string $url The URL to post the asset to (required)
     * @param  string $file_name The name of the uploaded file (required)
     * @param  \Swagger\Client\Model\UploadExternalAssetBodyWrapper $body  (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restApiUploadExternalAssetRequest($url, $file_name, $body)
    {
        // verify the required parameter 'url' is set
        if ($url === null || (is_array($url) && count($url) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $url when calling restApiUploadExternalAsset'
            );
        }
        // verify the required parameter 'file_name' is set
        if ($file_name === null || (is_array($file_name) && count($file_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_name when calling restApiUploadExternalAsset'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling restApiUploadExternalAsset'
            );
        }

        $resourcePath = '/rest-api/v1.2/resources/assets/external';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($url !== null) {
            $queryParams['url'] = ObjectSerializer::toQueryValue($url);
        }
        // query params
        if ($file_name !== null) {
            $queryParams['fileName'] = ObjectSerializer::toQueryValue($file_name);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
